(self["webpackChunkdesktop"] = self["webpackChunkdesktop"] || []).push([["src_asset_ts_test_ts"],{

/***/ 541:
/*!******************************!*\
  !*** ./src/asset/ts/test.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Test: () => (/* binding */ Test)
/* harmony export */ });
/* harmony import */ var ispace_core_main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ispace.core.main */ 262);
/* harmony import */ var ispace_core_main__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ispace_core_main__WEBPACK_IMPORTED_MODULE_0__);

class Test {
    constructor() {
        ispace_core_main__WEBPACK_IMPORTED_MODULE_0__.auth.login("alei", "1qaz@WSX").subscribe(res => {
            console.log(res);
        });
        this.name = "test";
        this.version = "1.0.0";
    }
}


/***/ }),

/***/ 262:
/*!*************************************!*\
  !*** ../../core/front/dist/core.js ***!
  \*************************************/
/***/ (function(module) {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/rxjs/dist/cjs/index.js":
/*!*********************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;\nexports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;\nexports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;\nexports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;\nvar Observable_1 = __webpack_require__(/*! ./internal/Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nObject.defineProperty(exports, \"Observable\", ({ enumerable: true, get: function () { return Observable_1.Observable; } }));\nvar ConnectableObservable_1 = __webpack_require__(/*! ./internal/observable/ConnectableObservable */ \"./node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js\");\nObject.defineProperty(exports, \"ConnectableObservable\", ({ enumerable: true, get: function () { return ConnectableObservable_1.ConnectableObservable; } }));\nvar observable_1 = __webpack_require__(/*! ./internal/symbol/observable */ \"./node_modules/rxjs/dist/cjs/internal/symbol/observable.js\");\nObject.defineProperty(exports, \"observable\", ({ enumerable: true, get: function () { return observable_1.observable; } }));\nvar animationFrames_1 = __webpack_require__(/*! ./internal/observable/dom/animationFrames */ \"./node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js\");\nObject.defineProperty(exports, \"animationFrames\", ({ enumerable: true, get: function () { return animationFrames_1.animationFrames; } }));\nvar Subject_1 = __webpack_require__(/*! ./internal/Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nObject.defineProperty(exports, \"Subject\", ({ enumerable: true, get: function () { return Subject_1.Subject; } }));\nvar BehaviorSubject_1 = __webpack_require__(/*! ./internal/BehaviorSubject */ \"./node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js\");\nObject.defineProperty(exports, \"BehaviorSubject\", ({ enumerable: true, get: function () { return BehaviorSubject_1.BehaviorSubject; } }));\nvar ReplaySubject_1 = __webpack_require__(/*! ./internal/ReplaySubject */ \"./node_modules/rxjs/dist/cjs/internal/ReplaySubject.js\");\nObject.defineProperty(exports, \"ReplaySubject\", ({ enumerable: true, get: function () { return ReplaySubject_1.ReplaySubject; } }));\nvar AsyncSubject_1 = __webpack_require__(/*! ./internal/AsyncSubject */ \"./node_modules/rxjs/dist/cjs/internal/AsyncSubject.js\");\nObject.defineProperty(exports, \"AsyncSubject\", ({ enumerable: true, get: function () { return AsyncSubject_1.AsyncSubject; } }));\nvar asap_1 = __webpack_require__(/*! ./internal/scheduler/asap */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/asap.js\");\nObject.defineProperty(exports, \"asap\", ({ enumerable: true, get: function () { return asap_1.asap; } }));\nObject.defineProperty(exports, \"asapScheduler\", ({ enumerable: true, get: function () { return asap_1.asapScheduler; } }));\nvar async_1 = __webpack_require__(/*! ./internal/scheduler/async */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/async.js\");\nObject.defineProperty(exports, \"async\", ({ enumerable: true, get: function () { return async_1.async; } }));\nObject.defineProperty(exports, \"asyncScheduler\", ({ enumerable: true, get: function () { return async_1.asyncScheduler; } }));\nvar queue_1 = __webpack_require__(/*! ./internal/scheduler/queue */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/queue.js\");\nObject.defineProperty(exports, \"queue\", ({ enumerable: true, get: function () { return queue_1.queue; } }));\nObject.defineProperty(exports, \"queueScheduler\", ({ enumerable: true, get: function () { return queue_1.queueScheduler; } }));\nvar animationFrame_1 = __webpack_require__(/*! ./internal/scheduler/animationFrame */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js\");\nObject.defineProperty(exports, \"animationFrame\", ({ enumerable: true, get: function () { return animationFrame_1.animationFrame; } }));\nObject.defineProperty(exports, \"animationFrameScheduler\", ({ enumerable: true, get: function () { return animationFrame_1.animationFrameScheduler; } }));\nvar VirtualTimeScheduler_1 = __webpack_require__(/*! ./internal/scheduler/VirtualTimeScheduler */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js\");\nObject.defineProperty(exports, \"VirtualTimeScheduler\", ({ enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualTimeScheduler; } }));\nObject.defineProperty(exports, \"VirtualAction\", ({ enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualAction; } }));\nvar Scheduler_1 = __webpack_require__(/*! ./internal/Scheduler */ \"./node_modules/rxjs/dist/cjs/internal/Scheduler.js\");\nObject.defineProperty(exports, \"Scheduler\", ({ enumerable: true, get: function () { return Scheduler_1.Scheduler; } }));\nvar Subscription_1 = __webpack_require__(/*! ./internal/Subscription */ \"./node_modules/rxjs/dist/cjs/internal/Subscription.js\");\nObject.defineProperty(exports, \"Subscription\", ({ enumerable: true, get: function () { return Subscription_1.Subscription; } }));\nvar Subscriber_1 = __webpack_require__(/*! ./internal/Subscriber */ \"./node_modules/rxjs/dist/cjs/internal/Subscriber.js\");\nObject.defineProperty(exports, \"Subscriber\", ({ enumerable: true, get: function () { return Subscriber_1.Subscriber; } }));\nvar Notification_1 = __webpack_require__(/*! ./internal/Notification */ \"./node_modules/rxjs/dist/cjs/internal/Notification.js\");\nObject.defineProperty(exports, \"Notification\", ({ enumerable: true, get: function () { return Notification_1.Notification; } }));\nObject.defineProperty(exports, \"NotificationKind\", ({ enumerable: true, get: function () { return Notification_1.NotificationKind; } }));\nvar pipe_1 = __webpack_require__(/*! ./internal/util/pipe */ \"./node_modules/rxjs/dist/cjs/internal/util/pipe.js\");\nObject.defineProperty(exports, \"pipe\", ({ enumerable: true, get: function () { return pipe_1.pipe; } }));\nvar noop_1 = __webpack_require__(/*! ./internal/util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nObject.defineProperty(exports, \"noop\", ({ enumerable: true, get: function () { return noop_1.noop; } }));\nvar identity_1 = __webpack_require__(/*! ./internal/util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nObject.defineProperty(exports, \"identity\", ({ enumerable: true, get: function () { return identity_1.identity; } }));\nvar isObservable_1 = __webpack_require__(/*! ./internal/util/isObservable */ \"./node_modules/rxjs/dist/cjs/internal/util/isObservable.js\");\nObject.defineProperty(exports, \"isObservable\", ({ enumerable: true, get: function () { return isObservable_1.isObservable; } }));\nvar lastValueFrom_1 = __webpack_require__(/*! ./internal/lastValueFrom */ \"./node_modules/rxjs/dist/cjs/internal/lastValueFrom.js\");\nObject.defineProperty(exports, \"lastValueFrom\", ({ enumerable: true, get: function () { return lastValueFrom_1.lastValueFrom; } }));\nvar firstValueFrom_1 = __webpack_require__(/*! ./internal/firstValueFrom */ \"./node_modules/rxjs/dist/cjs/internal/firstValueFrom.js\");\nObject.defineProperty(exports, \"firstValueFrom\", ({ enumerable: true, get: function () { return firstValueFrom_1.firstValueFrom; } }));\nvar ArgumentOutOfRangeError_1 = __webpack_require__(/*! ./internal/util/ArgumentOutOfRangeError */ \"./node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js\");\nObject.defineProperty(exports, \"ArgumentOutOfRangeError\", ({ enumerable: true, get: function () { return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError; } }));\nvar EmptyError_1 = __webpack_require__(/*! ./internal/util/EmptyError */ \"./node_modules/rxjs/dist/cjs/internal/util/EmptyError.js\");\nObject.defineProperty(exports, \"EmptyError\", ({ enumerable: true, get: function () { return EmptyError_1.EmptyError; } }));\nvar NotFoundError_1 = __webpack_require__(/*! ./internal/util/NotFoundError */ \"./node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js\");\nObject.defineProperty(exports, \"NotFoundError\", ({ enumerable: true, get: function () { return NotFoundError_1.NotFoundError; } }));\nvar ObjectUnsubscribedError_1 = __webpack_require__(/*! ./internal/util/ObjectUnsubscribedError */ \"./node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js\");\nObject.defineProperty(exports, \"ObjectUnsubscribedError\", ({ enumerable: true, get: function () { return ObjectUnsubscribedError_1.ObjectUnsubscribedError; } }));\nvar SequenceError_1 = __webpack_require__(/*! ./internal/util/SequenceError */ \"./node_modules/rxjs/dist/cjs/internal/util/SequenceError.js\");\nObject.defineProperty(exports, \"SequenceError\", ({ enumerable: true, get: function () { return SequenceError_1.SequenceError; } }));\nvar timeout_1 = __webpack_require__(/*! ./internal/operators/timeout */ \"./node_modules/rxjs/dist/cjs/internal/operators/timeout.js\");\nObject.defineProperty(exports, \"TimeoutError\", ({ enumerable: true, get: function () { return timeout_1.TimeoutError; } }));\nvar UnsubscriptionError_1 = __webpack_require__(/*! ./internal/util/UnsubscriptionError */ \"./node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js\");\nObject.defineProperty(exports, \"UnsubscriptionError\", ({ enumerable: true, get: function () { return UnsubscriptionError_1.UnsubscriptionError; } }));\nvar bindCallback_1 = __webpack_require__(/*! ./internal/observable/bindCallback */ \"./node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js\");\nObject.defineProperty(exports, \"bindCallback\", ({ enumerable: true, get: function () { return bindCallback_1.bindCallback; } }));\nvar bindNodeCallback_1 = __webpack_require__(/*! ./internal/observable/bindNodeCallback */ \"./node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js\");\nObject.defineProperty(exports, \"bindNodeCallback\", ({ enumerable: true, get: function () { return bindNodeCallback_1.bindNodeCallback; } }));\nvar combineLatest_1 = __webpack_require__(/*! ./internal/observable/combineLatest */ \"./node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js\");\nObject.defineProperty(exports, \"combineLatest\", ({ enumerable: true, get: function () { return combineLatest_1.combineLatest; } }));\nvar concat_1 = __webpack_require__(/*! ./internal/observable/concat */ \"./node_modules/rxjs/dist/cjs/internal/observable/concat.js\");\nObject.defineProperty(exports, \"concat\", ({ enumerable: true, get: function () { return concat_1.concat; } }));\nvar connectable_1 = __webpack_require__(/*! ./internal/observable/connectable */ \"./node_modules/rxjs/dist/cjs/internal/observable/connectable.js\");\nObject.defineProperty(exports, \"connectable\", ({ enumerable: true, get: function () { return connectable_1.connectable; } }));\nvar defer_1 = __webpack_require__(/*! ./internal/observable/defer */ \"./node_modules/rxjs/dist/cjs/internal/observable/defer.js\");\nObject.defineProperty(exports, \"defer\", ({ enumerable: true, get: function () { return defer_1.defer; } }));\nvar empty_1 = __webpack_require__(/*! ./internal/observable/empty */ \"./node_modules/rxjs/dist/cjs/internal/observable/empty.js\");\nObject.defineProperty(exports, \"empty\", ({ enumerable: true, get: function () { return empty_1.empty; } }));\nvar forkJoin_1 = __webpack_require__(/*! ./internal/observable/forkJoin */ \"./node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js\");\nObject.defineProperty(exports, \"forkJoin\", ({ enumerable: true, get: function () { return forkJoin_1.forkJoin; } }));\nvar from_1 = __webpack_require__(/*! ./internal/observable/from */ \"./node_modules/rxjs/dist/cjs/internal/observable/from.js\");\nObject.defineProperty(exports, \"from\", ({ enumerable: true, get: function () { return from_1.from; } }));\nvar fromEvent_1 = __webpack_require__(/*! ./internal/observable/fromEvent */ \"./node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js\");\nObject.defineProperty(exports, \"fromEvent\", ({ enumerable: true, get: function () { return fromEvent_1.fromEvent; } }));\nvar fromEventPattern_1 = __webpack_require__(/*! ./internal/observable/fromEventPattern */ \"./node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js\");\nObject.defineProperty(exports, \"fromEventPattern\", ({ enumerable: true, get: function () { return fromEventPattern_1.fromEventPattern; } }));\nvar generate_1 = __webpack_require__(/*! ./internal/observable/generate */ \"./node_modules/rxjs/dist/cjs/internal/observable/generate.js\");\nObject.defineProperty(exports, \"generate\", ({ enumerable: true, get: function () { return generate_1.generate; } }));\nvar iif_1 = __webpack_require__(/*! ./internal/observable/iif */ \"./node_modules/rxjs/dist/cjs/internal/observable/iif.js\");\nObject.defineProperty(exports, \"iif\", ({ enumerable: true, get: function () { return iif_1.iif; } }));\nvar interval_1 = __webpack_require__(/*! ./internal/observable/interval */ \"./node_modules/rxjs/dist/cjs/internal/observable/interval.js\");\nObject.defineProperty(exports, \"interval\", ({ enumerable: true, get: function () { return interval_1.interval; } }));\nvar merge_1 = __webpack_require__(/*! ./internal/observable/merge */ \"./node_modules/rxjs/dist/cjs/internal/observable/merge.js\");\nObject.defineProperty(exports, \"merge\", ({ enumerable: true, get: function () { return merge_1.merge; } }));\nvar never_1 = __webpack_require__(/*! ./internal/observable/never */ \"./node_modules/rxjs/dist/cjs/internal/observable/never.js\");\nObject.defineProperty(exports, \"never\", ({ enumerable: true, get: function () { return never_1.never; } }));\nvar of_1 = __webpack_require__(/*! ./internal/observable/of */ \"./node_modules/rxjs/dist/cjs/internal/observable/of.js\");\nObject.defineProperty(exports, \"of\", ({ enumerable: true, get: function () { return of_1.of; } }));\nvar onErrorResumeNext_1 = __webpack_require__(/*! ./internal/observable/onErrorResumeNext */ \"./node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js\");\nObject.defineProperty(exports, \"onErrorResumeNext\", ({ enumerable: true, get: function () { return onErrorResumeNext_1.onErrorResumeNext; } }));\nvar pairs_1 = __webpack_require__(/*! ./internal/observable/pairs */ \"./node_modules/rxjs/dist/cjs/internal/observable/pairs.js\");\nObject.defineProperty(exports, \"pairs\", ({ enumerable: true, get: function () { return pairs_1.pairs; } }));\nvar partition_1 = __webpack_require__(/*! ./internal/observable/partition */ \"./node_modules/rxjs/dist/cjs/internal/observable/partition.js\");\nObject.defineProperty(exports, \"partition\", ({ enumerable: true, get: function () { return partition_1.partition; } }));\nvar race_1 = __webpack_require__(/*! ./internal/observable/race */ \"./node_modules/rxjs/dist/cjs/internal/observable/race.js\");\nObject.defineProperty(exports, \"race\", ({ enumerable: true, get: function () { return race_1.race; } }));\nvar range_1 = __webpack_require__(/*! ./internal/observable/range */ \"./node_modules/rxjs/dist/cjs/internal/observable/range.js\");\nObject.defineProperty(exports, \"range\", ({ enumerable: true, get: function () { return range_1.range; } }));\nvar throwError_1 = __webpack_require__(/*! ./internal/observable/throwError */ \"./node_modules/rxjs/dist/cjs/internal/observable/throwError.js\");\nObject.defineProperty(exports, \"throwError\", ({ enumerable: true, get: function () { return throwError_1.throwError; } }));\nvar timer_1 = __webpack_require__(/*! ./internal/observable/timer */ \"./node_modules/rxjs/dist/cjs/internal/observable/timer.js\");\nObject.defineProperty(exports, \"timer\", ({ enumerable: true, get: function () { return timer_1.timer; } }));\nvar using_1 = __webpack_require__(/*! ./internal/observable/using */ \"./node_modules/rxjs/dist/cjs/internal/observable/using.js\");\nObject.defineProperty(exports, \"using\", ({ enumerable: true, get: function () { return using_1.using; } }));\nvar zip_1 = __webpack_require__(/*! ./internal/observable/zip */ \"./node_modules/rxjs/dist/cjs/internal/observable/zip.js\");\nObject.defineProperty(exports, \"zip\", ({ enumerable: true, get: function () { return zip_1.zip; } }));\nvar scheduled_1 = __webpack_require__(/*! ./internal/scheduled/scheduled */ \"./node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js\");\nObject.defineProperty(exports, \"scheduled\", ({ enumerable: true, get: function () { return scheduled_1.scheduled; } }));\nvar empty_2 = __webpack_require__(/*! ./internal/observable/empty */ \"./node_modules/rxjs/dist/cjs/internal/observable/empty.js\");\nObject.defineProperty(exports, \"EMPTY\", ({ enumerable: true, get: function () { return empty_2.EMPTY; } }));\nvar never_2 = __webpack_require__(/*! ./internal/observable/never */ \"./node_modules/rxjs/dist/cjs/internal/observable/never.js\");\nObject.defineProperty(exports, \"NEVER\", ({ enumerable: true, get: function () { return never_2.NEVER; } }));\n__exportStar(__webpack_require__(/*! ./internal/types */ \"./node_modules/rxjs/dist/cjs/internal/types.js\"), exports);\nvar config_1 = __webpack_require__(/*! ./internal/config */ \"./node_modules/rxjs/dist/cjs/internal/config.js\");\nObject.defineProperty(exports, \"config\", ({ enumerable: true, get: function () { return config_1.config; } }));\nvar audit_1 = __webpack_require__(/*! ./internal/operators/audit */ \"./node_modules/rxjs/dist/cjs/internal/operators/audit.js\");\nObject.defineProperty(exports, \"audit\", ({ enumerable: true, get: function () { return audit_1.audit; } }));\nvar auditTime_1 = __webpack_require__(/*! ./internal/operators/auditTime */ \"./node_modules/rxjs/dist/cjs/internal/operators/auditTime.js\");\nObject.defineProperty(exports, \"auditTime\", ({ enumerable: true, get: function () { return auditTime_1.auditTime; } }));\nvar buffer_1 = __webpack_require__(/*! ./internal/operators/buffer */ \"./node_modules/rxjs/dist/cjs/internal/operators/buffer.js\");\nObject.defineProperty(exports, \"buffer\", ({ enumerable: true, get: function () { return buffer_1.buffer; } }));\nvar bufferCount_1 = __webpack_require__(/*! ./internal/operators/bufferCount */ \"./node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js\");\nObject.defineProperty(exports, \"bufferCount\", ({ enumerable: true, get: function () { return bufferCount_1.bufferCount; } }));\nvar bufferTime_1 = __webpack_require__(/*! ./internal/operators/bufferTime */ \"./node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js\");\nObject.defineProperty(exports, \"bufferTime\", ({ enumerable: true, get: function () { return bufferTime_1.bufferTime; } }));\nvar bufferToggle_1 = __webpack_require__(/*! ./internal/operators/bufferToggle */ \"./node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js\");\nObject.defineProperty(exports, \"bufferToggle\", ({ enumerable: true, get: function () { return bufferToggle_1.bufferToggle; } }));\nvar bufferWhen_1 = __webpack_require__(/*! ./internal/operators/bufferWhen */ \"./node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js\");\nObject.defineProperty(exports, \"bufferWhen\", ({ enumerable: true, get: function () { return bufferWhen_1.bufferWhen; } }));\nvar catchError_1 = __webpack_require__(/*! ./internal/operators/catchError */ \"./node_modules/rxjs/dist/cjs/internal/operators/catchError.js\");\nObject.defineProperty(exports, \"catchError\", ({ enumerable: true, get: function () { return catchError_1.catchError; } }));\nvar combineAll_1 = __webpack_require__(/*! ./internal/operators/combineAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/combineAll.js\");\nObject.defineProperty(exports, \"combineAll\", ({ enumerable: true, get: function () { return combineAll_1.combineAll; } }));\nvar combineLatestAll_1 = __webpack_require__(/*! ./internal/operators/combineLatestAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js\");\nObject.defineProperty(exports, \"combineLatestAll\", ({ enumerable: true, get: function () { return combineLatestAll_1.combineLatestAll; } }));\nvar combineLatestWith_1 = __webpack_require__(/*! ./internal/operators/combineLatestWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js\");\nObject.defineProperty(exports, \"combineLatestWith\", ({ enumerable: true, get: function () { return combineLatestWith_1.combineLatestWith; } }));\nvar concatAll_1 = __webpack_require__(/*! ./internal/operators/concatAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/concatAll.js\");\nObject.defineProperty(exports, \"concatAll\", ({ enumerable: true, get: function () { return concatAll_1.concatAll; } }));\nvar concatMap_1 = __webpack_require__(/*! ./internal/operators/concatMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/concatMap.js\");\nObject.defineProperty(exports, \"concatMap\", ({ enumerable: true, get: function () { return concatMap_1.concatMap; } }));\nvar concatMapTo_1 = __webpack_require__(/*! ./internal/operators/concatMapTo */ \"./node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js\");\nObject.defineProperty(exports, \"concatMapTo\", ({ enumerable: true, get: function () { return concatMapTo_1.concatMapTo; } }));\nvar concatWith_1 = __webpack_require__(/*! ./internal/operators/concatWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/concatWith.js\");\nObject.defineProperty(exports, \"concatWith\", ({ enumerable: true, get: function () { return concatWith_1.concatWith; } }));\nvar connect_1 = __webpack_require__(/*! ./internal/operators/connect */ \"./node_modules/rxjs/dist/cjs/internal/operators/connect.js\");\nObject.defineProperty(exports, \"connect\", ({ enumerable: true, get: function () { return connect_1.connect; } }));\nvar count_1 = __webpack_require__(/*! ./internal/operators/count */ \"./node_modules/rxjs/dist/cjs/internal/operators/count.js\");\nObject.defineProperty(exports, \"count\", ({ enumerable: true, get: function () { return count_1.count; } }));\nvar debounce_1 = __webpack_require__(/*! ./internal/operators/debounce */ \"./node_modules/rxjs/dist/cjs/internal/operators/debounce.js\");\nObject.defineProperty(exports, \"debounce\", ({ enumerable: true, get: function () { return debounce_1.debounce; } }));\nvar debounceTime_1 = __webpack_require__(/*! ./internal/operators/debounceTime */ \"./node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js\");\nObject.defineProperty(exports, \"debounceTime\", ({ enumerable: true, get: function () { return debounceTime_1.debounceTime; } }));\nvar defaultIfEmpty_1 = __webpack_require__(/*! ./internal/operators/defaultIfEmpty */ \"./node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js\");\nObject.defineProperty(exports, \"defaultIfEmpty\", ({ enumerable: true, get: function () { return defaultIfEmpty_1.defaultIfEmpty; } }));\nvar delay_1 = __webpack_require__(/*! ./internal/operators/delay */ \"./node_modules/rxjs/dist/cjs/internal/operators/delay.js\");\nObject.defineProperty(exports, \"delay\", ({ enumerable: true, get: function () { return delay_1.delay; } }));\nvar delayWhen_1 = __webpack_require__(/*! ./internal/operators/delayWhen */ \"./node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js\");\nObject.defineProperty(exports, \"delayWhen\", ({ enumerable: true, get: function () { return delayWhen_1.delayWhen; } }));\nvar dematerialize_1 = __webpack_require__(/*! ./internal/operators/dematerialize */ \"./node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js\");\nObject.defineProperty(exports, \"dematerialize\", ({ enumerable: true, get: function () { return dematerialize_1.dematerialize; } }));\nvar distinct_1 = __webpack_require__(/*! ./internal/operators/distinct */ \"./node_modules/rxjs/dist/cjs/internal/operators/distinct.js\");\nObject.defineProperty(exports, \"distinct\", ({ enumerable: true, get: function () { return distinct_1.distinct; } }));\nvar distinctUntilChanged_1 = __webpack_require__(/*! ./internal/operators/distinctUntilChanged */ \"./node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js\");\nObject.defineProperty(exports, \"distinctUntilChanged\", ({ enumerable: true, get: function () { return distinctUntilChanged_1.distinctUntilChanged; } }));\nvar distinctUntilKeyChanged_1 = __webpack_require__(/*! ./internal/operators/distinctUntilKeyChanged */ \"./node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js\");\nObject.defineProperty(exports, \"distinctUntilKeyChanged\", ({ enumerable: true, get: function () { return distinctUntilKeyChanged_1.distinctUntilKeyChanged; } }));\nvar elementAt_1 = __webpack_require__(/*! ./internal/operators/elementAt */ \"./node_modules/rxjs/dist/cjs/internal/operators/elementAt.js\");\nObject.defineProperty(exports, \"elementAt\", ({ enumerable: true, get: function () { return elementAt_1.elementAt; } }));\nvar endWith_1 = __webpack_require__(/*! ./internal/operators/endWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/endWith.js\");\nObject.defineProperty(exports, \"endWith\", ({ enumerable: true, get: function () { return endWith_1.endWith; } }));\nvar every_1 = __webpack_require__(/*! ./internal/operators/every */ \"./node_modules/rxjs/dist/cjs/internal/operators/every.js\");\nObject.defineProperty(exports, \"every\", ({ enumerable: true, get: function () { return every_1.every; } }));\nvar exhaust_1 = __webpack_require__(/*! ./internal/operators/exhaust */ \"./node_modules/rxjs/dist/cjs/internal/operators/exhaust.js\");\nObject.defineProperty(exports, \"exhaust\", ({ enumerable: true, get: function () { return exhaust_1.exhaust; } }));\nvar exhaustAll_1 = __webpack_require__(/*! ./internal/operators/exhaustAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js\");\nObject.defineProperty(exports, \"exhaustAll\", ({ enumerable: true, get: function () { return exhaustAll_1.exhaustAll; } }));\nvar exhaustMap_1 = __webpack_require__(/*! ./internal/operators/exhaustMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js\");\nObject.defineProperty(exports, \"exhaustMap\", ({ enumerable: true, get: function () { return exhaustMap_1.exhaustMap; } }));\nvar expand_1 = __webpack_require__(/*! ./internal/operators/expand */ \"./node_modules/rxjs/dist/cjs/internal/operators/expand.js\");\nObject.defineProperty(exports, \"expand\", ({ enumerable: true, get: function () { return expand_1.expand; } }));\nvar filter_1 = __webpack_require__(/*! ./internal/operators/filter */ \"./node_modules/rxjs/dist/cjs/internal/operators/filter.js\");\nObject.defineProperty(exports, \"filter\", ({ enumerable: true, get: function () { return filter_1.filter; } }));\nvar finalize_1 = __webpack_require__(/*! ./internal/operators/finalize */ \"./node_modules/rxjs/dist/cjs/internal/operators/finalize.js\");\nObject.defineProperty(exports, \"finalize\", ({ enumerable: true, get: function () { return finalize_1.finalize; } }));\nvar find_1 = __webpack_require__(/*! ./internal/operators/find */ \"./node_modules/rxjs/dist/cjs/internal/operators/find.js\");\nObject.defineProperty(exports, \"find\", ({ enumerable: true, get: function () { return find_1.find; } }));\nvar findIndex_1 = __webpack_require__(/*! ./internal/operators/findIndex */ \"./node_modules/rxjs/dist/cjs/internal/operators/findIndex.js\");\nObject.defineProperty(exports, \"findIndex\", ({ enumerable: true, get: function () { return findIndex_1.findIndex; } }));\nvar first_1 = __webpack_require__(/*! ./internal/operators/first */ \"./node_modules/rxjs/dist/cjs/internal/operators/first.js\");\nObject.defineProperty(exports, \"first\", ({ enumerable: true, get: function () { return first_1.first; } }));\nvar groupBy_1 = __webpack_require__(/*! ./internal/operators/groupBy */ \"./node_modules/rxjs/dist/cjs/internal/operators/groupBy.js\");\nObject.defineProperty(exports, \"groupBy\", ({ enumerable: true, get: function () { return groupBy_1.groupBy; } }));\nvar ignoreElements_1 = __webpack_require__(/*! ./internal/operators/ignoreElements */ \"./node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js\");\nObject.defineProperty(exports, \"ignoreElements\", ({ enumerable: true, get: function () { return ignoreElements_1.ignoreElements; } }));\nvar isEmpty_1 = __webpack_require__(/*! ./internal/operators/isEmpty */ \"./node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js\");\nObject.defineProperty(exports, \"isEmpty\", ({ enumerable: true, get: function () { return isEmpty_1.isEmpty; } }));\nvar last_1 = __webpack_require__(/*! ./internal/operators/last */ \"./node_modules/rxjs/dist/cjs/internal/operators/last.js\");\nObject.defineProperty(exports, \"last\", ({ enumerable: true, get: function () { return last_1.last; } }));\nvar map_1 = __webpack_require__(/*! ./internal/operators/map */ \"./node_modules/rxjs/dist/cjs/internal/operators/map.js\");\nObject.defineProperty(exports, \"map\", ({ enumerable: true, get: function () { return map_1.map; } }));\nvar mapTo_1 = __webpack_require__(/*! ./internal/operators/mapTo */ \"./node_modules/rxjs/dist/cjs/internal/operators/mapTo.js\");\nObject.defineProperty(exports, \"mapTo\", ({ enumerable: true, get: function () { return mapTo_1.mapTo; } }));\nvar materialize_1 = __webpack_require__(/*! ./internal/operators/materialize */ \"./node_modules/rxjs/dist/cjs/internal/operators/materialize.js\");\nObject.defineProperty(exports, \"materialize\", ({ enumerable: true, get: function () { return materialize_1.materialize; } }));\nvar max_1 = __webpack_require__(/*! ./internal/operators/max */ \"./node_modules/rxjs/dist/cjs/internal/operators/max.js\");\nObject.defineProperty(exports, \"max\", ({ enumerable: true, get: function () { return max_1.max; } }));\nvar mergeAll_1 = __webpack_require__(/*! ./internal/operators/mergeAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js\");\nObject.defineProperty(exports, \"mergeAll\", ({ enumerable: true, get: function () { return mergeAll_1.mergeAll; } }));\nvar flatMap_1 = __webpack_require__(/*! ./internal/operators/flatMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/flatMap.js\");\nObject.defineProperty(exports, \"flatMap\", ({ enumerable: true, get: function () { return flatMap_1.flatMap; } }));\nvar mergeMap_1 = __webpack_require__(/*! ./internal/operators/mergeMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js\");\nObject.defineProperty(exports, \"mergeMap\", ({ enumerable: true, get: function () { return mergeMap_1.mergeMap; } }));\nvar mergeMapTo_1 = __webpack_require__(/*! ./internal/operators/mergeMapTo */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js\");\nObject.defineProperty(exports, \"mergeMapTo\", ({ enumerable: true, get: function () { return mergeMapTo_1.mergeMapTo; } }));\nvar mergeScan_1 = __webpack_require__(/*! ./internal/operators/mergeScan */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js\");\nObject.defineProperty(exports, \"mergeScan\", ({ enumerable: true, get: function () { return mergeScan_1.mergeScan; } }));\nvar mergeWith_1 = __webpack_require__(/*! ./internal/operators/mergeWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js\");\nObject.defineProperty(exports, \"mergeWith\", ({ enumerable: true, get: function () { return mergeWith_1.mergeWith; } }));\nvar min_1 = __webpack_require__(/*! ./internal/operators/min */ \"./node_modules/rxjs/dist/cjs/internal/operators/min.js\");\nObject.defineProperty(exports, \"min\", ({ enumerable: true, get: function () { return min_1.min; } }));\nvar multicast_1 = __webpack_require__(/*! ./internal/operators/multicast */ \"./node_modules/rxjs/dist/cjs/internal/operators/multicast.js\");\nObject.defineProperty(exports, \"multicast\", ({ enumerable: true, get: function () { return multicast_1.multicast; } }));\nvar observeOn_1 = __webpack_require__(/*! ./internal/operators/observeOn */ \"./node_modules/rxjs/dist/cjs/internal/operators/observeOn.js\");\nObject.defineProperty(exports, \"observeOn\", ({ enumerable: true, get: function () { return observeOn_1.observeOn; } }));\nvar onErrorResumeNextWith_1 = __webpack_require__(/*! ./internal/operators/onErrorResumeNextWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js\");\nObject.defineProperty(exports, \"onErrorResumeNextWith\", ({ enumerable: true, get: function () { return onErrorResumeNextWith_1.onErrorResumeNextWith; } }));\nvar pairwise_1 = __webpack_require__(/*! ./internal/operators/pairwise */ \"./node_modules/rxjs/dist/cjs/internal/operators/pairwise.js\");\nObject.defineProperty(exports, \"pairwise\", ({ enumerable: true, get: function () { return pairwise_1.pairwise; } }));\nvar pluck_1 = __webpack_require__(/*! ./internal/operators/pluck */ \"./node_modules/rxjs/dist/cjs/internal/operators/pluck.js\");\nObject.defineProperty(exports, \"pluck\", ({ enumerable: true, get: function () { return pluck_1.pluck; } }));\nvar publish_1 = __webpack_require__(/*! ./internal/operators/publish */ \"./node_modules/rxjs/dist/cjs/internal/operators/publish.js\");\nObject.defineProperty(exports, \"publish\", ({ enumerable: true, get: function () { return publish_1.publish; } }));\nvar publishBehavior_1 = __webpack_require__(/*! ./internal/operators/publishBehavior */ \"./node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js\");\nObject.defineProperty(exports, \"publishBehavior\", ({ enumerable: true, get: function () { return publishBehavior_1.publishBehavior; } }));\nvar publishLast_1 = __webpack_require__(/*! ./internal/operators/publishLast */ \"./node_modules/rxjs/dist/cjs/internal/operators/publishLast.js\");\nObject.defineProperty(exports, \"publishLast\", ({ enumerable: true, get: function () { return publishLast_1.publishLast; } }));\nvar publishReplay_1 = __webpack_require__(/*! ./internal/operators/publishReplay */ \"./node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js\");\nObject.defineProperty(exports, \"publishReplay\", ({ enumerable: true, get: function () { return publishReplay_1.publishReplay; } }));\nvar raceWith_1 = __webpack_require__(/*! ./internal/operators/raceWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/raceWith.js\");\nObject.defineProperty(exports, \"raceWith\", ({ enumerable: true, get: function () { return raceWith_1.raceWith; } }));\nvar reduce_1 = __webpack_require__(/*! ./internal/operators/reduce */ \"./node_modules/rxjs/dist/cjs/internal/operators/reduce.js\");\nObject.defineProperty(exports, \"reduce\", ({ enumerable: true, get: function () { return reduce_1.reduce; } }));\nvar repeat_1 = __webpack_require__(/*! ./internal/operators/repeat */ \"./node_modules/rxjs/dist/cjs/internal/operators/repeat.js\");\nObject.defineProperty(exports, \"repeat\", ({ enumerable: true, get: function () { return repeat_1.repeat; } }));\nvar repeatWhen_1 = __webpack_require__(/*! ./internal/operators/repeatWhen */ \"./node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js\");\nObject.defineProperty(exports, \"repeatWhen\", ({ enumerable: true, get: function () { return repeatWhen_1.repeatWhen; } }));\nvar retry_1 = __webpack_require__(/*! ./internal/operators/retry */ \"./node_modules/rxjs/dist/cjs/internal/operators/retry.js\");\nObject.defineProperty(exports, \"retry\", ({ enumerable: true, get: function () { return retry_1.retry; } }));\nvar retryWhen_1 = __webpack_require__(/*! ./internal/operators/retryWhen */ \"./node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js\");\nObject.defineProperty(exports, \"retryWhen\", ({ enumerable: true, get: function () { return retryWhen_1.retryWhen; } }));\nvar refCount_1 = __webpack_require__(/*! ./internal/operators/refCount */ \"./node_modules/rxjs/dist/cjs/internal/operators/refCount.js\");\nObject.defineProperty(exports, \"refCount\", ({ enumerable: true, get: function () { return refCount_1.refCount; } }));\nvar sample_1 = __webpack_require__(/*! ./internal/operators/sample */ \"./node_modules/rxjs/dist/cjs/internal/operators/sample.js\");\nObject.defineProperty(exports, \"sample\", ({ enumerable: true, get: function () { return sample_1.sample; } }));\nvar sampleTime_1 = __webpack_require__(/*! ./internal/operators/sampleTime */ \"./node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js\");\nObject.defineProperty(exports, \"sampleTime\", ({ enumerable: true, get: function () { return sampleTime_1.sampleTime; } }));\nvar scan_1 = __webpack_require__(/*! ./internal/operators/scan */ \"./node_modules/rxjs/dist/cjs/internal/operators/scan.js\");\nObject.defineProperty(exports, \"scan\", ({ enumerable: true, get: function () { return scan_1.scan; } }));\nvar sequenceEqual_1 = __webpack_require__(/*! ./internal/operators/sequenceEqual */ \"./node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js\");\nObject.defineProperty(exports, \"sequenceEqual\", ({ enumerable: true, get: function () { return sequenceEqual_1.sequenceEqual; } }));\nvar share_1 = __webpack_require__(/*! ./internal/operators/share */ \"./node_modules/rxjs/dist/cjs/internal/operators/share.js\");\nObject.defineProperty(exports, \"share\", ({ enumerable: true, get: function () { return share_1.share; } }));\nvar shareReplay_1 = __webpack_require__(/*! ./internal/operators/shareReplay */ \"./node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js\");\nObject.defineProperty(exports, \"shareReplay\", ({ enumerable: true, get: function () { return shareReplay_1.shareReplay; } }));\nvar single_1 = __webpack_require__(/*! ./internal/operators/single */ \"./node_modules/rxjs/dist/cjs/internal/operators/single.js\");\nObject.defineProperty(exports, \"single\", ({ enumerable: true, get: function () { return single_1.single; } }));\nvar skip_1 = __webpack_require__(/*! ./internal/operators/skip */ \"./node_modules/rxjs/dist/cjs/internal/operators/skip.js\");\nObject.defineProperty(exports, \"skip\", ({ enumerable: true, get: function () { return skip_1.skip; } }));\nvar skipLast_1 = __webpack_require__(/*! ./internal/operators/skipLast */ \"./node_modules/rxjs/dist/cjs/internal/operators/skipLast.js\");\nObject.defineProperty(exports, \"skipLast\", ({ enumerable: true, get: function () { return skipLast_1.skipLast; } }));\nvar skipUntil_1 = __webpack_require__(/*! ./internal/operators/skipUntil */ \"./node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js\");\nObject.defineProperty(exports, \"skipUntil\", ({ enumerable: true, get: function () { return skipUntil_1.skipUntil; } }));\nvar skipWhile_1 = __webpack_require__(/*! ./internal/operators/skipWhile */ \"./node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js\");\nObject.defineProperty(exports, \"skipWhile\", ({ enumerable: true, get: function () { return skipWhile_1.skipWhile; } }));\nvar startWith_1 = __webpack_require__(/*! ./internal/operators/startWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/startWith.js\");\nObject.defineProperty(exports, \"startWith\", ({ enumerable: true, get: function () { return startWith_1.startWith; } }));\nvar subscribeOn_1 = __webpack_require__(/*! ./internal/operators/subscribeOn */ \"./node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js\");\nObject.defineProperty(exports, \"subscribeOn\", ({ enumerable: true, get: function () { return subscribeOn_1.subscribeOn; } }));\nvar switchAll_1 = __webpack_require__(/*! ./internal/operators/switchAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/switchAll.js\");\nObject.defineProperty(exports, \"switchAll\", ({ enumerable: true, get: function () { return switchAll_1.switchAll; } }));\nvar switchMap_1 = __webpack_require__(/*! ./internal/operators/switchMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/switchMap.js\");\nObject.defineProperty(exports, \"switchMap\", ({ enumerable: true, get: function () { return switchMap_1.switchMap; } }));\nvar switchMapTo_1 = __webpack_require__(/*! ./internal/operators/switchMapTo */ \"./node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js\");\nObject.defineProperty(exports, \"switchMapTo\", ({ enumerable: true, get: function () { return switchMapTo_1.switchMapTo; } }));\nvar switchScan_1 = __webpack_require__(/*! ./internal/operators/switchScan */ \"./node_modules/rxjs/dist/cjs/internal/operators/switchScan.js\");\nObject.defineProperty(exports, \"switchScan\", ({ enumerable: true, get: function () { return switchScan_1.switchScan; } }));\nvar take_1 = __webpack_require__(/*! ./internal/operators/take */ \"./node_modules/rxjs/dist/cjs/internal/operators/take.js\");\nObject.defineProperty(exports, \"take\", ({ enumerable: true, get: function () { return take_1.take; } }));\nvar takeLast_1 = __webpack_require__(/*! ./internal/operators/takeLast */ \"./node_modules/rxjs/dist/cjs/internal/operators/takeLast.js\");\nObject.defineProperty(exports, \"takeLast\", ({ enumerable: true, get: function () { return takeLast_1.takeLast; } }));\nvar takeUntil_1 = __webpack_require__(/*! ./internal/operators/takeUntil */ \"./node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js\");\nObject.defineProperty(exports, \"takeUntil\", ({ enumerable: true, get: function () { return takeUntil_1.takeUntil; } }));\nvar takeWhile_1 = __webpack_require__(/*! ./internal/operators/takeWhile */ \"./node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js\");\nObject.defineProperty(exports, \"takeWhile\", ({ enumerable: true, get: function () { return takeWhile_1.takeWhile; } }));\nvar tap_1 = __webpack_require__(/*! ./internal/operators/tap */ \"./node_modules/rxjs/dist/cjs/internal/operators/tap.js\");\nObject.defineProperty(exports, \"tap\", ({ enumerable: true, get: function () { return tap_1.tap; } }));\nvar throttle_1 = __webpack_require__(/*! ./internal/operators/throttle */ \"./node_modules/rxjs/dist/cjs/internal/operators/throttle.js\");\nObject.defineProperty(exports, \"throttle\", ({ enumerable: true, get: function () { return throttle_1.throttle; } }));\nvar throttleTime_1 = __webpack_require__(/*! ./internal/operators/throttleTime */ \"./node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js\");\nObject.defineProperty(exports, \"throttleTime\", ({ enumerable: true, get: function () { return throttleTime_1.throttleTime; } }));\nvar throwIfEmpty_1 = __webpack_require__(/*! ./internal/operators/throwIfEmpty */ \"./node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js\");\nObject.defineProperty(exports, \"throwIfEmpty\", ({ enumerable: true, get: function () { return throwIfEmpty_1.throwIfEmpty; } }));\nvar timeInterval_1 = __webpack_require__(/*! ./internal/operators/timeInterval */ \"./node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js\");\nObject.defineProperty(exports, \"timeInterval\", ({ enumerable: true, get: function () { return timeInterval_1.timeInterval; } }));\nvar timeout_2 = __webpack_require__(/*! ./internal/operators/timeout */ \"./node_modules/rxjs/dist/cjs/internal/operators/timeout.js\");\nObject.defineProperty(exports, \"timeout\", ({ enumerable: true, get: function () { return timeout_2.timeout; } }));\nvar timeoutWith_1 = __webpack_require__(/*! ./internal/operators/timeoutWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js\");\nObject.defineProperty(exports, \"timeoutWith\", ({ enumerable: true, get: function () { return timeoutWith_1.timeoutWith; } }));\nvar timestamp_1 = __webpack_require__(/*! ./internal/operators/timestamp */ \"./node_modules/rxjs/dist/cjs/internal/operators/timestamp.js\");\nObject.defineProperty(exports, \"timestamp\", ({ enumerable: true, get: function () { return timestamp_1.timestamp; } }));\nvar toArray_1 = __webpack_require__(/*! ./internal/operators/toArray */ \"./node_modules/rxjs/dist/cjs/internal/operators/toArray.js\");\nObject.defineProperty(exports, \"toArray\", ({ enumerable: true, get: function () { return toArray_1.toArray; } }));\nvar window_1 = __webpack_require__(/*! ./internal/operators/window */ \"./node_modules/rxjs/dist/cjs/internal/operators/window.js\");\nObject.defineProperty(exports, \"window\", ({ enumerable: true, get: function () { return window_1.window; } }));\nvar windowCount_1 = __webpack_require__(/*! ./internal/operators/windowCount */ \"./node_modules/rxjs/dist/cjs/internal/operators/windowCount.js\");\nObject.defineProperty(exports, \"windowCount\", ({ enumerable: true, get: function () { return windowCount_1.windowCount; } }));\nvar windowTime_1 = __webpack_require__(/*! ./internal/operators/windowTime */ \"./node_modules/rxjs/dist/cjs/internal/operators/windowTime.js\");\nObject.defineProperty(exports, \"windowTime\", ({ enumerable: true, get: function () { return windowTime_1.windowTime; } }));\nvar windowToggle_1 = __webpack_require__(/*! ./internal/operators/windowToggle */ \"./node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js\");\nObject.defineProperty(exports, \"windowToggle\", ({ enumerable: true, get: function () { return windowToggle_1.windowToggle; } }));\nvar windowWhen_1 = __webpack_require__(/*! ./internal/operators/windowWhen */ \"./node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js\");\nObject.defineProperty(exports, \"windowWhen\", ({ enumerable: true, get: function () { return windowWhen_1.windowWhen; } }));\nvar withLatestFrom_1 = __webpack_require__(/*! ./internal/operators/withLatestFrom */ \"./node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js\");\nObject.defineProperty(exports, \"withLatestFrom\", ({ enumerable: true, get: function () { return withLatestFrom_1.withLatestFrom; } }));\nvar zipAll_1 = __webpack_require__(/*! ./internal/operators/zipAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/zipAll.js\");\nObject.defineProperty(exports, \"zipAll\", ({ enumerable: true, get: function () { return zipAll_1.zipAll; } }));\nvar zipWith_1 = __webpack_require__(/*! ./internal/operators/zipWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/zipWith.js\");\nObject.defineProperty(exports, \"zipWith\", ({ enumerable: true, get: function () { return zipWith_1.zipWith; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/index.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/AsyncSubject.js":
/*!*************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/AsyncSubject.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsyncSubject = void 0;\nvar Subject_1 = __webpack_require__(/*! ./Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar AsyncSubject = (function (_super) {\n    __extends(AsyncSubject, _super);\n    function AsyncSubject() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._value = null;\n        _this._hasValue = false;\n        _this._isComplete = false;\n        return _this;\n    }\n    AsyncSubject.prototype._checkFinalizedStatuses = function (subscriber) {\n        var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;\n        if (hasError) {\n            subscriber.error(thrownError);\n        }\n        else if (isStopped || _isComplete) {\n            _hasValue && subscriber.next(_value);\n            subscriber.complete();\n        }\n    };\n    AsyncSubject.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._value = value;\n            this._hasValue = true;\n        }\n    };\n    AsyncSubject.prototype.complete = function () {\n        var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;\n        if (!_isComplete) {\n            this._isComplete = true;\n            _hasValue && _super.prototype.next.call(this, _value);\n            _super.prototype.complete.call(this);\n        }\n    };\n    return AsyncSubject;\n}(Subject_1.Subject));\nexports.AsyncSubject = AsyncSubject;\n//# sourceMappingURL=AsyncSubject.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/AsyncSubject.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BehaviorSubject = void 0;\nvar Subject_1 = __webpack_require__(/*! ./Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar BehaviorSubject = (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        var _this = _super.call(this) || this;\n        _this._value = _value;\n        return _this;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        !subscription.closed && subscriber.next(this._value);\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;\n        if (hasError) {\n            throw thrownError;\n        }\n        this._throwIfClosed();\n        return _value;\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, (this._value = value));\n    };\n    return BehaviorSubject;\n}(Subject_1.Subject));\nexports.BehaviorSubject = BehaviorSubject;\n//# sourceMappingURL=BehaviorSubject.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/Notification.js":
/*!*************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/Notification.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.observeNotification = exports.Notification = exports.NotificationKind = void 0;\nvar empty_1 = __webpack_require__(/*! ./observable/empty */ \"./node_modules/rxjs/dist/cjs/internal/observable/empty.js\");\nvar of_1 = __webpack_require__(/*! ./observable/of */ \"./node_modules/rxjs/dist/cjs/internal/observable/of.js\");\nvar throwError_1 = __webpack_require__(/*! ./observable/throwError */ \"./node_modules/rxjs/dist/cjs/internal/observable/throwError.js\");\nvar isFunction_1 = __webpack_require__(/*! ./util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nvar NotificationKind;\n(function (NotificationKind) {\n    NotificationKind[\"NEXT\"] = \"N\";\n    NotificationKind[\"ERROR\"] = \"E\";\n    NotificationKind[\"COMPLETE\"] = \"C\";\n})(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));\nvar Notification = (function () {\n    function Notification(kind, value, error) {\n        this.kind = kind;\n        this.value = value;\n        this.error = error;\n        this.hasValue = kind === 'N';\n    }\n    Notification.prototype.observe = function (observer) {\n        return observeNotification(this, observer);\n    };\n    Notification.prototype.do = function (nextHandler, errorHandler, completeHandler) {\n        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;\n        return kind === 'N' ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === 'E' ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();\n    };\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n        var _a;\n        return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next)\n            ? this.observe(nextOrObserver)\n            : this.do(nextOrObserver, error, complete);\n    };\n    Notification.prototype.toObservable = function () {\n        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;\n        var result = kind === 'N'\n            ?\n                of_1.of(value)\n            :\n                kind === 'E'\n                    ?\n                        throwError_1.throwError(function () { return error; })\n                    :\n                        kind === 'C'\n                            ?\n                                empty_1.EMPTY\n                            :\n                                0;\n        if (!result) {\n            throw new TypeError(\"Unexpected notification kind \" + kind);\n        }\n        return result;\n    };\n    Notification.createNext = function (value) {\n        return new Notification('N', value);\n    };\n    Notification.createError = function (err) {\n        return new Notification('E', undefined, err);\n    };\n    Notification.createComplete = function () {\n        return Notification.completeNotification;\n    };\n    Notification.completeNotification = new Notification('C');\n    return Notification;\n}());\nexports.Notification = Notification;\nfunction observeNotification(notification, observer) {\n    var _a, _b, _c;\n    var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;\n    if (typeof kind !== 'string') {\n        throw new TypeError('Invalid notification, missing \"kind\"');\n    }\n    kind === 'N' ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === 'E' ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);\n}\nexports.observeNotification = observeNotification;\n//# sourceMappingURL=Notification.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/Notification.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/NotificationFactories.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/NotificationFactories.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createNotification = exports.nextNotification = exports.errorNotification = exports.COMPLETE_NOTIFICATION = void 0;\nexports.COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();\nfunction errorNotification(error) {\n    return createNotification('E', undefined, error);\n}\nexports.errorNotification = errorNotification;\nfunction nextNotification(value) {\n    return createNotification('N', value, undefined);\n}\nexports.nextNotification = nextNotification;\nfunction createNotification(kind, value, error) {\n    return {\n        kind: kind,\n        value: value,\n        error: error,\n    };\n}\nexports.createNotification = createNotification;\n//# sourceMappingURL=NotificationFactories.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/NotificationFactories.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/Observable.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/Observable.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Observable = void 0;\nvar Subscriber_1 = __webpack_require__(/*! ./Subscriber */ \"./node_modules/rxjs/dist/cjs/internal/Subscriber.js\");\nvar Subscription_1 = __webpack_require__(/*! ./Subscription */ \"./node_modules/rxjs/dist/cjs/internal/Subscription.js\");\nvar observable_1 = __webpack_require__(/*! ./symbol/observable */ \"./node_modules/rxjs/dist/cjs/internal/symbol/observable.js\");\nvar pipe_1 = __webpack_require__(/*! ./util/pipe */ \"./node_modules/rxjs/dist/cjs/internal/util/pipe.js\");\nvar config_1 = __webpack_require__(/*! ./config */ \"./node_modules/rxjs/dist/cjs/internal/config.js\");\nvar isFunction_1 = __webpack_require__(/*! ./util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nvar errorContext_1 = __webpack_require__(/*! ./util/errorContext */ \"./node_modules/rxjs/dist/cjs/internal/util/errorContext.js\");\nvar Observable = (function () {\n    function Observable(subscribe) {\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var _this = this;\n        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);\n        errorContext_1.errorContext(function () {\n            var _a = _this, operator = _a.operator, source = _a.source;\n            subscriber.add(operator\n                ?\n                    operator.call(subscriber, source)\n                : source\n                    ?\n                        _this._subscribe(subscriber)\n                    :\n                        _this._trySubscribe(subscriber));\n        });\n        return subscriber;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.error(err);\n        }\n    };\n    Observable.prototype.forEach = function (next, promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var subscriber = new Subscriber_1.SafeSubscriber({\n                next: function (value) {\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscriber.unsubscribe();\n                    }\n                },\n                error: reject,\n                complete: resolve,\n            });\n            _this.subscribe(subscriber);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        var _a;\n        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);\n    };\n    Observable.prototype[observable_1.observable] = function () {\n        return this;\n    };\n    Observable.prototype.pipe = function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i] = arguments[_i];\n        }\n        return pipe_1.pipeFromArray(operations)(this);\n    };\n    Observable.prototype.toPromise = function (promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var value;\n            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });\n        });\n    };\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\nfunction getPromiseCtor(promiseCtor) {\n    var _a;\n    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;\n}\nfunction isObserver(value) {\n    return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);\n}\nfunction isSubscriber(value) {\n    return (value && value instanceof Subscriber_1.Subscriber) || (isObserver(value) && Subscription_1.isSubscription(value));\n}\n//# sourceMappingURL=Observable.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/Observable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/ReplaySubject.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/ReplaySubject.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReplaySubject = void 0;\nvar Subject_1 = __webpack_require__(/*! ./Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar dateTimestampProvider_1 = __webpack_require__(/*! ./scheduler/dateTimestampProvider */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js\");\nvar ReplaySubject = (function (_super) {\n    __extends(ReplaySubject, _super);\n    function ReplaySubject(_bufferSize, _windowTime, _timestampProvider) {\n        if (_bufferSize === void 0) { _bufferSize = Infinity; }\n        if (_windowTime === void 0) { _windowTime = Infinity; }\n        if (_timestampProvider === void 0) { _timestampProvider = dateTimestampProvider_1.dateTimestampProvider; }\n        var _this = _super.call(this) || this;\n        _this._bufferSize = _bufferSize;\n        _this._windowTime = _windowTime;\n        _this._timestampProvider = _timestampProvider;\n        _this._buffer = [];\n        _this._infiniteTimeWindow = true;\n        _this._infiniteTimeWindow = _windowTime === Infinity;\n        _this._bufferSize = Math.max(1, _bufferSize);\n        _this._windowTime = Math.max(1, _windowTime);\n        return _this;\n    }\n    ReplaySubject.prototype.next = function (value) {\n        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;\n        if (!isStopped) {\n            _buffer.push(value);\n            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n        }\n        this._trimBuffer();\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        this._throwIfClosed();\n        this._trimBuffer();\n        var subscription = this._innerSubscribe(subscriber);\n        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;\n        var copy = _buffer.slice();\n        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n            subscriber.next(copy[i]);\n        }\n        this._checkFinalizedStatuses(subscriber);\n        return subscription;\n    };\n    ReplaySubject.prototype._trimBuffer = function () {\n        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;\n        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n        if (!_infiniteTimeWindow) {\n            var now = _timestampProvider.now();\n            var last = 0;\n            for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {\n                last = i;\n            }\n            last && _buffer.splice(0, last + 1);\n        }\n    };\n    return ReplaySubject;\n}(Subject_1.Subject));\nexports.ReplaySubject = ReplaySubject;\n//# sourceMappingURL=ReplaySubject.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/ReplaySubject.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/Scheduler.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/Scheduler.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scheduler = void 0;\nvar dateTimestampProvider_1 = __webpack_require__(/*! ./scheduler/dateTimestampProvider */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js\");\nvar Scheduler = (function () {\n    function Scheduler(schedulerActionCtor, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.schedulerActionCtor = schedulerActionCtor;\n        this.now = now;\n    }\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.schedulerActionCtor(this, work).schedule(state, delay);\n    };\n    Scheduler.now = dateTimestampProvider_1.dateTimestampProvider.now;\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/Scheduler.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/Subject.js":
/*!********************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/Subject.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AnonymousSubject = exports.Subject = void 0;\nvar Observable_1 = __webpack_require__(/*! ./Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar Subscription_1 = __webpack_require__(/*! ./Subscription */ \"./node_modules/rxjs/dist/cjs/internal/Subscription.js\");\nvar ObjectUnsubscribedError_1 = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ \"./node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js\");\nvar arrRemove_1 = __webpack_require__(/*! ./util/arrRemove */ \"./node_modules/rxjs/dist/cjs/internal/util/arrRemove.js\");\nvar errorContext_1 = __webpack_require__(/*! ./util/errorContext */ \"./node_modules/rxjs/dist/cjs/internal/util/errorContext.js\");\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        var _this = _super.call(this) || this;\n        _this.closed = false;\n        _this.currentObservers = null;\n        _this.observers = [];\n        _this.isStopped = false;\n        _this.hasError = false;\n        _this.thrownError = null;\n        return _this;\n    }\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype._throwIfClosed = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n    };\n    Subject.prototype.next = function (value) {\n        var _this = this;\n        errorContext_1.errorContext(function () {\n            var e_1, _a;\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                if (!_this.currentObservers) {\n                    _this.currentObservers = Array.from(_this.observers);\n                }\n                try {\n                    for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {\n                        var observer = _c.value;\n                        observer.next(value);\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n        });\n    };\n    Subject.prototype.error = function (err) {\n        var _this = this;\n        errorContext_1.errorContext(function () {\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                _this.hasError = _this.isStopped = true;\n                _this.thrownError = err;\n                var observers = _this.observers;\n                while (observers.length) {\n                    observers.shift().error(err);\n                }\n            }\n        });\n    };\n    Subject.prototype.complete = function () {\n        var _this = this;\n        errorContext_1.errorContext(function () {\n            _this._throwIfClosed();\n            if (!_this.isStopped) {\n                _this.isStopped = true;\n                var observers = _this.observers;\n                while (observers.length) {\n                    observers.shift().complete();\n                }\n            }\n        });\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = this.closed = true;\n        this.observers = this.currentObservers = null;\n    };\n    Object.defineProperty(Subject.prototype, \"observed\", {\n        get: function () {\n            var _a;\n            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Subject.prototype._trySubscribe = function (subscriber) {\n        this._throwIfClosed();\n        return _super.prototype._trySubscribe.call(this, subscriber);\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        this._throwIfClosed();\n        this._checkFinalizedStatuses(subscriber);\n        return this._innerSubscribe(subscriber);\n    };\n    Subject.prototype._innerSubscribe = function (subscriber) {\n        var _this = this;\n        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;\n        if (hasError || isStopped) {\n            return Subscription_1.EMPTY_SUBSCRIPTION;\n        }\n        this.currentObservers = null;\n        observers.push(subscriber);\n        return new Subscription_1.Subscription(function () {\n            _this.currentObservers = null;\n            arrRemove_1.arrRemove(observers, subscriber);\n        });\n    };\n    Subject.prototype._checkFinalizedStatuses = function (subscriber) {\n        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;\n        if (hasError) {\n            subscriber.error(thrownError);\n        }\n        else if (isStopped) {\n            subscriber.complete();\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable_1.Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable_1.Observable));\nexports.Subject = Subject;\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        var _this = _super.call(this) || this;\n        _this.destination = destination;\n        _this.source = source;\n        return _this;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var _a, _b;\n        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;\n    };\n    return AnonymousSubject;\n}(Subject));\nexports.AnonymousSubject = AnonymousSubject;\n//# sourceMappingURL=Subject.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/Subject.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/Subscriber.js":
/*!***********************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/Subscriber.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;\nvar isFunction_1 = __webpack_require__(/*! ./util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nvar Subscription_1 = __webpack_require__(/*! ./Subscription */ \"./node_modules/rxjs/dist/cjs/internal/Subscription.js\");\nvar config_1 = __webpack_require__(/*! ./config */ \"./node_modules/rxjs/dist/cjs/internal/config.js\");\nvar reportUnhandledError_1 = __webpack_require__(/*! ./util/reportUnhandledError */ \"./node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js\");\nvar noop_1 = __webpack_require__(/*! ./util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nvar NotificationFactories_1 = __webpack_require__(/*! ./NotificationFactories */ \"./node_modules/rxjs/dist/cjs/internal/NotificationFactories.js\");\nvar timeoutProvider_1 = __webpack_require__(/*! ./scheduler/timeoutProvider */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js\");\nvar errorContext_1 = __webpack_require__(/*! ./util/errorContext */ \"./node_modules/rxjs/dist/cjs/internal/util/errorContext.js\");\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    function Subscriber(destination) {\n        var _this = _super.call(this) || this;\n        _this.isStopped = false;\n        if (destination) {\n            _this.destination = destination;\n            if (Subscription_1.isSubscription(destination)) {\n                destination.add(_this);\n            }\n        }\n        else {\n            _this.destination = exports.EMPTY_OBSERVER;\n        }\n        return _this;\n    }\n    Subscriber.create = function (next, error, complete) {\n        return new SafeSubscriber(next, error, complete);\n    };\n    Subscriber.prototype.next = function (value) {\n        if (this.isStopped) {\n            handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);\n        }\n        else {\n            this._next(value);\n        }\n    };\n    Subscriber.prototype.error = function (err) {\n        if (this.isStopped) {\n            handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);\n        }\n        else {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    Subscriber.prototype.complete = function () {\n        if (this.isStopped) {\n            handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);\n        }\n        else {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.isStopped = true;\n            _super.prototype.unsubscribe.call(this);\n            this.destination = null;\n        }\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        try {\n            this.destination.error(err);\n        }\n        finally {\n            this.unsubscribe();\n        }\n    };\n    Subscriber.prototype._complete = function () {\n        try {\n            this.destination.complete();\n        }\n        finally {\n            this.unsubscribe();\n        }\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nexports.Subscriber = Subscriber;\nvar _bind = Function.prototype.bind;\nfunction bind(fn, thisArg) {\n    return _bind.call(fn, thisArg);\n}\nvar ConsumerObserver = (function () {\n    function ConsumerObserver(partialObserver) {\n        this.partialObserver = partialObserver;\n    }\n    ConsumerObserver.prototype.next = function (value) {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.next) {\n            try {\n                partialObserver.next(value);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    };\n    ConsumerObserver.prototype.error = function (err) {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.error) {\n            try {\n                partialObserver.error(err);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n        else {\n            handleUnhandledError(err);\n        }\n    };\n    ConsumerObserver.prototype.complete = function () {\n        var partialObserver = this.partialObserver;\n        if (partialObserver.complete) {\n            try {\n                partialObserver.complete();\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    };\n    return ConsumerObserver;\n}());\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(observerOrNext, error, complete) {\n        var _this = _super.call(this) || this;\n        var partialObserver;\n        if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {\n            partialObserver = {\n                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),\n                error: error !== null && error !== void 0 ? error : undefined,\n                complete: complete !== null && complete !== void 0 ? complete : undefined,\n            };\n        }\n        else {\n            var context_1;\n            if (_this && config_1.config.useDeprecatedNextContext) {\n                context_1 = Object.create(observerOrNext);\n                context_1.unsubscribe = function () { return _this.unsubscribe(); };\n                partialObserver = {\n                    next: observerOrNext.next && bind(observerOrNext.next, context_1),\n                    error: observerOrNext.error && bind(observerOrNext.error, context_1),\n                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),\n                };\n            }\n            else {\n                partialObserver = observerOrNext;\n            }\n        }\n        _this.destination = new ConsumerObserver(partialObserver);\n        return _this;\n    }\n    return SafeSubscriber;\n}(Subscriber));\nexports.SafeSubscriber = SafeSubscriber;\nfunction handleUnhandledError(error) {\n    if (config_1.config.useDeprecatedSynchronousErrorHandling) {\n        errorContext_1.captureError(error);\n    }\n    else {\n        reportUnhandledError_1.reportUnhandledError(error);\n    }\n}\nfunction defaultErrorHandler(err) {\n    throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n    var onStoppedNotification = config_1.config.onStoppedNotification;\n    onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });\n}\nexports.EMPTY_OBSERVER = {\n    closed: true,\n    next: noop_1.noop,\n    error: defaultErrorHandler,\n    complete: noop_1.noop,\n};\n//# sourceMappingURL=Subscriber.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/Subscriber.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/Subscription.js":
/*!*************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/Subscription.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSubscription = exports.EMPTY_SUBSCRIPTION = exports.Subscription = void 0;\nvar isFunction_1 = __webpack_require__(/*! ./util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nvar UnsubscriptionError_1 = __webpack_require__(/*! ./util/UnsubscriptionError */ \"./node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js\");\nvar arrRemove_1 = __webpack_require__(/*! ./util/arrRemove */ \"./node_modules/rxjs/dist/cjs/internal/util/arrRemove.js\");\nvar Subscription = (function () {\n    function Subscription(initialTeardown) {\n        this.initialTeardown = initialTeardown;\n        this.closed = false;\n        this._parentage = null;\n        this._finalizers = null;\n    }\n    Subscription.prototype.unsubscribe = function () {\n        var e_1, _a, e_2, _b;\n        var errors;\n        if (!this.closed) {\n            this.closed = true;\n            var _parentage = this._parentage;\n            if (_parentage) {\n                this._parentage = null;\n                if (Array.isArray(_parentage)) {\n                    try {\n                        for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {\n                            var parent_1 = _parentage_1_1.value;\n                            parent_1.remove(this);\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                }\n                else {\n                    _parentage.remove(this);\n                }\n            }\n            var initialFinalizer = this.initialTeardown;\n            if (isFunction_1.isFunction(initialFinalizer)) {\n                try {\n                    initialFinalizer();\n                }\n                catch (e) {\n                    errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];\n                }\n            }\n            var _finalizers = this._finalizers;\n            if (_finalizers) {\n                this._finalizers = null;\n                try {\n                    for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {\n                        var finalizer = _finalizers_1_1.value;\n                        try {\n                            execFinalizer(finalizer);\n                        }\n                        catch (err) {\n                            errors = errors !== null && errors !== void 0 ? errors : [];\n                            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));\n                            }\n                            else {\n                                errors.push(err);\n                            }\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n            if (errors) {\n                throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n            }\n        }\n    };\n    Subscription.prototype.add = function (teardown) {\n        var _a;\n        if (teardown && teardown !== this) {\n            if (this.closed) {\n                execFinalizer(teardown);\n            }\n            else {\n                if (teardown instanceof Subscription) {\n                    if (teardown.closed || teardown._hasParent(this)) {\n                        return;\n                    }\n                    teardown._addParent(this);\n                }\n                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);\n            }\n        }\n    };\n    Subscription.prototype._hasParent = function (parent) {\n        var _parentage = this._parentage;\n        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n    };\n    Subscription.prototype._addParent = function (parent) {\n        var _parentage = this._parentage;\n        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n    };\n    Subscription.prototype._removeParent = function (parent) {\n        var _parentage = this._parentage;\n        if (_parentage === parent) {\n            this._parentage = null;\n        }\n        else if (Array.isArray(_parentage)) {\n            arrRemove_1.arrRemove(_parentage, parent);\n        }\n    };\n    Subscription.prototype.remove = function (teardown) {\n        var _finalizers = this._finalizers;\n        _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);\n        if (teardown instanceof Subscription) {\n            teardown._removeParent(this);\n        }\n    };\n    Subscription.EMPTY = (function () {\n        var empty = new Subscription();\n        empty.closed = true;\n        return empty;\n    })();\n    return Subscription;\n}());\nexports.Subscription = Subscription;\nexports.EMPTY_SUBSCRIPTION = Subscription.EMPTY;\nfunction isSubscription(value) {\n    return (value instanceof Subscription ||\n        (value && 'closed' in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe)));\n}\nexports.isSubscription = isSubscription;\nfunction execFinalizer(finalizer) {\n    if (isFunction_1.isFunction(finalizer)) {\n        finalizer();\n    }\n    else {\n        finalizer.unsubscribe();\n    }\n}\n//# sourceMappingURL=Subscription.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/Subscription.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/config.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/config.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.config = void 0;\nexports.config = {\n    onUnhandledError: null,\n    onStoppedNotification: null,\n    Promise: undefined,\n    useDeprecatedSynchronousErrorHandling: false,\n    useDeprecatedNextContext: false,\n};\n//# sourceMappingURL=config.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/config.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/firstValueFrom.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/firstValueFrom.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.firstValueFrom = void 0;\nvar EmptyError_1 = __webpack_require__(/*! ./util/EmptyError */ \"./node_modules/rxjs/dist/cjs/internal/util/EmptyError.js\");\nvar Subscriber_1 = __webpack_require__(/*! ./Subscriber */ \"./node_modules/rxjs/dist/cjs/internal/Subscriber.js\");\nfunction firstValueFrom(source, config) {\n    var hasConfig = typeof config === 'object';\n    return new Promise(function (resolve, reject) {\n        var subscriber = new Subscriber_1.SafeSubscriber({\n            next: function (value) {\n                resolve(value);\n                subscriber.unsubscribe();\n            },\n            error: reject,\n            complete: function () {\n                if (hasConfig) {\n                    resolve(config.defaultValue);\n                }\n                else {\n                    reject(new EmptyError_1.EmptyError());\n                }\n            },\n        });\n        source.subscribe(subscriber);\n    });\n}\nexports.firstValueFrom = firstValueFrom;\n//# sourceMappingURL=firstValueFrom.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/firstValueFrom.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/lastValueFrom.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/lastValueFrom.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.lastValueFrom = void 0;\nvar EmptyError_1 = __webpack_require__(/*! ./util/EmptyError */ \"./node_modules/rxjs/dist/cjs/internal/util/EmptyError.js\");\nfunction lastValueFrom(source, config) {\n    var hasConfig = typeof config === 'object';\n    return new Promise(function (resolve, reject) {\n        var _hasValue = false;\n        var _value;\n        source.subscribe({\n            next: function (value) {\n                _value = value;\n                _hasValue = true;\n            },\n            error: reject,\n            complete: function () {\n                if (_hasValue) {\n                    resolve(_value);\n                }\n                else if (hasConfig) {\n                    resolve(config.defaultValue);\n                }\n                else {\n                    reject(new EmptyError_1.EmptyError());\n                }\n            },\n        });\n    });\n}\nexports.lastValueFrom = lastValueFrom;\n//# sourceMappingURL=lastValueFrom.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/lastValueFrom.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectableObservable = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar Subscription_1 = __webpack_require__(/*! ../Subscription */ \"./node_modules/rxjs/dist/cjs/internal/Subscription.js\");\nvar refCount_1 = __webpack_require__(/*! ../operators/refCount */ \"./node_modules/rxjs/dist/cjs/internal/operators/refCount.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ../operators/OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar ConnectableObservable = (function (_super) {\n    __extends(ConnectableObservable, _super);\n    function ConnectableObservable(source, subjectFactory) {\n        var _this = _super.call(this) || this;\n        _this.source = source;\n        _this.subjectFactory = subjectFactory;\n        _this._subject = null;\n        _this._refCount = 0;\n        _this._connection = null;\n        if (lift_1.hasLift(source)) {\n            _this.lift = source.lift;\n        }\n        return _this;\n    }\n    ConnectableObservable.prototype._subscribe = function (subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    };\n    ConnectableObservable.prototype.getSubject = function () {\n        var subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    };\n    ConnectableObservable.prototype._teardown = function () {\n        this._refCount = 0;\n        var _connection = this._connection;\n        this._subject = this._connection = null;\n        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();\n    };\n    ConnectableObservable.prototype.connect = function () {\n        var _this = this;\n        var connection = this._connection;\n        if (!connection) {\n            connection = this._connection = new Subscription_1.Subscription();\n            var subject_1 = this.getSubject();\n            connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, undefined, function () {\n                _this._teardown();\n                subject_1.complete();\n            }, function (err) {\n                _this._teardown();\n                subject_1.error(err);\n            }, function () { return _this._teardown(); })));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription_1.Subscription.EMPTY;\n            }\n        }\n        return connection;\n    };\n    ConnectableObservable.prototype.refCount = function () {\n        return refCount_1.refCount()(this);\n    };\n    return ConnectableObservable;\n}(Observable_1.Observable));\nexports.ConnectableObservable = ConnectableObservable;\n//# sourceMappingURL=ConnectableObservable.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js":
/*!************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bindCallback = void 0;\nvar bindCallbackInternals_1 = __webpack_require__(/*! ./bindCallbackInternals */ \"./node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js\");\nfunction bindCallback(callbackFunc, resultSelector, scheduler) {\n    return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);\n}\nexports.bindCallback = bindCallback;\n//# sourceMappingURL=bindCallback.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bindCallbackInternals = void 0;\nvar isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ \"./node_modules/rxjs/dist/cjs/internal/util/isScheduler.js\");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar subscribeOn_1 = __webpack_require__(/*! ../operators/subscribeOn */ \"./node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js\");\nvar mapOneOrManyArgs_1 = __webpack_require__(/*! ../util/mapOneOrManyArgs */ \"./node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js\");\nvar observeOn_1 = __webpack_require__(/*! ../operators/observeOn */ \"./node_modules/rxjs/dist/cjs/internal/operators/observeOn.js\");\nvar AsyncSubject_1 = __webpack_require__(/*! ../AsyncSubject */ \"./node_modules/rxjs/dist/cjs/internal/AsyncSubject.js\");\nfunction bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {\n    if (resultSelector) {\n        if (isScheduler_1.isScheduler(resultSelector)) {\n            scheduler = resultSelector;\n        }\n        else {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler)\n                    .apply(this, args)\n                    .pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));\n            };\n        }\n    }\n    if (scheduler) {\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return bindCallbackInternals(isNodeStyle, callbackFunc)\n                .apply(this, args)\n                .pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));\n        };\n    }\n    return function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var subject = new AsyncSubject_1.AsyncSubject();\n        var uninitialized = true;\n        return new Observable_1.Observable(function (subscriber) {\n            var subs = subject.subscribe(subscriber);\n            if (uninitialized) {\n                uninitialized = false;\n                var isAsync_1 = false;\n                var isComplete_1 = false;\n                callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [\n                    function () {\n                        var results = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            results[_i] = arguments[_i];\n                        }\n                        if (isNodeStyle) {\n                            var err = results.shift();\n                            if (err != null) {\n                                subject.error(err);\n                                return;\n                            }\n                        }\n                        subject.next(1 < results.length ? results : results[0]);\n                        isComplete_1 = true;\n                        if (isAsync_1) {\n                            subject.complete();\n                        }\n                    },\n                ]));\n                if (isComplete_1) {\n                    subject.complete();\n                }\n                isAsync_1 = true;\n            }\n            return subs;\n        });\n    };\n}\nexports.bindCallbackInternals = bindCallbackInternals;\n//# sourceMappingURL=bindCallbackInternals.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js":
/*!****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bindNodeCallback = void 0;\nvar bindCallbackInternals_1 = __webpack_require__(/*! ./bindCallbackInternals */ \"./node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js\");\nfunction bindNodeCallback(callbackFunc, resultSelector, scheduler) {\n    return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);\n}\nexports.bindNodeCallback = bindNodeCallback;\n//# sourceMappingURL=bindNodeCallback.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.combineLatestInit = exports.combineLatest = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar argsArgArrayOrObject_1 = __webpack_require__(/*! ../util/argsArgArrayOrObject */ \"./node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js\");\nvar from_1 = __webpack_require__(/*! ./from */ \"./node_modules/rxjs/dist/cjs/internal/observable/from.js\");\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nvar mapOneOrManyArgs_1 = __webpack_require__(/*! ../util/mapOneOrManyArgs */ \"./node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js\");\nvar args_1 = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/cjs/internal/util/args.js\");\nvar createObject_1 = __webpack_require__(/*! ../util/createObject */ \"./node_modules/rxjs/dist/cjs/internal/util/createObject.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ../operators/OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar executeSchedule_1 = __webpack_require__(/*! ../util/executeSchedule */ \"./node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js\");\nfunction combineLatest() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var scheduler = args_1.popScheduler(args);\n    var resultSelector = args_1.popResultSelector(args);\n    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;\n    if (observables.length === 0) {\n        return from_1.from([], scheduler);\n    }\n    var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys\n        ?\n            function (values) { return createObject_1.createObject(keys, values); }\n        :\n            identity_1.identity));\n    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;\n}\nexports.combineLatest = combineLatest;\nfunction combineLatestInit(observables, scheduler, valueTransform) {\n    if (valueTransform === void 0) { valueTransform = identity_1.identity; }\n    return function (subscriber) {\n        maybeSchedule(scheduler, function () {\n            var length = observables.length;\n            var values = new Array(length);\n            var active = length;\n            var remainingFirstValues = length;\n            var _loop_1 = function (i) {\n                maybeSchedule(scheduler, function () {\n                    var source = from_1.from(observables[i], scheduler);\n                    var hasFirstValue = false;\n                    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n                        values[i] = value;\n                        if (!hasFirstValue) {\n                            hasFirstValue = true;\n                            remainingFirstValues--;\n                        }\n                        if (!remainingFirstValues) {\n                            subscriber.next(valueTransform(values.slice()));\n                        }\n                    }, function () {\n                        if (!--active) {\n                            subscriber.complete();\n                        }\n                    }));\n                }, subscriber);\n            };\n            for (var i = 0; i < length; i++) {\n                _loop_1(i);\n            }\n        }, subscriber);\n    };\n}\nexports.combineLatestInit = combineLatestInit;\nfunction maybeSchedule(scheduler, execute, subscription) {\n    if (scheduler) {\n        executeSchedule_1.executeSchedule(subscription, scheduler, execute);\n    }\n    else {\n        execute();\n    }\n}\n//# sourceMappingURL=combineLatest.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/concat.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/concat.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.concat = void 0;\nvar concatAll_1 = __webpack_require__(/*! ../operators/concatAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/concatAll.js\");\nvar args_1 = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/cjs/internal/util/args.js\");\nvar from_1 = __webpack_require__(/*! ./from */ \"./node_modules/rxjs/dist/cjs/internal/observable/from.js\");\nfunction concat() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/concat.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/connectable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/connectable.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.connectable = void 0;\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar defer_1 = __webpack_require__(/*! ./defer */ \"./node_modules/rxjs/dist/cjs/internal/observable/defer.js\");\nvar DEFAULT_CONFIG = {\n    connector: function () { return new Subject_1.Subject(); },\n    resetOnDisconnect: true,\n};\nfunction connectable(source, config) {\n    if (config === void 0) { config = DEFAULT_CONFIG; }\n    var connection = null;\n    var connector = config.connector, _a = config.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;\n    var subject = connector();\n    var result = new Observable_1.Observable(function (subscriber) {\n        return subject.subscribe(subscriber);\n    });\n    result.connect = function () {\n        if (!connection || connection.closed) {\n            connection = defer_1.defer(function () { return source; }).subscribe(subject);\n            if (resetOnDisconnect) {\n                connection.add(function () { return (subject = connector()); });\n            }\n        }\n        return connection;\n    };\n    return result;\n}\nexports.connectable = connectable;\n//# sourceMappingURL=connectable.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/connectable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/defer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/defer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defer = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar innerFrom_1 = __webpack_require__(/*! ./innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nfunction defer(observableFactory) {\n    return new Observable_1.Observable(function (subscriber) {\n        innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);\n    });\n}\nexports.defer = defer;\n//# sourceMappingURL=defer.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/defer.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.animationFrames = void 0;\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar performanceTimestampProvider_1 = __webpack_require__(/*! ../../scheduler/performanceTimestampProvider */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js\");\nvar animationFrameProvider_1 = __webpack_require__(/*! ../../scheduler/animationFrameProvider */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js\");\nfunction animationFrames(timestampProvider) {\n    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\nexports.animationFrames = animationFrames;\nfunction animationFramesFactory(timestampProvider) {\n    return new Observable_1.Observable(function (subscriber) {\n        var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;\n        var start = provider.now();\n        var id = 0;\n        var run = function () {\n            if (!subscriber.closed) {\n                id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function (timestamp) {\n                    id = 0;\n                    var now = provider.now();\n                    subscriber.next({\n                        timestamp: timestampProvider ? now : timestamp,\n                        elapsed: now - start,\n                    });\n                    run();\n                });\n            }\n        };\n        run();\n        return function () {\n            if (id) {\n                animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);\n            }\n        };\n    });\n}\nvar DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\n//# sourceMappingURL=animationFrames.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/empty.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/empty.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.empty = exports.EMPTY = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nexports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });\nfunction empty(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;\n}\nexports.empty = empty;\nfunction emptyScheduled(scheduler) {\n    return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });\n}\n//# sourceMappingURL=empty.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/empty.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.forkJoin = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar argsArgArrayOrObject_1 = __webpack_require__(/*! ../util/argsArgArrayOrObject */ \"./node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js\");\nvar innerFrom_1 = __webpack_require__(/*! ./innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar args_1 = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/cjs/internal/util/args.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ../operators/OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar mapOneOrManyArgs_1 = __webpack_require__(/*! ../util/mapOneOrManyArgs */ \"./node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js\");\nvar createObject_1 = __webpack_require__(/*! ../util/createObject */ \"./node_modules/rxjs/dist/cjs/internal/util/createObject.js\");\nfunction forkJoin() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var resultSelector = args_1.popResultSelector(args);\n    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;\n    var result = new Observable_1.Observable(function (subscriber) {\n        var length = sources.length;\n        if (!length) {\n            subscriber.complete();\n            return;\n        }\n        var values = new Array(length);\n        var remainingCompletions = length;\n        var remainingEmissions = length;\n        var _loop_1 = function (sourceIndex) {\n            var hasValue = false;\n            innerFrom_1.innerFrom(sources[sourceIndex]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n                if (!hasValue) {\n                    hasValue = true;\n                    remainingEmissions--;\n                }\n                values[sourceIndex] = value;\n            }, function () { return remainingCompletions--; }, undefined, function () {\n                if (!remainingCompletions || !hasValue) {\n                    if (!remainingEmissions) {\n                        subscriber.next(keys ? createObject_1.createObject(keys, values) : values);\n                    }\n                    subscriber.complete();\n                }\n            }));\n        };\n        for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {\n            _loop_1(sourceIndex);\n        }\n    });\n    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;\n}\nexports.forkJoin = forkJoin;\n//# sourceMappingURL=forkJoin.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/from.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/from.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.from = void 0;\nvar scheduled_1 = __webpack_require__(/*! ../scheduled/scheduled */ \"./node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js\");\nvar innerFrom_1 = __webpack_require__(/*! ./innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nfunction from(input, scheduler) {\n    return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);\n}\nexports.from = from;\n//# sourceMappingURL=from.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/from.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromEvent = void 0;\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar mergeMap_1 = __webpack_require__(/*! ../operators/mergeMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js\");\nvar isArrayLike_1 = __webpack_require__(/*! ../util/isArrayLike */ \"./node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nvar mapOneOrManyArgs_1 = __webpack_require__(/*! ../util/mapOneOrManyArgs */ \"./node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js\");\nvar nodeEventEmitterMethods = ['addListener', 'removeListener'];\nvar eventTargetMethods = ['addEventListener', 'removeEventListener'];\nvar jqueryMethods = ['on', 'off'];\nfunction fromEvent(target, eventName, options, resultSelector) {\n    if (isFunction_1.isFunction(options)) {\n        resultSelector = options;\n        options = undefined;\n    }\n    if (resultSelector) {\n        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));\n    }\n    var _a = __read(isEventTarget(target)\n        ? eventTargetMethods.map(function (methodName) { return function (handler) { return target[methodName](eventName, handler, options); }; })\n        :\n            isNodeStyleEventEmitter(target)\n                ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n                : isJQueryStyleEventEmitter(target)\n                    ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n                    : [], 2), add = _a[0], remove = _a[1];\n    if (!add) {\n        if (isArrayLike_1.isArrayLike(target)) {\n            return mergeMap_1.mergeMap(function (subTarget) { return fromEvent(subTarget, eventName, options); })(innerFrom_1.innerFrom(target));\n        }\n    }\n    if (!add) {\n        throw new TypeError('Invalid event target');\n    }\n    return new Observable_1.Observable(function (subscriber) {\n        var handler = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return subscriber.next(1 < args.length ? args : args[0]);\n        };\n        add(handler);\n        return function () { return remove(handler); };\n    });\n}\nexports.fromEvent = fromEvent;\nfunction toCommonHandlerRegistry(target, eventName) {\n    return function (methodName) { return function (handler) { return target[methodName](eventName, handler); }; };\n}\nfunction isNodeStyleEventEmitter(target) {\n    return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);\n}\nfunction isJQueryStyleEventEmitter(target) {\n    return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);\n}\nfunction isEventTarget(target) {\n    return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);\n}\n//# sourceMappingURL=fromEvent.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js":
/*!****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromEventPattern = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nvar mapOneOrManyArgs_1 = __webpack_require__(/*! ../util/mapOneOrManyArgs */ \"./node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js\");\nfunction fromEventPattern(addHandler, removeHandler, resultSelector) {\n    if (resultSelector) {\n        return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));\n    }\n    return new Observable_1.Observable(function (subscriber) {\n        var handler = function () {\n            var e = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                e[_i] = arguments[_i];\n            }\n            return subscriber.next(e.length === 1 ? e[0] : e);\n        };\n        var retValue = addHandler(handler);\n        return isFunction_1.isFunction(removeHandler) ? function () { return removeHandler(handler, retValue); } : undefined;\n    });\n}\nexports.fromEventPattern = fromEventPattern;\n//# sourceMappingURL=fromEventPattern.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js":
/*!****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromSubscribable = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nfunction fromSubscribable(subscribable) {\n    return new Observable_1.Observable(function (subscriber) { return subscribable.subscribe(subscriber); });\n}\nexports.fromSubscribable = fromSubscribable;\n//# sourceMappingURL=fromSubscribable.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/generate.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/generate.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.generate = void 0;\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nvar isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ \"./node_modules/rxjs/dist/cjs/internal/util/isScheduler.js\");\nvar defer_1 = __webpack_require__(/*! ./defer */ \"./node_modules/rxjs/dist/cjs/internal/observable/defer.js\");\nvar scheduleIterable_1 = __webpack_require__(/*! ../scheduled/scheduleIterable */ \"./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js\");\nfunction generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {\n    var _a, _b;\n    var resultSelector;\n    var initialState;\n    if (arguments.length === 1) {\n        (_a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1.identity : _b, scheduler = _a.scheduler);\n    }\n    else {\n        initialState = initialStateOrOptions;\n        if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {\n            resultSelector = identity_1.identity;\n            scheduler = resultSelectorOrScheduler;\n        }\n        else {\n            resultSelector = resultSelectorOrScheduler;\n        }\n    }\n    function gen() {\n        var state;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    state = initialState;\n                    _a.label = 1;\n                case 1:\n                    if (!(!condition || condition(state))) return [3, 4];\n                    return [4, resultSelector(state)];\n                case 2:\n                    _a.sent();\n                    _a.label = 3;\n                case 3:\n                    state = iterate(state);\n                    return [3, 1];\n                case 4: return [2];\n            }\n        });\n    }\n    return defer_1.defer((scheduler\n        ?\n            function () { return scheduleIterable_1.scheduleIterable(gen(), scheduler); }\n        :\n            gen));\n}\nexports.generate = generate;\n//# sourceMappingURL=generate.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/generate.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/iif.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/iif.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.iif = void 0;\nvar defer_1 = __webpack_require__(/*! ./defer */ \"./node_modules/rxjs/dist/cjs/internal/observable/defer.js\");\nfunction iif(condition, trueResult, falseResult) {\n    return defer_1.defer(function () { return (condition() ? trueResult : falseResult); });\n}\nexports.iif = iif;\n//# sourceMappingURL=iif.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/iif.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromReadableStreamLike = exports.fromAsyncIterable = exports.fromIterable = exports.fromPromise = exports.fromArrayLike = exports.fromInteropObservable = exports.innerFrom = void 0;\nvar isArrayLike_1 = __webpack_require__(/*! ../util/isArrayLike */ \"./node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js\");\nvar isPromise_1 = __webpack_require__(/*! ../util/isPromise */ \"./node_modules/rxjs/dist/cjs/internal/util/isPromise.js\");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar isInteropObservable_1 = __webpack_require__(/*! ../util/isInteropObservable */ \"./node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js\");\nvar isAsyncIterable_1 = __webpack_require__(/*! ../util/isAsyncIterable */ \"./node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js\");\nvar throwUnobservableError_1 = __webpack_require__(/*! ../util/throwUnobservableError */ \"./node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js\");\nvar isIterable_1 = __webpack_require__(/*! ../util/isIterable */ \"./node_modules/rxjs/dist/cjs/internal/util/isIterable.js\");\nvar isReadableStreamLike_1 = __webpack_require__(/*! ../util/isReadableStreamLike */ \"./node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nvar reportUnhandledError_1 = __webpack_require__(/*! ../util/reportUnhandledError */ \"./node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js\");\nvar observable_1 = __webpack_require__(/*! ../symbol/observable */ \"./node_modules/rxjs/dist/cjs/internal/symbol/observable.js\");\nfunction innerFrom(input) {\n    if (input instanceof Observable_1.Observable) {\n        return input;\n    }\n    if (input != null) {\n        if (isInteropObservable_1.isInteropObservable(input)) {\n            return fromInteropObservable(input);\n        }\n        if (isArrayLike_1.isArrayLike(input)) {\n            return fromArrayLike(input);\n        }\n        if (isPromise_1.isPromise(input)) {\n            return fromPromise(input);\n        }\n        if (isAsyncIterable_1.isAsyncIterable(input)) {\n            return fromAsyncIterable(input);\n        }\n        if (isIterable_1.isIterable(input)) {\n            return fromIterable(input);\n        }\n        if (isReadableStreamLike_1.isReadableStreamLike(input)) {\n            return fromReadableStreamLike(input);\n        }\n    }\n    throw throwUnobservableError_1.createInvalidObservableTypeError(input);\n}\nexports.innerFrom = innerFrom;\nfunction fromInteropObservable(obj) {\n    return new Observable_1.Observable(function (subscriber) {\n        var obs = obj[observable_1.observable]();\n        if (isFunction_1.isFunction(obs.subscribe)) {\n            return obs.subscribe(subscriber);\n        }\n        throw new TypeError('Provided object does not correctly implement Symbol.observable');\n    });\n}\nexports.fromInteropObservable = fromInteropObservable;\nfunction fromArrayLike(array) {\n    return new Observable_1.Observable(function (subscriber) {\n        for (var i = 0; i < array.length && !subscriber.closed; i++) {\n            subscriber.next(array[i]);\n        }\n        subscriber.complete();\n    });\n}\nexports.fromArrayLike = fromArrayLike;\nfunction fromPromise(promise) {\n    return new Observable_1.Observable(function (subscriber) {\n        promise\n            .then(function (value) {\n            if (!subscriber.closed) {\n                subscriber.next(value);\n                subscriber.complete();\n            }\n        }, function (err) { return subscriber.error(err); })\n            .then(null, reportUnhandledError_1.reportUnhandledError);\n    });\n}\nexports.fromPromise = fromPromise;\nfunction fromIterable(iterable) {\n    return new Observable_1.Observable(function (subscriber) {\n        var e_1, _a;\n        try {\n            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {\n                var value = iterable_1_1.value;\n                subscriber.next(value);\n                if (subscriber.closed) {\n                    return;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        subscriber.complete();\n    });\n}\nexports.fromIterable = fromIterable;\nfunction fromAsyncIterable(asyncIterable) {\n    return new Observable_1.Observable(function (subscriber) {\n        process(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });\n    });\n}\nexports.fromAsyncIterable = fromAsyncIterable;\nfunction fromReadableStreamLike(readableStream) {\n    return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));\n}\nexports.fromReadableStreamLike = fromReadableStreamLike;\nfunction process(asyncIterable, subscriber) {\n    var asyncIterable_1, asyncIterable_1_1;\n    var e_2, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var value, e_2_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _b.trys.push([0, 5, 6, 11]);\n                    asyncIterable_1 = __asyncValues(asyncIterable);\n                    _b.label = 1;\n                case 1: return [4, asyncIterable_1.next()];\n                case 2:\n                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];\n                    value = asyncIterable_1_1.value;\n                    subscriber.next(value);\n                    if (subscriber.closed) {\n                        return [2];\n                    }\n                    _b.label = 3;\n                case 3: return [3, 1];\n                case 4: return [3, 11];\n                case 5:\n                    e_2_1 = _b.sent();\n                    e_2 = { error: e_2_1 };\n                    return [3, 11];\n                case 6:\n                    _b.trys.push([6, , 9, 10]);\n                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];\n                    return [4, _a.call(asyncIterable_1)];\n                case 7:\n                    _b.sent();\n                    _b.label = 8;\n                case 8: return [3, 10];\n                case 9:\n                    if (e_2) throw e_2.error;\n                    return [7];\n                case 10: return [7];\n                case 11:\n                    subscriber.complete();\n                    return [2];\n            }\n        });\n    });\n}\n//# sourceMappingURL=innerFrom.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/interval.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/interval.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.interval = void 0;\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/async.js\");\nvar timer_1 = __webpack_require__(/*! ./timer */ \"./node_modules/rxjs/dist/cjs/internal/observable/timer.js\");\nfunction interval(period, scheduler) {\n    if (period === void 0) { period = 0; }\n    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }\n    if (period < 0) {\n        period = 0;\n    }\n    return timer_1.timer(period, period, scheduler);\n}\nexports.interval = interval;\n//# sourceMappingURL=interval.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/interval.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/merge.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/merge.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.merge = void 0;\nvar mergeAll_1 = __webpack_require__(/*! ../operators/mergeAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js\");\nvar innerFrom_1 = __webpack_require__(/*! ./innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar empty_1 = __webpack_require__(/*! ./empty */ \"./node_modules/rxjs/dist/cjs/internal/observable/empty.js\");\nvar args_1 = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/cjs/internal/util/args.js\");\nvar from_1 = __webpack_require__(/*! ./from */ \"./node_modules/rxjs/dist/cjs/internal/observable/from.js\");\nfunction merge() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var scheduler = args_1.popScheduler(args);\n    var concurrent = args_1.popNumber(args, Infinity);\n    var sources = args;\n    return !sources.length\n        ?\n            empty_1.EMPTY\n        : sources.length === 1\n            ?\n                innerFrom_1.innerFrom(sources[0])\n            :\n                mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/merge.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/never.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/never.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.never = exports.NEVER = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nexports.NEVER = new Observable_1.Observable(noop_1.noop);\nfunction never() {\n    return exports.NEVER;\n}\nexports.never = never;\n//# sourceMappingURL=never.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/never.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/of.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/of.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.of = void 0;\nvar args_1 = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/cjs/internal/util/args.js\");\nvar from_1 = __webpack_require__(/*! ./from */ \"./node_modules/rxjs/dist/cjs/internal/observable/from.js\");\nfunction of() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var scheduler = args_1.popScheduler(args);\n    return from_1.from(args, scheduler);\n}\nexports.of = of;\n//# sourceMappingURL=of.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/of.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.onErrorResumeNext = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar argsOrArgArray_1 = __webpack_require__(/*! ../util/argsOrArgArray */ \"./node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ../operators/OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nvar innerFrom_1 = __webpack_require__(/*! ./innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nfunction onErrorResumeNext() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);\n    return new Observable_1.Observable(function (subscriber) {\n        var sourceIndex = 0;\n        var subscribeNext = function () {\n            if (sourceIndex < nextSources.length) {\n                var nextSource = void 0;\n                try {\n                    nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);\n                }\n                catch (err) {\n                    subscribeNext();\n                    return;\n                }\n                var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, undefined, noop_1.noop, noop_1.noop);\n                nextSource.subscribe(innerSubscriber);\n                innerSubscriber.add(subscribeNext);\n            }\n            else {\n                subscriber.complete();\n            }\n        };\n        subscribeNext();\n    });\n}\nexports.onErrorResumeNext = onErrorResumeNext;\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/pairs.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/pairs.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pairs = void 0;\nvar from_1 = __webpack_require__(/*! ./from */ \"./node_modules/rxjs/dist/cjs/internal/observable/from.js\");\nfunction pairs(obj, scheduler) {\n    return from_1.from(Object.entries(obj), scheduler);\n}\nexports.pairs = pairs;\n//# sourceMappingURL=pairs.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/pairs.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/partition.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/partition.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.partition = void 0;\nvar not_1 = __webpack_require__(/*! ../util/not */ \"./node_modules/rxjs/dist/cjs/internal/util/not.js\");\nvar filter_1 = __webpack_require__(/*! ../operators/filter */ \"./node_modules/rxjs/dist/cjs/internal/operators/filter.js\");\nvar innerFrom_1 = __webpack_require__(/*! ./innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nfunction partition(source, predicate, thisArg) {\n    return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];\n}\nexports.partition = partition;\n//# sourceMappingURL=partition.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/partition.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/race.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/race.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.raceInit = exports.race = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar innerFrom_1 = __webpack_require__(/*! ./innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar argsOrArgArray_1 = __webpack_require__(/*! ../util/argsOrArgArray */ \"./node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ../operators/OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction race() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    sources = argsOrArgArray_1.argsOrArgArray(sources);\n    return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));\n}\nexports.race = race;\nfunction raceInit(sources) {\n    return function (subscriber) {\n        var subscriptions = [];\n        var _loop_1 = function (i) {\n            subscriptions.push(innerFrom_1.innerFrom(sources[i]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n                if (subscriptions) {\n                    for (var s = 0; s < subscriptions.length; s++) {\n                        s !== i && subscriptions[s].unsubscribe();\n                    }\n                    subscriptions = null;\n                }\n                subscriber.next(value);\n            })));\n        };\n        for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {\n            _loop_1(i);\n        }\n    };\n}\nexports.raceInit = raceInit;\n//# sourceMappingURL=race.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/race.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/range.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/range.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.range = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar empty_1 = __webpack_require__(/*! ./empty */ \"./node_modules/rxjs/dist/cjs/internal/observable/empty.js\");\nfunction range(start, count, scheduler) {\n    if (count == null) {\n        count = start;\n        start = 0;\n    }\n    if (count <= 0) {\n        return empty_1.EMPTY;\n    }\n    var end = count + start;\n    return new Observable_1.Observable(scheduler\n        ?\n            function (subscriber) {\n                var n = start;\n                return scheduler.schedule(function () {\n                    if (n < end) {\n                        subscriber.next(n++);\n                        this.schedule();\n                    }\n                    else {\n                        subscriber.complete();\n                    }\n                });\n            }\n        :\n            function (subscriber) {\n                var n = start;\n                while (n < end && !subscriber.closed) {\n                    subscriber.next(n++);\n                }\n                subscriber.complete();\n            });\n}\nexports.range = range;\n//# sourceMappingURL=range.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/range.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/throwError.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/throwError.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.throwError = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction throwError(errorOrErrorFactory, scheduler) {\n    var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function () { return errorOrErrorFactory; };\n    var init = function (subscriber) { return subscriber.error(errorFactory()); };\n    return new Observable_1.Observable(scheduler ? function (subscriber) { return scheduler.schedule(init, 0, subscriber); } : init);\n}\nexports.throwError = throwError;\n//# sourceMappingURL=throwError.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/throwError.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/timer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/timer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.timer = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/async.js\");\nvar isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ \"./node_modules/rxjs/dist/cjs/internal/util/isScheduler.js\");\nvar isDate_1 = __webpack_require__(/*! ../util/isDate */ \"./node_modules/rxjs/dist/cjs/internal/util/isDate.js\");\nfunction timer(dueTime, intervalOrScheduler, scheduler) {\n    if (dueTime === void 0) { dueTime = 0; }\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var intervalDuration = -1;\n    if (intervalOrScheduler != null) {\n        if (isScheduler_1.isScheduler(intervalOrScheduler)) {\n            scheduler = intervalOrScheduler;\n        }\n        else {\n            intervalDuration = intervalOrScheduler;\n        }\n    }\n    return new Observable_1.Observable(function (subscriber) {\n        var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;\n        if (due < 0) {\n            due = 0;\n        }\n        var n = 0;\n        return scheduler.schedule(function () {\n            if (!subscriber.closed) {\n                subscriber.next(n++);\n                if (0 <= intervalDuration) {\n                    this.schedule(undefined, intervalDuration);\n                }\n                else {\n                    subscriber.complete();\n                }\n            }\n        }, due);\n    });\n}\nexports.timer = timer;\n//# sourceMappingURL=timer.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/timer.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/using.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/using.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.using = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar innerFrom_1 = __webpack_require__(/*! ./innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar empty_1 = __webpack_require__(/*! ./empty */ \"./node_modules/rxjs/dist/cjs/internal/observable/empty.js\");\nfunction using(resourceFactory, observableFactory) {\n    return new Observable_1.Observable(function (subscriber) {\n        var resource = resourceFactory();\n        var result = observableFactory(resource);\n        var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;\n        source.subscribe(subscriber);\n        return function () {\n            if (resource) {\n                resource.unsubscribe();\n            }\n        };\n    });\n}\nexports.using = using;\n//# sourceMappingURL=using.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/using.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/observable/zip.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/observable/zip.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.zip = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar innerFrom_1 = __webpack_require__(/*! ./innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar argsOrArgArray_1 = __webpack_require__(/*! ../util/argsOrArgArray */ \"./node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js\");\nvar empty_1 = __webpack_require__(/*! ./empty */ \"./node_modules/rxjs/dist/cjs/internal/observable/empty.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ../operators/OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar args_1 = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/cjs/internal/util/args.js\");\nfunction zip() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var resultSelector = args_1.popResultSelector(args);\n    var sources = argsOrArgArray_1.argsOrArgArray(args);\n    return sources.length\n        ? new Observable_1.Observable(function (subscriber) {\n            var buffers = sources.map(function () { return []; });\n            var completed = sources.map(function () { return false; });\n            subscriber.add(function () {\n                buffers = completed = null;\n            });\n            var _loop_1 = function (sourceIndex) {\n                innerFrom_1.innerFrom(sources[sourceIndex]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n                    buffers[sourceIndex].push(value);\n                    if (buffers.every(function (buffer) { return buffer.length; })) {\n                        var result = buffers.map(function (buffer) { return buffer.shift(); });\n                        subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);\n                        if (buffers.some(function (buffer, i) { return !buffer.length && completed[i]; })) {\n                            subscriber.complete();\n                        }\n                    }\n                }, function () {\n                    completed[sourceIndex] = true;\n                    !buffers[sourceIndex].length && subscriber.complete();\n                }));\n            };\n            for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {\n                _loop_1(sourceIndex);\n            }\n            return function () {\n                buffers = completed = null;\n            };\n        })\n        : empty_1.EMPTY;\n}\nexports.zip = zip;\n//# sourceMappingURL=zip.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/observable/zip.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OperatorSubscriber = exports.createOperatorSubscriber = void 0;\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/dist/cjs/internal/Subscriber.js\");\nfunction createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {\n    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\nexports.createOperatorSubscriber = createOperatorSubscriber;\nvar OperatorSubscriber = (function (_super) {\n    __extends(OperatorSubscriber, _super);\n    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {\n        var _this = _super.call(this, destination) || this;\n        _this.onFinalize = onFinalize;\n        _this.shouldUnsubscribe = shouldUnsubscribe;\n        _this._next = onNext\n            ? function (value) {\n                try {\n                    onNext(value);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n            }\n            : _super.prototype._next;\n        _this._error = onError\n            ? function (err) {\n                try {\n                    onError(err);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : _super.prototype._error;\n        _this._complete = onComplete\n            ? function () {\n                try {\n                    onComplete();\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : _super.prototype._complete;\n        return _this;\n    }\n    OperatorSubscriber.prototype.unsubscribe = function () {\n        var _a;\n        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n            var closed_1 = this.closed;\n            _super.prototype.unsubscribe.call(this);\n            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));\n        }\n    };\n    return OperatorSubscriber;\n}(Subscriber_1.Subscriber));\nexports.OperatorSubscriber = OperatorSubscriber;\n//# sourceMappingURL=OperatorSubscriber.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/audit.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/audit.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.audit = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction audit(durationSelector) {\n    return lift_1.operate(function (source, subscriber) {\n        var hasValue = false;\n        var lastValue = null;\n        var durationSubscriber = null;\n        var isComplete = false;\n        var endDuration = function () {\n            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();\n            durationSubscriber = null;\n            if (hasValue) {\n                hasValue = false;\n                var value = lastValue;\n                lastValue = null;\n                subscriber.next(value);\n            }\n            isComplete && subscriber.complete();\n        };\n        var cleanupDuration = function () {\n            durationSubscriber = null;\n            isComplete && subscriber.complete();\n        };\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            hasValue = true;\n            lastValue = value;\n            if (!durationSubscriber) {\n                innerFrom_1.innerFrom(durationSelector(value)).subscribe((durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration)));\n            }\n        }, function () {\n            isComplete = true;\n            (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();\n        }));\n    });\n}\nexports.audit = audit;\n//# sourceMappingURL=audit.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/audit.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/auditTime.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/auditTime.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.auditTime = void 0;\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/async.js\");\nvar audit_1 = __webpack_require__(/*! ./audit */ \"./node_modules/rxjs/dist/cjs/internal/operators/audit.js\");\nvar timer_1 = __webpack_require__(/*! ../observable/timer */ \"./node_modules/rxjs/dist/cjs/internal/observable/timer.js\");\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }\n    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/auditTime.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/buffer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/buffer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.buffer = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nfunction buffer(closingNotifier) {\n    return lift_1.operate(function (source, subscriber) {\n        var currentBuffer = [];\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return currentBuffer.push(value); }, function () {\n            subscriber.next(currentBuffer);\n            subscriber.complete();\n        }));\n        innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {\n            var b = currentBuffer;\n            currentBuffer = [];\n            subscriber.next(b);\n        }, noop_1.noop));\n        return function () {\n            currentBuffer = null;\n        };\n    });\n}\nexports.buffer = buffer;\n//# sourceMappingURL=buffer.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/buffer.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bufferCount = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar arrRemove_1 = __webpack_require__(/*! ../util/arrRemove */ \"./node_modules/rxjs/dist/cjs/internal/util/arrRemove.js\");\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) { startBufferEvery = null; }\n    startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;\n    return lift_1.operate(function (source, subscriber) {\n        var buffers = [];\n        var count = 0;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            var e_1, _a, e_2, _b;\n            var toEmit = null;\n            if (count++ % startBufferEvery === 0) {\n                buffers.push([]);\n            }\n            try {\n                for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {\n                    var buffer = buffers_1_1.value;\n                    buffer.push(value);\n                    if (bufferSize <= buffer.length) {\n                        toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];\n                        toEmit.push(buffer);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            if (toEmit) {\n                try {\n                    for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {\n                        var buffer = toEmit_1_1.value;\n                        arrRemove_1.arrRemove(buffers, buffer);\n                        subscriber.next(buffer);\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }, function () {\n            var e_3, _a;\n            try {\n                for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {\n                    var buffer = buffers_2_1.value;\n                    subscriber.next(buffer);\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n            subscriber.complete();\n        }, undefined, function () {\n            buffers = null;\n        }));\n    });\n}\nexports.bufferCount = bufferCount;\n//# sourceMappingURL=bufferCount.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bufferTime = void 0;\nvar Subscription_1 = __webpack_require__(/*! ../Subscription */ \"./node_modules/rxjs/dist/cjs/internal/Subscription.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar arrRemove_1 = __webpack_require__(/*! ../util/arrRemove */ \"./node_modules/rxjs/dist/cjs/internal/util/arrRemove.js\");\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/async.js\");\nvar args_1 = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/cjs/internal/util/args.js\");\nvar executeSchedule_1 = __webpack_require__(/*! ../util/executeSchedule */ \"./node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js\");\nfunction bufferTime(bufferTimeSpan) {\n    var _a, _b;\n    var otherArgs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        otherArgs[_i - 1] = arguments[_i];\n    }\n    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;\n    var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;\n    var maxBufferSize = otherArgs[1] || Infinity;\n    return lift_1.operate(function (source, subscriber) {\n        var bufferRecords = [];\n        var restartOnEmit = false;\n        var emit = function (record) {\n            var buffer = record.buffer, subs = record.subs;\n            subs.unsubscribe();\n            arrRemove_1.arrRemove(bufferRecords, record);\n            subscriber.next(buffer);\n            restartOnEmit && startBuffer();\n        };\n        var startBuffer = function () {\n            if (bufferRecords) {\n                var subs = new Subscription_1.Subscription();\n                subscriber.add(subs);\n                var buffer = [];\n                var record_1 = {\n                    buffer: buffer,\n                    subs: subs,\n                };\n                bufferRecords.push(record_1);\n                executeSchedule_1.executeSchedule(subs, scheduler, function () { return emit(record_1); }, bufferTimeSpan);\n            }\n        };\n        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n            executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n        }\n        else {\n            restartOnEmit = true;\n        }\n        startBuffer();\n        var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            var e_1, _a;\n            var recordsCopy = bufferRecords.slice();\n            try {\n                for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {\n                    var record = recordsCopy_1_1.value;\n                    var buffer = record.buffer;\n                    buffer.push(value);\n                    maxBufferSize <= buffer.length && emit(record);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a = recordsCopy_1.return)) _a.call(recordsCopy_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }, function () {\n            while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {\n                subscriber.next(bufferRecords.shift().buffer);\n            }\n            bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();\n            subscriber.complete();\n            subscriber.unsubscribe();\n        }, undefined, function () { return (bufferRecords = null); });\n        source.subscribe(bufferTimeSubscriber);\n    });\n}\nexports.bufferTime = bufferTime;\n//# sourceMappingURL=bufferTime.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bufferToggle = void 0;\nvar Subscription_1 = __webpack_require__(/*! ../Subscription */ \"./node_modules/rxjs/dist/cjs/internal/Subscription.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nvar arrRemove_1 = __webpack_require__(/*! ../util/arrRemove */ \"./node_modules/rxjs/dist/cjs/internal/util/arrRemove.js\");\nfunction bufferToggle(openings, closingSelector) {\n    return lift_1.operate(function (source, subscriber) {\n        var buffers = [];\n        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (openValue) {\n            var buffer = [];\n            buffers.push(buffer);\n            var closingSubscription = new Subscription_1.Subscription();\n            var emitBuffer = function () {\n                arrRemove_1.arrRemove(buffers, buffer);\n                subscriber.next(buffer);\n                closingSubscription.unsubscribe();\n            };\n            closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));\n        }, noop_1.noop));\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            var e_1, _a;\n            try {\n                for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {\n                    var buffer = buffers_1_1.value;\n                    buffer.push(value);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }, function () {\n            while (buffers.length > 0) {\n                subscriber.next(buffers.shift());\n            }\n            subscriber.complete();\n        }));\n    });\n}\nexports.bufferToggle = bufferToggle;\n//# sourceMappingURL=bufferToggle.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bufferWhen = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nfunction bufferWhen(closingSelector) {\n    return lift_1.operate(function (source, subscriber) {\n        var buffer = null;\n        var closingSubscriber = null;\n        var openBuffer = function () {\n            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();\n            var b = buffer;\n            buffer = [];\n            b && subscriber.next(b);\n            innerFrom_1.innerFrom(closingSelector()).subscribe((closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop)));\n        };\n        openBuffer();\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return buffer === null || buffer === void 0 ? void 0 : buffer.push(value); }, function () {\n            buffer && subscriber.next(buffer);\n            subscriber.complete();\n        }, undefined, function () { return (buffer = closingSubscriber = null); }));\n    });\n}\nexports.bufferWhen = bufferWhen;\n//# sourceMappingURL=bufferWhen.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/catchError.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/catchError.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.catchError = void 0;\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nfunction catchError(selector) {\n    return lift_1.operate(function (source, subscriber) {\n        var innerSub = null;\n        var syncUnsub = false;\n        var handledResult;\n        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function (err) {\n            handledResult = innerFrom_1.innerFrom(selector(err, catchError(selector)(source)));\n            if (innerSub) {\n                innerSub.unsubscribe();\n                innerSub = null;\n                handledResult.subscribe(subscriber);\n            }\n            else {\n                syncUnsub = true;\n            }\n        }));\n        if (syncUnsub) {\n            innerSub.unsubscribe();\n            innerSub = null;\n            handledResult.subscribe(subscriber);\n        }\n    });\n}\nexports.catchError = catchError;\n//# sourceMappingURL=catchError.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/catchError.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/combineAll.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/combineAll.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.combineAll = void 0;\nvar combineLatestAll_1 = __webpack_require__(/*! ./combineLatestAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js\");\nexports.combineAll = combineLatestAll_1.combineLatestAll;\n//# sourceMappingURL=combineAll.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/combineAll.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js":
/*!************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.combineLatest = void 0;\nvar combineLatest_1 = __webpack_require__(/*! ../observable/combineLatest */ \"./node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar argsOrArgArray_1 = __webpack_require__(/*! ../util/argsOrArgArray */ \"./node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js\");\nvar mapOneOrManyArgs_1 = __webpack_require__(/*! ../util/mapOneOrManyArgs */ \"./node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js\");\nvar pipe_1 = __webpack_require__(/*! ../util/pipe */ \"./node_modules/rxjs/dist/cjs/internal/util/pipe.js\");\nvar args_1 = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/cjs/internal/util/args.js\");\nfunction combineLatest() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var resultSelector = args_1.popResultSelector(args);\n    return resultSelector\n        ? pipe_1.pipe(combineLatest.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector))\n        : lift_1.operate(function (source, subscriber) {\n            combineLatest_1.combineLatestInit(__spreadArray([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);\n        });\n}\nexports.combineLatest = combineLatest;\n//# sourceMappingURL=combineLatest.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.combineLatestAll = void 0;\nvar combineLatest_1 = __webpack_require__(/*! ../observable/combineLatest */ \"./node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js\");\nvar joinAllInternals_1 = __webpack_require__(/*! ./joinAllInternals */ \"./node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js\");\nfunction combineLatestAll(project) {\n    return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);\n}\nexports.combineLatestAll = combineLatestAll;\n//# sourceMappingURL=combineLatestAll.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js":
/*!****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.combineLatestWith = void 0;\nvar combineLatest_1 = __webpack_require__(/*! ./combineLatest */ \"./node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js\");\nfunction combineLatestWith() {\n    var otherSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        otherSources[_i] = arguments[_i];\n    }\n    return combineLatest_1.combineLatest.apply(void 0, __spreadArray([], __read(otherSources)));\n}\nexports.combineLatestWith = combineLatestWith;\n//# sourceMappingURL=combineLatestWith.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/concat.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/concat.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.concat = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar concatAll_1 = __webpack_require__(/*! ./concatAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/concatAll.js\");\nvar args_1 = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/cjs/internal/util/args.js\");\nvar from_1 = __webpack_require__(/*! ../observable/from */ \"./node_modules/rxjs/dist/cjs/internal/observable/from.js\");\nfunction concat() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var scheduler = args_1.popScheduler(args);\n    return lift_1.operate(function (source, subscriber) {\n        concatAll_1.concatAll()(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);\n    });\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/concat.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/concatAll.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/concatAll.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.concatAll = void 0;\nvar mergeAll_1 = __webpack_require__(/*! ./mergeAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js\");\nfunction concatAll() {\n    return mergeAll_1.mergeAll(1);\n}\nexports.concatAll = concatAll;\n//# sourceMappingURL=concatAll.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/concatAll.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/concatMap.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/concatMap.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.concatMap = void 0;\nvar mergeMap_1 = __webpack_require__(/*! ./mergeMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction concatMap(project, resultSelector) {\n    return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);\n}\nexports.concatMap = concatMap;\n//# sourceMappingURL=concatMap.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/concatMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.concatMapTo = void 0;\nvar concatMap_1 = __webpack_require__(/*! ./concatMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/concatMap.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction concatMapTo(innerObservable, resultSelector) {\n    return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function () { return innerObservable; }, resultSelector) : concatMap_1.concatMap(function () { return innerObservable; });\n}\nexports.concatMapTo = concatMapTo;\n//# sourceMappingURL=concatMapTo.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/concatWith.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/concatWith.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.concatWith = void 0;\nvar concat_1 = __webpack_require__(/*! ./concat */ \"./node_modules/rxjs/dist/cjs/internal/operators/concat.js\");\nfunction concatWith() {\n    var otherSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        otherSources[_i] = arguments[_i];\n    }\n    return concat_1.concat.apply(void 0, __spreadArray([], __read(otherSources)));\n}\nexports.concatWith = concatWith;\n//# sourceMappingURL=concatWith.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/concatWith.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/connect.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/connect.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.connect = void 0;\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar fromSubscribable_1 = __webpack_require__(/*! ../observable/fromSubscribable */ \"./node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js\");\nvar DEFAULT_CONFIG = {\n    connector: function () { return new Subject_1.Subject(); },\n};\nfunction connect(selector, config) {\n    if (config === void 0) { config = DEFAULT_CONFIG; }\n    var connector = config.connector;\n    return lift_1.operate(function (source, subscriber) {\n        var subject = connector();\n        innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);\n        subscriber.add(source.subscribe(subject));\n    });\n}\nexports.connect = connect;\n//# sourceMappingURL=connect.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/connect.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/count.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/count.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.count = void 0;\nvar reduce_1 = __webpack_require__(/*! ./reduce */ \"./node_modules/rxjs/dist/cjs/internal/operators/reduce.js\");\nfunction count(predicate) {\n    return reduce_1.reduce(function (total, value, i) { return (!predicate || predicate(value, i) ? total + 1 : total); }, 0);\n}\nexports.count = count;\n//# sourceMappingURL=count.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/count.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/debounce.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/debounce.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.debounce = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nfunction debounce(durationSelector) {\n    return lift_1.operate(function (source, subscriber) {\n        var hasValue = false;\n        var lastValue = null;\n        var durationSubscriber = null;\n        var emit = function () {\n            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();\n            durationSubscriber = null;\n            if (hasValue) {\n                hasValue = false;\n                var value = lastValue;\n                lastValue = null;\n                subscriber.next(value);\n            }\n        };\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();\n            hasValue = true;\n            lastValue = value;\n            durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);\n            innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);\n        }, function () {\n            emit();\n            subscriber.complete();\n        }, undefined, function () {\n            lastValue = durationSubscriber = null;\n        }));\n    });\n}\nexports.debounce = debounce;\n//# sourceMappingURL=debounce.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/debounce.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.debounceTime = void 0;\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/async.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }\n    return lift_1.operate(function (source, subscriber) {\n        var activeTask = null;\n        var lastValue = null;\n        var lastTime = null;\n        var emit = function () {\n            if (activeTask) {\n                activeTask.unsubscribe();\n                activeTask = null;\n                var value = lastValue;\n                lastValue = null;\n                subscriber.next(value);\n            }\n        };\n        function emitWhenIdle() {\n            var targetTime = lastTime + dueTime;\n            var now = scheduler.now();\n            if (now < targetTime) {\n                activeTask = this.schedule(undefined, targetTime - now);\n                subscriber.add(activeTask);\n                return;\n            }\n            emit();\n        }\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            lastValue = value;\n            lastTime = scheduler.now();\n            if (!activeTask) {\n                activeTask = scheduler.schedule(emitWhenIdle, dueTime);\n                subscriber.add(activeTask);\n            }\n        }, function () {\n            emit();\n            subscriber.complete();\n        }, undefined, function () {\n            lastValue = activeTask = null;\n        }));\n    });\n}\nexports.debounceTime = debounceTime;\n//# sourceMappingURL=debounceTime.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultIfEmpty = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction defaultIfEmpty(defaultValue) {\n    return lift_1.operate(function (source, subscriber) {\n        var hasValue = false;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            hasValue = true;\n            subscriber.next(value);\n        }, function () {\n            if (!hasValue) {\n                subscriber.next(defaultValue);\n            }\n            subscriber.complete();\n        }));\n    });\n}\nexports.defaultIfEmpty = defaultIfEmpty;\n//# sourceMappingURL=defaultIfEmpty.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/delay.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/delay.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.delay = void 0;\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/async.js\");\nvar delayWhen_1 = __webpack_require__(/*! ./delayWhen */ \"./node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js\");\nvar timer_1 = __webpack_require__(/*! ../observable/timer */ \"./node_modules/rxjs/dist/cjs/internal/observable/timer.js\");\nfunction delay(due, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }\n    var duration = timer_1.timer(due, scheduler);\n    return delayWhen_1.delayWhen(function () { return duration; });\n}\nexports.delay = delay;\n//# sourceMappingURL=delay.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/delay.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.delayWhen = void 0;\nvar concat_1 = __webpack_require__(/*! ../observable/concat */ \"./node_modules/rxjs/dist/cjs/internal/observable/concat.js\");\nvar take_1 = __webpack_require__(/*! ./take */ \"./node_modules/rxjs/dist/cjs/internal/operators/take.js\");\nvar ignoreElements_1 = __webpack_require__(/*! ./ignoreElements */ \"./node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js\");\nvar mapTo_1 = __webpack_require__(/*! ./mapTo */ \"./node_modules/rxjs/dist/cjs/internal/operators/mapTo.js\");\nvar mergeMap_1 = __webpack_require__(/*! ./mergeMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nfunction delayWhen(delayDurationSelector, subscriptionDelay) {\n    if (subscriptionDelay) {\n        return function (source) {\n            return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));\n        };\n    }\n    return mergeMap_1.mergeMap(function (value, index) { return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value)); });\n}\nexports.delayWhen = delayWhen;\n//# sourceMappingURL=delayWhen.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js":
/*!************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dematerialize = void 0;\nvar Notification_1 = __webpack_require__(/*! ../Notification */ \"./node_modules/rxjs/dist/cjs/internal/Notification.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction dematerialize() {\n    return lift_1.operate(function (source, subscriber) {\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (notification) { return Notification_1.observeNotification(notification, subscriber); }));\n    });\n}\nexports.dematerialize = dematerialize;\n//# sourceMappingURL=dematerialize.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/distinct.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/distinct.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.distinct = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nfunction distinct(keySelector, flushes) {\n    return lift_1.operate(function (source, subscriber) {\n        var distinctKeys = new Set();\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            var key = keySelector ? keySelector(value) : value;\n            if (!distinctKeys.has(key)) {\n                distinctKeys.add(key);\n                subscriber.next(value);\n            }\n        }));\n        flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () { return distinctKeys.clear(); }, noop_1.noop));\n    });\n}\nexports.distinct = distinct;\n//# sourceMappingURL=distinct.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/distinct.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.distinctUntilChanged = void 0;\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction distinctUntilChanged(comparator, keySelector) {\n    if (keySelector === void 0) { keySelector = identity_1.identity; }\n    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;\n    return lift_1.operate(function (source, subscriber) {\n        var previousKey;\n        var first = true;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            var currentKey = keySelector(value);\n            if (first || !comparator(previousKey, currentKey)) {\n                first = false;\n                previousKey = currentKey;\n                subscriber.next(value);\n            }\n        }));\n    });\n}\nexports.distinctUntilChanged = distinctUntilChanged;\nfunction defaultCompare(a, b) {\n    return a === b;\n}\n//# sourceMappingURL=distinctUntilChanged.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.distinctUntilKeyChanged = void 0;\nvar distinctUntilChanged_1 = __webpack_require__(/*! ./distinctUntilChanged */ \"./node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js\");\nfunction distinctUntilKeyChanged(key, compare) {\n    return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });\n}\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n//# sourceMappingURL=distinctUntilKeyChanged.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/elementAt.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/elementAt.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.elementAt = void 0;\nvar ArgumentOutOfRangeError_1 = __webpack_require__(/*! ../util/ArgumentOutOfRangeError */ \"./node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js\");\nvar filter_1 = __webpack_require__(/*! ./filter */ \"./node_modules/rxjs/dist/cjs/internal/operators/filter.js\");\nvar throwIfEmpty_1 = __webpack_require__(/*! ./throwIfEmpty */ \"./node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js\");\nvar defaultIfEmpty_1 = __webpack_require__(/*! ./defaultIfEmpty */ \"./node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js\");\nvar take_1 = __webpack_require__(/*! ./take */ \"./node_modules/rxjs/dist/cjs/internal/operators/take.js\");\nfunction elementAt(index, defaultValue) {\n    if (index < 0) {\n        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();\n    }\n    var hasDefaultValue = arguments.length >= 2;\n    return function (source) {\n        return source.pipe(filter_1.filter(function (v, i) { return i === index; }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError(); }));\n    };\n}\nexports.elementAt = elementAt;\n//# sourceMappingURL=elementAt.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/elementAt.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/endWith.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/endWith.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.endWith = void 0;\nvar concat_1 = __webpack_require__(/*! ../observable/concat */ \"./node_modules/rxjs/dist/cjs/internal/observable/concat.js\");\nvar of_1 = __webpack_require__(/*! ../observable/of */ \"./node_modules/rxjs/dist/cjs/internal/observable/of.js\");\nfunction endWith() {\n    var values = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        values[_i] = arguments[_i];\n    }\n    return function (source) { return concat_1.concat(source, of_1.of.apply(void 0, __spreadArray([], __read(values)))); };\n}\nexports.endWith = endWith;\n//# sourceMappingURL=endWith.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/endWith.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/every.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/every.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.every = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction every(predicate, thisArg) {\n    return lift_1.operate(function (source, subscriber) {\n        var index = 0;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            if (!predicate.call(thisArg, value, index++, source)) {\n                subscriber.next(false);\n                subscriber.complete();\n            }\n        }, function () {\n            subscriber.next(true);\n            subscriber.complete();\n        }));\n    });\n}\nexports.every = every;\n//# sourceMappingURL=every.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/every.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/exhaust.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/exhaust.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.exhaust = void 0;\nvar exhaustAll_1 = __webpack_require__(/*! ./exhaustAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js\");\nexports.exhaust = exhaustAll_1.exhaustAll;\n//# sourceMappingURL=exhaust.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/exhaust.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.exhaustAll = void 0;\nvar exhaustMap_1 = __webpack_require__(/*! ./exhaustMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js\");\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nfunction exhaustAll() {\n    return exhaustMap_1.exhaustMap(identity_1.identity);\n}\nexports.exhaustAll = exhaustAll;\n//# sourceMappingURL=exhaustAll.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.exhaustMap = void 0;\nvar map_1 = __webpack_require__(/*! ./map */ \"./node_modules/rxjs/dist/cjs/internal/operators/map.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction exhaustMap(project, resultSelector) {\n    if (resultSelector) {\n        return function (source) {\n            return source.pipe(exhaustMap(function (a, i) { return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); }));\n        };\n    }\n    return lift_1.operate(function (source, subscriber) {\n        var index = 0;\n        var innerSub = null;\n        var isComplete = false;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (outerValue) {\n            if (!innerSub) {\n                innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function () {\n                    innerSub = null;\n                    isComplete && subscriber.complete();\n                });\n                innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);\n            }\n        }, function () {\n            isComplete = true;\n            !innerSub && subscriber.complete();\n        }));\n    });\n}\nexports.exhaustMap = exhaustMap;\n//# sourceMappingURL=exhaustMap.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/expand.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/expand.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.expand = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar mergeInternals_1 = __webpack_require__(/*! ./mergeInternals */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js\");\nfunction expand(project, concurrent, scheduler) {\n    if (concurrent === void 0) { concurrent = Infinity; }\n    concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;\n    return lift_1.operate(function (source, subscriber) {\n        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, undefined, true, scheduler);\n    });\n}\nexports.expand = expand;\n//# sourceMappingURL=expand.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/expand.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/filter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/filter.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.filter = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction filter(predicate, thisArg) {\n    return lift_1.operate(function (source, subscriber) {\n        var index = 0;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));\n    });\n}\nexports.filter = filter;\n//# sourceMappingURL=filter.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/filter.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/finalize.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/finalize.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.finalize = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nfunction finalize(callback) {\n    return lift_1.operate(function (source, subscriber) {\n        try {\n            source.subscribe(subscriber);\n        }\n        finally {\n            subscriber.add(callback);\n        }\n    });\n}\nexports.finalize = finalize;\n//# sourceMappingURL=finalize.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/finalize.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/find.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/find.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createFind = exports.find = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction find(predicate, thisArg) {\n    return lift_1.operate(createFind(predicate, thisArg, 'value'));\n}\nexports.find = find;\nfunction createFind(predicate, thisArg, emit) {\n    var findIndex = emit === 'index';\n    return function (source, subscriber) {\n        var index = 0;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            var i = index++;\n            if (predicate.call(thisArg, value, i, source)) {\n                subscriber.next(findIndex ? i : value);\n                subscriber.complete();\n            }\n        }, function () {\n            subscriber.next(findIndex ? -1 : undefined);\n            subscriber.complete();\n        }));\n    };\n}\nexports.createFind = createFind;\n//# sourceMappingURL=find.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/find.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/findIndex.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/findIndex.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.findIndex = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar find_1 = __webpack_require__(/*! ./find */ \"./node_modules/rxjs/dist/cjs/internal/operators/find.js\");\nfunction findIndex(predicate, thisArg) {\n    return lift_1.operate(find_1.createFind(predicate, thisArg, 'index'));\n}\nexports.findIndex = findIndex;\n//# sourceMappingURL=findIndex.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/findIndex.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/first.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/first.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.first = void 0;\nvar EmptyError_1 = __webpack_require__(/*! ../util/EmptyError */ \"./node_modules/rxjs/dist/cjs/internal/util/EmptyError.js\");\nvar filter_1 = __webpack_require__(/*! ./filter */ \"./node_modules/rxjs/dist/cjs/internal/operators/filter.js\");\nvar take_1 = __webpack_require__(/*! ./take */ \"./node_modules/rxjs/dist/cjs/internal/operators/take.js\");\nvar defaultIfEmpty_1 = __webpack_require__(/*! ./defaultIfEmpty */ \"./node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js\");\nvar throwIfEmpty_1 = __webpack_require__(/*! ./throwIfEmpty */ \"./node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js\");\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nfunction first(predicate, defaultValue) {\n    var hasDefaultValue = arguments.length >= 2;\n    return function (source) {\n        return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); }));\n    };\n}\nexports.first = first;\n//# sourceMappingURL=first.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/first.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/flatMap.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/flatMap.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.flatMap = void 0;\nvar mergeMap_1 = __webpack_require__(/*! ./mergeMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js\");\nexports.flatMap = mergeMap_1.mergeMap;\n//# sourceMappingURL=flatMap.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/flatMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/groupBy.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/groupBy.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.groupBy = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction groupBy(keySelector, elementOrOptions, duration, connector) {\n    return lift_1.operate(function (source, subscriber) {\n        var element;\n        if (!elementOrOptions || typeof elementOrOptions === 'function') {\n            element = elementOrOptions;\n        }\n        else {\n            (duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector);\n        }\n        var groups = new Map();\n        var notify = function (cb) {\n            groups.forEach(cb);\n            cb(subscriber);\n        };\n        var handleError = function (err) { return notify(function (consumer) { return consumer.error(err); }); };\n        var activeGroups = 0;\n        var teardownAttempted = false;\n        var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function (value) {\n            try {\n                var key_1 = keySelector(value);\n                var group_1 = groups.get(key_1);\n                if (!group_1) {\n                    groups.set(key_1, (group_1 = connector ? connector() : new Subject_1.Subject()));\n                    var grouped = createGroupedObservable(key_1, group_1);\n                    subscriber.next(grouped);\n                    if (duration) {\n                        var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function () {\n                            group_1.complete();\n                            durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();\n                        }, undefined, undefined, function () { return groups.delete(key_1); });\n                        groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));\n                    }\n                }\n                group_1.next(element ? element(value) : value);\n            }\n            catch (err) {\n                handleError(err);\n            }\n        }, function () { return notify(function (consumer) { return consumer.complete(); }); }, handleError, function () { return groups.clear(); }, function () {\n            teardownAttempted = true;\n            return activeGroups === 0;\n        });\n        source.subscribe(groupBySourceSubscriber);\n        function createGroupedObservable(key, groupSubject) {\n            var result = new Observable_1.Observable(function (groupSubscriber) {\n                activeGroups++;\n                var innerSub = groupSubject.subscribe(groupSubscriber);\n                return function () {\n                    innerSub.unsubscribe();\n                    --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();\n                };\n            });\n            result.key = key;\n            return result;\n        }\n    });\n}\nexports.groupBy = groupBy;\n//# sourceMappingURL=groupBy.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/groupBy.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ignoreElements = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nfunction ignoreElements() {\n    return lift_1.operate(function (source, subscriber) {\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));\n    });\n}\nexports.ignoreElements = ignoreElements;\n//# sourceMappingURL=ignoreElements.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isEmpty = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction isEmpty() {\n    return lift_1.operate(function (source, subscriber) {\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {\n            subscriber.next(false);\n            subscriber.complete();\n        }, function () {\n            subscriber.next(true);\n            subscriber.complete();\n        }));\n    });\n}\nexports.isEmpty = isEmpty;\n//# sourceMappingURL=isEmpty.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.joinAllInternals = void 0;\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nvar mapOneOrManyArgs_1 = __webpack_require__(/*! ../util/mapOneOrManyArgs */ \"./node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js\");\nvar pipe_1 = __webpack_require__(/*! ../util/pipe */ \"./node_modules/rxjs/dist/cjs/internal/util/pipe.js\");\nvar mergeMap_1 = __webpack_require__(/*! ./mergeMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js\");\nvar toArray_1 = __webpack_require__(/*! ./toArray */ \"./node_modules/rxjs/dist/cjs/internal/operators/toArray.js\");\nfunction joinAllInternals(joinFn, project) {\n    return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function (sources) { return joinFn(sources); }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);\n}\nexports.joinAllInternals = joinAllInternals;\n//# sourceMappingURL=joinAllInternals.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/last.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/last.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.last = void 0;\nvar EmptyError_1 = __webpack_require__(/*! ../util/EmptyError */ \"./node_modules/rxjs/dist/cjs/internal/util/EmptyError.js\");\nvar filter_1 = __webpack_require__(/*! ./filter */ \"./node_modules/rxjs/dist/cjs/internal/operators/filter.js\");\nvar takeLast_1 = __webpack_require__(/*! ./takeLast */ \"./node_modules/rxjs/dist/cjs/internal/operators/takeLast.js\");\nvar throwIfEmpty_1 = __webpack_require__(/*! ./throwIfEmpty */ \"./node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js\");\nvar defaultIfEmpty_1 = __webpack_require__(/*! ./defaultIfEmpty */ \"./node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js\");\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nfunction last(predicate, defaultValue) {\n    var hasDefaultValue = arguments.length >= 2;\n    return function (source) {\n        return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); }));\n    };\n}\nexports.last = last;\n//# sourceMappingURL=last.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/last.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/map.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/map.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.map = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction map(project, thisArg) {\n    return lift_1.operate(function (source, subscriber) {\n        var index = 0;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            subscriber.next(project.call(thisArg, value, index++));\n        }));\n    });\n}\nexports.map = map;\n//# sourceMappingURL=map.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/map.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/mapTo.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/mapTo.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapTo = void 0;\nvar map_1 = __webpack_require__(/*! ./map */ \"./node_modules/rxjs/dist/cjs/internal/operators/map.js\");\nfunction mapTo(value) {\n    return map_1.map(function () { return value; });\n}\nexports.mapTo = mapTo;\n//# sourceMappingURL=mapTo.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/mapTo.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/materialize.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/materialize.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.materialize = void 0;\nvar Notification_1 = __webpack_require__(/*! ../Notification */ \"./node_modules/rxjs/dist/cjs/internal/Notification.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction materialize() {\n    return lift_1.operate(function (source, subscriber) {\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            subscriber.next(Notification_1.Notification.createNext(value));\n        }, function () {\n            subscriber.next(Notification_1.Notification.createComplete());\n            subscriber.complete();\n        }, function (err) {\n            subscriber.next(Notification_1.Notification.createError(err));\n            subscriber.complete();\n        }));\n    });\n}\nexports.materialize = materialize;\n//# sourceMappingURL=materialize.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/materialize.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/max.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/max.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.max = void 0;\nvar reduce_1 = __webpack_require__(/*! ./reduce */ \"./node_modules/rxjs/dist/cjs/internal/operators/reduce.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction max(comparer) {\n    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function (x, y) { return (comparer(x, y) > 0 ? x : y); } : function (x, y) { return (x > y ? x : y); });\n}\nexports.max = max;\n//# sourceMappingURL=max.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/max.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/merge.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/merge.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.merge = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar argsOrArgArray_1 = __webpack_require__(/*! ../util/argsOrArgArray */ \"./node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js\");\nvar mergeAll_1 = __webpack_require__(/*! ./mergeAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js\");\nvar args_1 = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/cjs/internal/util/args.js\");\nvar from_1 = __webpack_require__(/*! ../observable/from */ \"./node_modules/rxjs/dist/cjs/internal/observable/from.js\");\nfunction merge() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var scheduler = args_1.popScheduler(args);\n    var concurrent = args_1.popNumber(args, Infinity);\n    args = argsOrArgArray_1.argsOrArgArray(args);\n    return lift_1.operate(function (source, subscriber) {\n        mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);\n    });\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/merge.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mergeAll = void 0;\nvar mergeMap_1 = __webpack_require__(/*! ./mergeMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js\");\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nfunction mergeAll(concurrent) {\n    if (concurrent === void 0) { concurrent = Infinity; }\n    return mergeMap_1.mergeMap(identity_1.identity, concurrent);\n}\nexports.mergeAll = mergeAll;\n//# sourceMappingURL=mergeAll.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mergeInternals = void 0;\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar executeSchedule_1 = __webpack_require__(/*! ../util/executeSchedule */ \"./node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n    var buffer = [];\n    var active = 0;\n    var index = 0;\n    var isComplete = false;\n    var checkComplete = function () {\n        if (isComplete && !buffer.length && !active) {\n            subscriber.complete();\n        }\n    };\n    var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };\n    var doInnerSub = function (value) {\n        expand && subscriber.next(value);\n        active++;\n        var innerComplete = false;\n        innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (innerValue) {\n            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n            if (expand) {\n                outerNext(innerValue);\n            }\n            else {\n                subscriber.next(innerValue);\n            }\n        }, function () {\n            innerComplete = true;\n        }, undefined, function () {\n            if (innerComplete) {\n                try {\n                    active--;\n                    var _loop_1 = function () {\n                        var bufferedValue = buffer.shift();\n                        if (innerSubScheduler) {\n                            executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function () { return doInnerSub(bufferedValue); });\n                        }\n                        else {\n                            doInnerSub(bufferedValue);\n                        }\n                    };\n                    while (buffer.length && active < concurrent) {\n                        _loop_1();\n                    }\n                    checkComplete();\n                }\n                catch (err) {\n                    subscriber.error(err);\n                }\n            }\n        }));\n    };\n    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function () {\n        isComplete = true;\n        checkComplete();\n    }));\n    return function () {\n        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n    };\n}\nexports.mergeInternals = mergeInternals;\n//# sourceMappingURL=mergeInternals.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mergeMap = void 0;\nvar map_1 = __webpack_require__(/*! ./map */ \"./node_modules/rxjs/dist/cjs/internal/operators/map.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar mergeInternals_1 = __webpack_require__(/*! ./mergeInternals */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Infinity; }\n    if (isFunction_1.isFunction(resultSelector)) {\n        return mergeMap(function (a, i) { return map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })(innerFrom_1.innerFrom(project(a, i))); }, concurrent);\n    }\n    else if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return lift_1.operate(function (source, subscriber) { return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent); });\n}\nexports.mergeMap = mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mergeMapTo = void 0;\nvar mergeMap_1 = __webpack_require__(/*! ./mergeMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction mergeMapTo(innerObservable, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Infinity; }\n    if (isFunction_1.isFunction(resultSelector)) {\n        return mergeMap_1.mergeMap(function () { return innerObservable; }, resultSelector, concurrent);\n    }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return mergeMap_1.mergeMap(function () { return innerObservable; }, concurrent);\n}\nexports.mergeMapTo = mergeMapTo;\n//# sourceMappingURL=mergeMapTo.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mergeScan = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar mergeInternals_1 = __webpack_require__(/*! ./mergeInternals */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js\");\nfunction mergeScan(accumulator, seed, concurrent) {\n    if (concurrent === void 0) { concurrent = Infinity; }\n    return lift_1.operate(function (source, subscriber) {\n        var state = seed;\n        return mergeInternals_1.mergeInternals(source, subscriber, function (value, index) { return accumulator(state, value, index); }, concurrent, function (value) {\n            state = value;\n        }, false, undefined, function () { return (state = null); });\n    });\n}\nexports.mergeScan = mergeScan;\n//# sourceMappingURL=mergeScan.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mergeWith = void 0;\nvar merge_1 = __webpack_require__(/*! ./merge */ \"./node_modules/rxjs/dist/cjs/internal/operators/merge.js\");\nfunction mergeWith() {\n    var otherSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        otherSources[_i] = arguments[_i];\n    }\n    return merge_1.merge.apply(void 0, __spreadArray([], __read(otherSources)));\n}\nexports.mergeWith = mergeWith;\n//# sourceMappingURL=mergeWith.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/min.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/min.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.min = void 0;\nvar reduce_1 = __webpack_require__(/*! ./reduce */ \"./node_modules/rxjs/dist/cjs/internal/operators/reduce.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction min(comparer) {\n    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function (x, y) { return (comparer(x, y) < 0 ? x : y); } : function (x, y) { return (x < y ? x : y); });\n}\nexports.min = min;\n//# sourceMappingURL=min.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/min.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/multicast.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/multicast.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.multicast = void 0;\nvar ConnectableObservable_1 = __webpack_require__(/*! ../observable/ConnectableObservable */ \"./node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nvar connect_1 = __webpack_require__(/*! ./connect */ \"./node_modules/rxjs/dist/cjs/internal/operators/connect.js\");\nfunction multicast(subjectOrSubjectFactory, selector) {\n    var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function () { return subjectOrSubjectFactory; };\n    if (isFunction_1.isFunction(selector)) {\n        return connect_1.connect(selector, {\n            connector: subjectFactory,\n        });\n    }\n    return function (source) { return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory); };\n}\nexports.multicast = multicast;\n//# sourceMappingURL=multicast.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/multicast.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/observeOn.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/observeOn.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.observeOn = void 0;\nvar executeSchedule_1 = __webpack_require__(/*! ../util/executeSchedule */ \"./node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction observeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return lift_1.operate(function (source, subscriber) {\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return executeSchedule_1.executeSchedule(subscriber, scheduler, function () { return subscriber.next(value); }, delay); }, function () { return executeSchedule_1.executeSchedule(subscriber, scheduler, function () { return subscriber.complete(); }, delay); }, function (err) { return executeSchedule_1.executeSchedule(subscriber, scheduler, function () { return subscriber.error(err); }, delay); }));\n    });\n}\nexports.observeOn = observeOn;\n//# sourceMappingURL=observeOn.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/observeOn.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js":
/*!********************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.onErrorResumeNext = exports.onErrorResumeNextWith = void 0;\nvar argsOrArgArray_1 = __webpack_require__(/*! ../util/argsOrArgArray */ \"./node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js\");\nvar onErrorResumeNext_1 = __webpack_require__(/*! ../observable/onErrorResumeNext */ \"./node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js\");\nfunction onErrorResumeNextWith() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);\n    return function (source) { return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray([source], __read(nextSources))); };\n}\nexports.onErrorResumeNextWith = onErrorResumeNextWith;\nexports.onErrorResumeNext = onErrorResumeNextWith;\n//# sourceMappingURL=onErrorResumeNextWith.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/pairwise.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/pairwise.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pairwise = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction pairwise() {\n    return lift_1.operate(function (source, subscriber) {\n        var prev;\n        var hasPrev = false;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            var p = prev;\n            prev = value;\n            hasPrev && subscriber.next([p, value]);\n            hasPrev = true;\n        }));\n    });\n}\nexports.pairwise = pairwise;\n//# sourceMappingURL=pairwise.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/pairwise.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/partition.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/partition.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.partition = void 0;\nvar not_1 = __webpack_require__(/*! ../util/not */ \"./node_modules/rxjs/dist/cjs/internal/util/not.js\");\nvar filter_1 = __webpack_require__(/*! ./filter */ \"./node_modules/rxjs/dist/cjs/internal/operators/filter.js\");\nfunction partition(predicate, thisArg) {\n    return function (source) {\n        return [filter_1.filter(predicate, thisArg)(source), filter_1.filter(not_1.not(predicate, thisArg))(source)];\n    };\n}\nexports.partition = partition;\n//# sourceMappingURL=partition.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/partition.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/pluck.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/pluck.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pluck = void 0;\nvar map_1 = __webpack_require__(/*! ./map */ \"./node_modules/rxjs/dist/cjs/internal/operators/map.js\");\nfunction pluck() {\n    var properties = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        properties[_i] = arguments[_i];\n    }\n    var length = properties.length;\n    if (length === 0) {\n        throw new Error('list of properties cannot be empty.');\n    }\n    return map_1.map(function (x) {\n        var currentProp = x;\n        for (var i = 0; i < length; i++) {\n            var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];\n            if (typeof p !== 'undefined') {\n                currentProp = p;\n            }\n            else {\n                return undefined;\n            }\n        }\n        return currentProp;\n    });\n}\nexports.pluck = pluck;\n//# sourceMappingURL=pluck.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/pluck.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/publish.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/publish.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.publish = void 0;\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar multicast_1 = __webpack_require__(/*! ./multicast */ \"./node_modules/rxjs/dist/cjs/internal/operators/multicast.js\");\nvar connect_1 = __webpack_require__(/*! ./connect */ \"./node_modules/rxjs/dist/cjs/internal/operators/connect.js\");\nfunction publish(selector) {\n    return selector ? function (source) { return connect_1.connect(selector)(source); } : function (source) { return multicast_1.multicast(new Subject_1.Subject())(source); };\n}\nexports.publish = publish;\n//# sourceMappingURL=publish.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/publish.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.publishBehavior = void 0;\nvar BehaviorSubject_1 = __webpack_require__(/*! ../BehaviorSubject */ \"./node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js\");\nvar ConnectableObservable_1 = __webpack_require__(/*! ../observable/ConnectableObservable */ \"./node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js\");\nfunction publishBehavior(initialValue) {\n    return function (source) {\n        var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);\n        return new ConnectableObservable_1.ConnectableObservable(source, function () { return subject; });\n    };\n}\nexports.publishBehavior = publishBehavior;\n//# sourceMappingURL=publishBehavior.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/publishLast.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/publishLast.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.publishLast = void 0;\nvar AsyncSubject_1 = __webpack_require__(/*! ../AsyncSubject */ \"./node_modules/rxjs/dist/cjs/internal/AsyncSubject.js\");\nvar ConnectableObservable_1 = __webpack_require__(/*! ../observable/ConnectableObservable */ \"./node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js\");\nfunction publishLast() {\n    return function (source) {\n        var subject = new AsyncSubject_1.AsyncSubject();\n        return new ConnectableObservable_1.ConnectableObservable(source, function () { return subject; });\n    };\n}\nexports.publishLast = publishLast;\n//# sourceMappingURL=publishLast.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/publishLast.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js":
/*!************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.publishReplay = void 0;\nvar ReplaySubject_1 = __webpack_require__(/*! ../ReplaySubject */ \"./node_modules/rxjs/dist/cjs/internal/ReplaySubject.js\");\nvar multicast_1 = __webpack_require__(/*! ./multicast */ \"./node_modules/rxjs/dist/cjs/internal/operators/multicast.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {\n    if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {\n        timestampProvider = selectorOrScheduler;\n    }\n    var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;\n    return function (source) { return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source); };\n}\nexports.publishReplay = publishReplay;\n//# sourceMappingURL=publishReplay.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/race.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/race.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.race = void 0;\nvar argsOrArgArray_1 = __webpack_require__(/*! ../util/argsOrArgArray */ \"./node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js\");\nvar raceWith_1 = __webpack_require__(/*! ./raceWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/raceWith.js\");\nfunction race() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return raceWith_1.raceWith.apply(void 0, __spreadArray([], __read(argsOrArgArray_1.argsOrArgArray(args))));\n}\nexports.race = race;\n//# sourceMappingURL=race.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/race.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/raceWith.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/raceWith.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.raceWith = void 0;\nvar race_1 = __webpack_require__(/*! ../observable/race */ \"./node_modules/rxjs/dist/cjs/internal/observable/race.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nfunction raceWith() {\n    var otherSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        otherSources[_i] = arguments[_i];\n    }\n    return !otherSources.length\n        ? identity_1.identity\n        : lift_1.operate(function (source, subscriber) {\n            race_1.raceInit(__spreadArray([source], __read(otherSources)))(subscriber);\n        });\n}\nexports.raceWith = raceWith;\n//# sourceMappingURL=raceWith.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/raceWith.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/reduce.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/reduce.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.reduce = void 0;\nvar scanInternals_1 = __webpack_require__(/*! ./scanInternals */ \"./node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nfunction reduce(accumulator, seed) {\n    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));\n}\nexports.reduce = reduce;\n//# sourceMappingURL=reduce.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/reduce.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/refCount.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/refCount.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.refCount = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction refCount() {\n    return lift_1.operate(function (source, subscriber) {\n        var connection = null;\n        source._refCount++;\n        var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, undefined, function () {\n            if (!source || source._refCount <= 0 || 0 < --source._refCount) {\n                connection = null;\n                return;\n            }\n            var sharedConnection = source._connection;\n            var conn = connection;\n            connection = null;\n            if (sharedConnection && (!conn || sharedConnection === conn)) {\n                sharedConnection.unsubscribe();\n            }\n            subscriber.unsubscribe();\n        });\n        source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            connection = source.connect();\n        }\n    });\n}\nexports.refCount = refCount;\n//# sourceMappingURL=refCount.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/refCount.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/repeat.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/repeat.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.repeat = void 0;\nvar empty_1 = __webpack_require__(/*! ../observable/empty */ \"./node_modules/rxjs/dist/cjs/internal/observable/empty.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar timer_1 = __webpack_require__(/*! ../observable/timer */ \"./node_modules/rxjs/dist/cjs/internal/observable/timer.js\");\nfunction repeat(countOrConfig) {\n    var _a;\n    var count = Infinity;\n    var delay;\n    if (countOrConfig != null) {\n        if (typeof countOrConfig === 'object') {\n            (_a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay);\n        }\n        else {\n            count = countOrConfig;\n        }\n    }\n    return count <= 0\n        ? function () { return empty_1.EMPTY; }\n        : lift_1.operate(function (source, subscriber) {\n            var soFar = 0;\n            var sourceSub;\n            var resubscribe = function () {\n                sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();\n                sourceSub = null;\n                if (delay != null) {\n                    var notifier = typeof delay === 'number' ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));\n                    var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {\n                        notifierSubscriber_1.unsubscribe();\n                        subscribeToSource();\n                    });\n                    notifier.subscribe(notifierSubscriber_1);\n                }\n                else {\n                    subscribeToSource();\n                }\n            };\n            var subscribeToSource = function () {\n                var syncUnsub = false;\n                sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function () {\n                    if (++soFar < count) {\n                        if (sourceSub) {\n                            resubscribe();\n                        }\n                        else {\n                            syncUnsub = true;\n                        }\n                    }\n                    else {\n                        subscriber.complete();\n                    }\n                }));\n                if (syncUnsub) {\n                    resubscribe();\n                }\n            };\n            subscribeToSource();\n        });\n}\nexports.repeat = repeat;\n//# sourceMappingURL=repeat.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/repeat.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.repeatWhen = void 0;\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction repeatWhen(notifier) {\n    return lift_1.operate(function (source, subscriber) {\n        var innerSub;\n        var syncResub = false;\n        var completions$;\n        var isNotifierComplete = false;\n        var isMainComplete = false;\n        var checkComplete = function () { return isMainComplete && isNotifierComplete && (subscriber.complete(), true); };\n        var getCompletionSubject = function () {\n            if (!completions$) {\n                completions$ = new Subject_1.Subject();\n                innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {\n                    if (innerSub) {\n                        subscribeForRepeatWhen();\n                    }\n                    else {\n                        syncResub = true;\n                    }\n                }, function () {\n                    isNotifierComplete = true;\n                    checkComplete();\n                }));\n            }\n            return completions$;\n        };\n        var subscribeForRepeatWhen = function () {\n            isMainComplete = false;\n            innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function () {\n                isMainComplete = true;\n                !checkComplete() && getCompletionSubject().next();\n            }));\n            if (syncResub) {\n                innerSub.unsubscribe();\n                innerSub = null;\n                syncResub = false;\n                subscribeForRepeatWhen();\n            }\n        };\n        subscribeForRepeatWhen();\n    });\n}\nexports.repeatWhen = repeatWhen;\n//# sourceMappingURL=repeatWhen.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/retry.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/retry.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.retry = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nvar timer_1 = __webpack_require__(/*! ../observable/timer */ \"./node_modules/rxjs/dist/cjs/internal/observable/timer.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nfunction retry(configOrCount) {\n    if (configOrCount === void 0) { configOrCount = Infinity; }\n    var config;\n    if (configOrCount && typeof configOrCount === 'object') {\n        config = configOrCount;\n    }\n    else {\n        config = {\n            count: configOrCount,\n        };\n    }\n    var _a = config.count, count = _a === void 0 ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;\n    return count <= 0\n        ? identity_1.identity\n        : lift_1.operate(function (source, subscriber) {\n            var soFar = 0;\n            var innerSub;\n            var subscribeForRetry = function () {\n                var syncUnsub = false;\n                innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n                    if (resetOnSuccess) {\n                        soFar = 0;\n                    }\n                    subscriber.next(value);\n                }, undefined, function (err) {\n                    if (soFar++ < count) {\n                        var resub_1 = function () {\n                            if (innerSub) {\n                                innerSub.unsubscribe();\n                                innerSub = null;\n                                subscribeForRetry();\n                            }\n                            else {\n                                syncUnsub = true;\n                            }\n                        };\n                        if (delay != null) {\n                            var notifier = typeof delay === 'number' ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));\n                            var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {\n                                notifierSubscriber_1.unsubscribe();\n                                resub_1();\n                            }, function () {\n                                subscriber.complete();\n                            });\n                            notifier.subscribe(notifierSubscriber_1);\n                        }\n                        else {\n                            resub_1();\n                        }\n                    }\n                    else {\n                        subscriber.error(err);\n                    }\n                }));\n                if (syncUnsub) {\n                    innerSub.unsubscribe();\n                    innerSub = null;\n                    subscribeForRetry();\n                }\n            };\n            subscribeForRetry();\n        });\n}\nexports.retry = retry;\n//# sourceMappingURL=retry.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/retry.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.retryWhen = void 0;\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction retryWhen(notifier) {\n    return lift_1.operate(function (source, subscriber) {\n        var innerSub;\n        var syncResub = false;\n        var errors$;\n        var subscribeForRetryWhen = function () {\n            innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function (err) {\n                if (!errors$) {\n                    errors$ = new Subject_1.Subject();\n                    innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {\n                        return innerSub ? subscribeForRetryWhen() : (syncResub = true);\n                    }));\n                }\n                if (errors$) {\n                    errors$.next(err);\n                }\n            }));\n            if (syncResub) {\n                innerSub.unsubscribe();\n                innerSub = null;\n                syncResub = false;\n                subscribeForRetryWhen();\n            }\n        };\n        subscribeForRetryWhen();\n    });\n}\nexports.retryWhen = retryWhen;\n//# sourceMappingURL=retryWhen.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/sample.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/sample.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sample = void 0;\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction sample(notifier) {\n    return lift_1.operate(function (source, subscriber) {\n        var hasValue = false;\n        var lastValue = null;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            hasValue = true;\n            lastValue = value;\n        }));\n        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {\n            if (hasValue) {\n                hasValue = false;\n                var value = lastValue;\n                lastValue = null;\n                subscriber.next(value);\n            }\n        }, noop_1.noop));\n    });\n}\nexports.sample = sample;\n//# sourceMappingURL=sample.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/sample.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sampleTime = void 0;\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/async.js\");\nvar sample_1 = __webpack_require__(/*! ./sample */ \"./node_modules/rxjs/dist/cjs/internal/operators/sample.js\");\nvar interval_1 = __webpack_require__(/*! ../observable/interval */ \"./node_modules/rxjs/dist/cjs/internal/observable/interval.js\");\nfunction sampleTime(period, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }\n    return sample_1.sample(interval_1.interval(period, scheduler));\n}\nexports.sampleTime = sampleTime;\n//# sourceMappingURL=sampleTime.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/scan.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/scan.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scan = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar scanInternals_1 = __webpack_require__(/*! ./scanInternals */ \"./node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js\");\nfunction scan(accumulator, seed) {\n    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));\n}\nexports.scan = scan;\n//# sourceMappingURL=scan.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/scan.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js":
/*!************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scanInternals = void 0;\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {\n    return function (source, subscriber) {\n        var hasState = hasSeed;\n        var state = seed;\n        var index = 0;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            var i = index++;\n            state = hasState\n                ?\n                    accumulator(state, value, i)\n                :\n                    ((hasState = true), value);\n            emitOnNext && subscriber.next(state);\n        }, emitBeforeComplete &&\n            (function () {\n                hasState && subscriber.next(state);\n                subscriber.complete();\n            })));\n    };\n}\nexports.scanInternals = scanInternals;\n//# sourceMappingURL=scanInternals.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js":
/*!************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sequenceEqual = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nfunction sequenceEqual(compareTo, comparator) {\n    if (comparator === void 0) { comparator = function (a, b) { return a === b; }; }\n    return lift_1.operate(function (source, subscriber) {\n        var aState = createState();\n        var bState = createState();\n        var emit = function (isEqual) {\n            subscriber.next(isEqual);\n            subscriber.complete();\n        };\n        var createSubscriber = function (selfState, otherState) {\n            var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (a) {\n                var buffer = otherState.buffer, complete = otherState.complete;\n                if (buffer.length === 0) {\n                    complete ? emit(false) : selfState.buffer.push(a);\n                }\n                else {\n                    !comparator(a, buffer.shift()) && emit(false);\n                }\n            }, function () {\n                selfState.complete = true;\n                var complete = otherState.complete, buffer = otherState.buffer;\n                complete && emit(buffer.length === 0);\n                sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();\n            });\n            return sequenceEqualSubscriber;\n        };\n        source.subscribe(createSubscriber(aState, bState));\n        innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));\n    });\n}\nexports.sequenceEqual = sequenceEqual;\nfunction createState() {\n    return {\n        buffer: [],\n        complete: false,\n    };\n}\n//# sourceMappingURL=sequenceEqual.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/share.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/share.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.share = void 0;\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/rxjs/dist/cjs/internal/Subscriber.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nfunction share(options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.connector, connector = _a === void 0 ? function () { return new Subject_1.Subject(); } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;\n    return function (wrapperSource) {\n        var connection;\n        var resetConnection;\n        var subject;\n        var refCount = 0;\n        var hasCompleted = false;\n        var hasErrored = false;\n        var cancelReset = function () {\n            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();\n            resetConnection = undefined;\n        };\n        var reset = function () {\n            cancelReset();\n            connection = subject = undefined;\n            hasCompleted = hasErrored = false;\n        };\n        var resetAndUnsubscribe = function () {\n            var conn = connection;\n            reset();\n            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();\n        };\n        return lift_1.operate(function (source, subscriber) {\n            refCount++;\n            if (!hasErrored && !hasCompleted) {\n                cancelReset();\n            }\n            var dest = (subject = subject !== null && subject !== void 0 ? subject : connector());\n            subscriber.add(function () {\n                refCount--;\n                if (refCount === 0 && !hasErrored && !hasCompleted) {\n                    resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n                }\n            });\n            dest.subscribe(subscriber);\n            if (!connection &&\n                refCount > 0) {\n                connection = new Subscriber_1.SafeSubscriber({\n                    next: function (value) { return dest.next(value); },\n                    error: function (err) {\n                        hasErrored = true;\n                        cancelReset();\n                        resetConnection = handleReset(reset, resetOnError, err);\n                        dest.error(err);\n                    },\n                    complete: function () {\n                        hasCompleted = true;\n                        cancelReset();\n                        resetConnection = handleReset(reset, resetOnComplete);\n                        dest.complete();\n                    },\n                });\n                innerFrom_1.innerFrom(source).subscribe(connection);\n            }\n        })(wrapperSource);\n    };\n}\nexports.share = share;\nfunction handleReset(reset, on) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    if (on === true) {\n        reset();\n        return;\n    }\n    if (on === false) {\n        return;\n    }\n    var onSubscriber = new Subscriber_1.SafeSubscriber({\n        next: function () {\n            onSubscriber.unsubscribe();\n            reset();\n        },\n    });\n    return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);\n}\n//# sourceMappingURL=share.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/share.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shareReplay = void 0;\nvar ReplaySubject_1 = __webpack_require__(/*! ../ReplaySubject */ \"./node_modules/rxjs/dist/cjs/internal/ReplaySubject.js\");\nvar share_1 = __webpack_require__(/*! ./share */ \"./node_modules/rxjs/dist/cjs/internal/operators/share.js\");\nfunction shareReplay(configOrBufferSize, windowTime, scheduler) {\n    var _a, _b, _c;\n    var bufferSize;\n    var refCount = false;\n    if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n        (_a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler);\n    }\n    else {\n        bufferSize = (configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity);\n    }\n    return share_1.share({\n        connector: function () { return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler); },\n        resetOnError: true,\n        resetOnComplete: false,\n        resetOnRefCountZero: refCount,\n    });\n}\nexports.shareReplay = shareReplay;\n//# sourceMappingURL=shareReplay.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/single.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/single.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.single = void 0;\nvar EmptyError_1 = __webpack_require__(/*! ../util/EmptyError */ \"./node_modules/rxjs/dist/cjs/internal/util/EmptyError.js\");\nvar SequenceError_1 = __webpack_require__(/*! ../util/SequenceError */ \"./node_modules/rxjs/dist/cjs/internal/util/SequenceError.js\");\nvar NotFoundError_1 = __webpack_require__(/*! ../util/NotFoundError */ \"./node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction single(predicate) {\n    return lift_1.operate(function (source, subscriber) {\n        var hasValue = false;\n        var singleValue;\n        var seenValue = false;\n        var index = 0;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            seenValue = true;\n            if (!predicate || predicate(value, index++, source)) {\n                hasValue && subscriber.error(new SequenceError_1.SequenceError('Too many matching values'));\n                hasValue = true;\n                singleValue = value;\n            }\n        }, function () {\n            if (hasValue) {\n                subscriber.next(singleValue);\n                subscriber.complete();\n            }\n            else {\n                subscriber.error(seenValue ? new NotFoundError_1.NotFoundError('No matching values') : new EmptyError_1.EmptyError());\n            }\n        }));\n    });\n}\nexports.single = single;\n//# sourceMappingURL=single.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/single.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/skip.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/skip.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.skip = void 0;\nvar filter_1 = __webpack_require__(/*! ./filter */ \"./node_modules/rxjs/dist/cjs/internal/operators/filter.js\");\nfunction skip(count) {\n    return filter_1.filter(function (_, index) { return count <= index; });\n}\nexports.skip = skip;\n//# sourceMappingURL=skip.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/skip.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/skipLast.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/skipLast.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.skipLast = void 0;\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction skipLast(skipCount) {\n    return skipCount <= 0\n        ?\n            identity_1.identity\n        : lift_1.operate(function (source, subscriber) {\n            var ring = new Array(skipCount);\n            var seen = 0;\n            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n                var valueIndex = seen++;\n                if (valueIndex < skipCount) {\n                    ring[valueIndex] = value;\n                }\n                else {\n                    var index = valueIndex % skipCount;\n                    var oldValue = ring[index];\n                    ring[index] = value;\n                    subscriber.next(oldValue);\n                }\n            }));\n            return function () {\n                ring = null;\n            };\n        });\n}\nexports.skipLast = skipLast;\n//# sourceMappingURL=skipLast.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/skipLast.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.skipUntil = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nfunction skipUntil(notifier) {\n    return lift_1.operate(function (source, subscriber) {\n        var taking = false;\n        var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {\n            skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();\n            taking = true;\n        }, noop_1.noop);\n        innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return taking && subscriber.next(value); }));\n    });\n}\nexports.skipUntil = skipUntil;\n//# sourceMappingURL=skipUntil.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.skipWhile = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction skipWhile(predicate) {\n    return lift_1.operate(function (source, subscriber) {\n        var taking = false;\n        var index = 0;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return (taking || (taking = !predicate(value, index++))) && subscriber.next(value); }));\n    });\n}\nexports.skipWhile = skipWhile;\n//# sourceMappingURL=skipWhile.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/startWith.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/startWith.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.startWith = void 0;\nvar concat_1 = __webpack_require__(/*! ../observable/concat */ \"./node_modules/rxjs/dist/cjs/internal/observable/concat.js\");\nvar args_1 = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/cjs/internal/util/args.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nfunction startWith() {\n    var values = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        values[_i] = arguments[_i];\n    }\n    var scheduler = args_1.popScheduler(values);\n    return lift_1.operate(function (source, subscriber) {\n        (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);\n    });\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/startWith.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.subscribeOn = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nfunction subscribeOn(scheduler, delay) {\n    if (delay === void 0) { delay = 0; }\n    return lift_1.operate(function (source, subscriber) {\n        subscriber.add(scheduler.schedule(function () { return source.subscribe(subscriber); }, delay));\n    });\n}\nexports.subscribeOn = subscribeOn;\n//# sourceMappingURL=subscribeOn.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/switchAll.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/switchAll.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.switchAll = void 0;\nvar switchMap_1 = __webpack_require__(/*! ./switchMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/switchMap.js\");\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nfunction switchAll() {\n    return switchMap_1.switchMap(identity_1.identity);\n}\nexports.switchAll = switchAll;\n//# sourceMappingURL=switchAll.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/switchAll.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/switchMap.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/switchMap.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.switchMap = void 0;\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction switchMap(project, resultSelector) {\n    return lift_1.operate(function (source, subscriber) {\n        var innerSubscriber = null;\n        var index = 0;\n        var isComplete = false;\n        var checkComplete = function () { return isComplete && !innerSubscriber && subscriber.complete(); };\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();\n            var innerIndex = 0;\n            var outerIndex = index++;\n            innerFrom_1.innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (innerValue) { return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue); }, function () {\n                innerSubscriber = null;\n                checkComplete();\n            })));\n        }, function () {\n            isComplete = true;\n            checkComplete();\n        }));\n    });\n}\nexports.switchMap = switchMap;\n//# sourceMappingURL=switchMap.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/switchMap.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.switchMapTo = void 0;\nvar switchMap_1 = __webpack_require__(/*! ./switchMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/switchMap.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction switchMapTo(innerObservable, resultSelector) {\n    return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function () { return innerObservable; }, resultSelector) : switchMap_1.switchMap(function () { return innerObservable; });\n}\nexports.switchMapTo = switchMapTo;\n//# sourceMappingURL=switchMapTo.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/switchScan.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/switchScan.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.switchScan = void 0;\nvar switchMap_1 = __webpack_require__(/*! ./switchMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/switchMap.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nfunction switchScan(accumulator, seed) {\n    return lift_1.operate(function (source, subscriber) {\n        var state = seed;\n        switchMap_1.switchMap(function (value, index) { return accumulator(state, value, index); }, function (_, innerValue) { return ((state = innerValue), innerValue); })(source).subscribe(subscriber);\n        return function () {\n            state = null;\n        };\n    });\n}\nexports.switchScan = switchScan;\n//# sourceMappingURL=switchScan.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/switchScan.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/take.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/take.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.take = void 0;\nvar empty_1 = __webpack_require__(/*! ../observable/empty */ \"./node_modules/rxjs/dist/cjs/internal/observable/empty.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction take(count) {\n    return count <= 0\n        ?\n            function () { return empty_1.EMPTY; }\n        : lift_1.operate(function (source, subscriber) {\n            var seen = 0;\n            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n                if (++seen <= count) {\n                    subscriber.next(value);\n                    if (count <= seen) {\n                        subscriber.complete();\n                    }\n                }\n            }));\n        });\n}\nexports.take = take;\n//# sourceMappingURL=take.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/take.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/takeLast.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/takeLast.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.takeLast = void 0;\nvar empty_1 = __webpack_require__(/*! ../observable/empty */ \"./node_modules/rxjs/dist/cjs/internal/observable/empty.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction takeLast(count) {\n    return count <= 0\n        ? function () { return empty_1.EMPTY; }\n        : lift_1.operate(function (source, subscriber) {\n            var buffer = [];\n            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n                buffer.push(value);\n                count < buffer.length && buffer.shift();\n            }, function () {\n                var e_1, _a;\n                try {\n                    for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {\n                        var value = buffer_1_1.value;\n                        subscriber.next(value);\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n                subscriber.complete();\n            }, undefined, function () {\n                buffer = null;\n            }));\n        });\n}\nexports.takeLast = takeLast;\n//# sourceMappingURL=takeLast.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/takeLast.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.takeUntil = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nfunction takeUntil(notifier) {\n    return lift_1.operate(function (source, subscriber) {\n        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () { return subscriber.complete(); }, noop_1.noop));\n        !subscriber.closed && source.subscribe(subscriber);\n    });\n}\nexports.takeUntil = takeUntil;\n//# sourceMappingURL=takeUntil.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.takeWhile = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction takeWhile(predicate, inclusive) {\n    if (inclusive === void 0) { inclusive = false; }\n    return lift_1.operate(function (source, subscriber) {\n        var index = 0;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            var result = predicate(value, index++);\n            (result || inclusive) && subscriber.next(value);\n            !result && subscriber.complete();\n        }));\n    });\n}\nexports.takeWhile = takeWhile;\n//# sourceMappingURL=takeWhile.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/tap.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/tap.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tap = void 0;\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nfunction tap(observerOrNext, error, complete) {\n    var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete\n        ?\n            { next: observerOrNext, error: error, complete: complete }\n        : observerOrNext;\n    return tapObserver\n        ? lift_1.operate(function (source, subscriber) {\n            var _a;\n            (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n            var isUnsub = true;\n            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n                var _a;\n                (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);\n                subscriber.next(value);\n            }, function () {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                subscriber.complete();\n            }, function (err) {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);\n                subscriber.error(err);\n            }, function () {\n                var _a, _b;\n                if (isUnsub) {\n                    (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                }\n                (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);\n            }));\n        })\n        :\n            identity_1.identity;\n}\nexports.tap = tap;\n//# sourceMappingURL=tap.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/tap.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/throttle.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/throttle.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.throttle = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nfunction throttle(durationSelector, config) {\n    return lift_1.operate(function (source, subscriber) {\n        var _a = config !== null && config !== void 0 ? config : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;\n        var hasValue = false;\n        var sendValue = null;\n        var throttled = null;\n        var isComplete = false;\n        var endThrottling = function () {\n            throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();\n            throttled = null;\n            if (trailing) {\n                send();\n                isComplete && subscriber.complete();\n            }\n        };\n        var cleanupThrottling = function () {\n            throttled = null;\n            isComplete && subscriber.complete();\n        };\n        var startThrottle = function (value) {\n            return (throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));\n        };\n        var send = function () {\n            if (hasValue) {\n                hasValue = false;\n                var value = sendValue;\n                sendValue = null;\n                subscriber.next(value);\n                !isComplete && startThrottle(value);\n            }\n        };\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            hasValue = true;\n            sendValue = value;\n            !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));\n        }, function () {\n            isComplete = true;\n            !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();\n        }));\n    });\n}\nexports.throttle = throttle;\n//# sourceMappingURL=throttle.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/throttle.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.throttleTime = void 0;\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/async.js\");\nvar throttle_1 = __webpack_require__(/*! ./throttle */ \"./node_modules/rxjs/dist/cjs/internal/operators/throttle.js\");\nvar timer_1 = __webpack_require__(/*! ../observable/timer */ \"./node_modules/rxjs/dist/cjs/internal/observable/timer.js\");\nfunction throttleTime(duration, scheduler, config) {\n    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }\n    var duration$ = timer_1.timer(duration, scheduler);\n    return throttle_1.throttle(function () { return duration$; }, config);\n}\nexports.throttleTime = throttleTime;\n//# sourceMappingURL=throttleTime.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.throwIfEmpty = void 0;\nvar EmptyError_1 = __webpack_require__(/*! ../util/EmptyError */ \"./node_modules/rxjs/dist/cjs/internal/util/EmptyError.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction throwIfEmpty(errorFactory) {\n    if (errorFactory === void 0) { errorFactory = defaultErrorFactory; }\n    return lift_1.operate(function (source, subscriber) {\n        var hasValue = false;\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            hasValue = true;\n            subscriber.next(value);\n        }, function () { return (hasValue ? subscriber.complete() : subscriber.error(errorFactory())); }));\n    });\n}\nexports.throwIfEmpty = throwIfEmpty;\nfunction defaultErrorFactory() {\n    return new EmptyError_1.EmptyError();\n}\n//# sourceMappingURL=throwIfEmpty.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TimeInterval = exports.timeInterval = void 0;\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/async.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction timeInterval(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }\n    return lift_1.operate(function (source, subscriber) {\n        var last = scheduler.now();\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            var now = scheduler.now();\n            var interval = now - last;\n            last = now;\n            subscriber.next(new TimeInterval(value, interval));\n        }));\n    });\n}\nexports.timeInterval = timeInterval;\nvar TimeInterval = (function () {\n    function TimeInterval(value, interval) {\n        this.value = value;\n        this.interval = interval;\n    }\n    return TimeInterval;\n}());\nexports.TimeInterval = TimeInterval;\n//# sourceMappingURL=timeInterval.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/timeout.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/timeout.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.timeout = exports.TimeoutError = void 0;\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/async.js\");\nvar isDate_1 = __webpack_require__(/*! ../util/isDate */ \"./node_modules/rxjs/dist/cjs/internal/util/isDate.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar createErrorClass_1 = __webpack_require__(/*! ../util/createErrorClass */ \"./node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar executeSchedule_1 = __webpack_require__(/*! ../util/executeSchedule */ \"./node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js\");\nexports.TimeoutError = createErrorClass_1.createErrorClass(function (_super) {\n    return function TimeoutErrorImpl(info) {\n        if (info === void 0) { info = null; }\n        _super(this);\n        this.message = 'Timeout has occurred';\n        this.name = 'TimeoutError';\n        this.info = info;\n    };\n});\nfunction timeout(config, schedulerArg) {\n    var _a = (isDate_1.isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config), first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;\n    if (first == null && each == null) {\n        throw new TypeError('No timeout provided.');\n    }\n    return lift_1.operate(function (source, subscriber) {\n        var originalSourceSubscription;\n        var timerSubscription;\n        var lastValue = null;\n        var seen = 0;\n        var startTimer = function (delay) {\n            timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function () {\n                try {\n                    originalSourceSubscription.unsubscribe();\n                    innerFrom_1.innerFrom(_with({\n                        meta: meta,\n                        lastValue: lastValue,\n                        seen: seen,\n                    })).subscribe(subscriber);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                }\n            }, delay);\n        };\n        originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();\n            seen++;\n            subscriber.next((lastValue = value));\n            each > 0 && startTimer(each);\n        }, undefined, undefined, function () {\n            if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {\n                timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();\n            }\n            lastValue = null;\n        }));\n        !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler.now()) : each);\n    });\n}\nexports.timeout = timeout;\nfunction timeoutErrorFactory(info) {\n    throw new exports.TimeoutError(info);\n}\n//# sourceMappingURL=timeout.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/timeout.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.timeoutWith = void 0;\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/async.js\");\nvar isDate_1 = __webpack_require__(/*! ../util/isDate */ \"./node_modules/rxjs/dist/cjs/internal/util/isDate.js\");\nvar timeout_1 = __webpack_require__(/*! ./timeout */ \"./node_modules/rxjs/dist/cjs/internal/operators/timeout.js\");\nfunction timeoutWith(due, withObservable, scheduler) {\n    var first;\n    var each;\n    var _with;\n    scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;\n    if (isDate_1.isValidDate(due)) {\n        first = due;\n    }\n    else if (typeof due === 'number') {\n        each = due;\n    }\n    if (withObservable) {\n        _with = function () { return withObservable; };\n    }\n    else {\n        throw new TypeError('No observable provided to switch to');\n    }\n    if (first == null && each == null) {\n        throw new TypeError('No timeout provided.');\n    }\n    return timeout_1.timeout({\n        first: first,\n        each: each,\n        scheduler: scheduler,\n        with: _with,\n    });\n}\nexports.timeoutWith = timeoutWith;\n//# sourceMappingURL=timeoutWith.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/timestamp.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/timestamp.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.timestamp = void 0;\nvar dateTimestampProvider_1 = __webpack_require__(/*! ../scheduler/dateTimestampProvider */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js\");\nvar map_1 = __webpack_require__(/*! ./map */ \"./node_modules/rxjs/dist/cjs/internal/operators/map.js\");\nfunction timestamp(timestampProvider) {\n    if (timestampProvider === void 0) { timestampProvider = dateTimestampProvider_1.dateTimestampProvider; }\n    return map_1.map(function (value) { return ({ value: value, timestamp: timestampProvider.now() }); });\n}\nexports.timestamp = timestamp;\n//# sourceMappingURL=timestamp.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/timestamp.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/toArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/toArray.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toArray = void 0;\nvar reduce_1 = __webpack_require__(/*! ./reduce */ \"./node_modules/rxjs/dist/cjs/internal/operators/reduce.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar arrReducer = function (arr, value) { return (arr.push(value), arr); };\nfunction toArray() {\n    return lift_1.operate(function (source, subscriber) {\n        reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);\n    });\n}\nexports.toArray = toArray;\n//# sourceMappingURL=toArray.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/toArray.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/window.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/window.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.window = void 0;\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nfunction window(windowBoundaries) {\n    return lift_1.operate(function (source, subscriber) {\n        var windowSubject = new Subject_1.Subject();\n        subscriber.next(windowSubject.asObservable());\n        var errorHandler = function (err) {\n            windowSubject.error(err);\n            subscriber.error(err);\n        };\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value); }, function () {\n            windowSubject.complete();\n            subscriber.complete();\n        }, errorHandler));\n        innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {\n            windowSubject.complete();\n            subscriber.next((windowSubject = new Subject_1.Subject()));\n        }, noop_1.noop, errorHandler));\n        return function () {\n            windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();\n            windowSubject = null;\n        };\n    });\n}\nexports.window = window;\n//# sourceMappingURL=window.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/window.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/windowCount.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/windowCount.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.windowCount = void 0;\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nfunction windowCount(windowSize, startWindowEvery) {\n    if (startWindowEvery === void 0) { startWindowEvery = 0; }\n    var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;\n    return lift_1.operate(function (source, subscriber) {\n        var windows = [new Subject_1.Subject()];\n        var starts = [];\n        var count = 0;\n        subscriber.next(windows[0].asObservable());\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            var e_1, _a;\n            try {\n                for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {\n                    var window_1 = windows_1_1.value;\n                    window_1.next(value);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return)) _a.call(windows_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            var c = count - windowSize + 1;\n            if (c >= 0 && c % startEvery === 0) {\n                windows.shift().complete();\n            }\n            if (++count % startEvery === 0) {\n                var window_2 = new Subject_1.Subject();\n                windows.push(window_2);\n                subscriber.next(window_2.asObservable());\n            }\n        }, function () {\n            while (windows.length > 0) {\n                windows.shift().complete();\n            }\n            subscriber.complete();\n        }, function (err) {\n            while (windows.length > 0) {\n                windows.shift().error(err);\n            }\n            subscriber.error(err);\n        }, function () {\n            starts = null;\n            windows = null;\n        }));\n    });\n}\nexports.windowCount = windowCount;\n//# sourceMappingURL=windowCount.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/windowCount.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/windowTime.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/windowTime.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.windowTime = void 0;\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/async.js\");\nvar Subscription_1 = __webpack_require__(/*! ../Subscription */ \"./node_modules/rxjs/dist/cjs/internal/Subscription.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar arrRemove_1 = __webpack_require__(/*! ../util/arrRemove */ \"./node_modules/rxjs/dist/cjs/internal/util/arrRemove.js\");\nvar args_1 = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/cjs/internal/util/args.js\");\nvar executeSchedule_1 = __webpack_require__(/*! ../util/executeSchedule */ \"./node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js\");\nfunction windowTime(windowTimeSpan) {\n    var _a, _b;\n    var otherArgs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        otherArgs[_i - 1] = arguments[_i];\n    }\n    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;\n    var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;\n    var maxWindowSize = otherArgs[1] || Infinity;\n    return lift_1.operate(function (source, subscriber) {\n        var windowRecords = [];\n        var restartOnClose = false;\n        var closeWindow = function (record) {\n            var window = record.window, subs = record.subs;\n            window.complete();\n            subs.unsubscribe();\n            arrRemove_1.arrRemove(windowRecords, record);\n            restartOnClose && startWindow();\n        };\n        var startWindow = function () {\n            if (windowRecords) {\n                var subs = new Subscription_1.Subscription();\n                subscriber.add(subs);\n                var window_1 = new Subject_1.Subject();\n                var record_1 = {\n                    window: window_1,\n                    subs: subs,\n                    seen: 0,\n                };\n                windowRecords.push(record_1);\n                subscriber.next(window_1.asObservable());\n                executeSchedule_1.executeSchedule(subs, scheduler, function () { return closeWindow(record_1); }, windowTimeSpan);\n            }\n        };\n        if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n            executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);\n        }\n        else {\n            restartOnClose = true;\n        }\n        startWindow();\n        var loop = function (cb) { return windowRecords.slice().forEach(cb); };\n        var terminate = function (cb) {\n            loop(function (_a) {\n                var window = _a.window;\n                return cb(window);\n            });\n            cb(subscriber);\n            subscriber.unsubscribe();\n        };\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            loop(function (record) {\n                record.window.next(value);\n                maxWindowSize <= ++record.seen && closeWindow(record);\n            });\n        }, function () { return terminate(function (consumer) { return consumer.complete(); }); }, function (err) { return terminate(function (consumer) { return consumer.error(err); }); }));\n        return function () {\n            windowRecords = null;\n        };\n    });\n}\nexports.windowTime = windowTime;\n//# sourceMappingURL=windowTime.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/windowTime.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.windowToggle = void 0;\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar Subscription_1 = __webpack_require__(/*! ../Subscription */ \"./node_modules/rxjs/dist/cjs/internal/Subscription.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nvar arrRemove_1 = __webpack_require__(/*! ../util/arrRemove */ \"./node_modules/rxjs/dist/cjs/internal/util/arrRemove.js\");\nfunction windowToggle(openings, closingSelector) {\n    return lift_1.operate(function (source, subscriber) {\n        var windows = [];\n        var handleError = function (err) {\n            while (0 < windows.length) {\n                windows.shift().error(err);\n            }\n            subscriber.error(err);\n        };\n        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (openValue) {\n            var window = new Subject_1.Subject();\n            windows.push(window);\n            var closingSubscription = new Subscription_1.Subscription();\n            var closeWindow = function () {\n                arrRemove_1.arrRemove(windows, window);\n                window.complete();\n                closingSubscription.unsubscribe();\n            };\n            var closingNotifier;\n            try {\n                closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));\n            }\n            catch (err) {\n                handleError(err);\n                return;\n            }\n            subscriber.next(window.asObservable());\n            closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));\n        }, noop_1.noop));\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            var e_1, _a;\n            var windowsCopy = windows.slice();\n            try {\n                for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {\n                    var window_1 = windowsCopy_1_1.value;\n                    window_1.next(value);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return)) _a.call(windowsCopy_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }, function () {\n            while (0 < windows.length) {\n                windows.shift().complete();\n            }\n            subscriber.complete();\n        }, handleError, function () {\n            while (0 < windows.length) {\n                windows.shift().unsubscribe();\n            }\n        }));\n    });\n}\nexports.windowToggle = windowToggle;\n//# sourceMappingURL=windowToggle.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.windowWhen = void 0;\nvar Subject_1 = __webpack_require__(/*! ../Subject */ \"./node_modules/rxjs/dist/cjs/internal/Subject.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nfunction windowWhen(closingSelector) {\n    return lift_1.operate(function (source, subscriber) {\n        var window;\n        var closingSubscriber;\n        var handleError = function (err) {\n            window.error(err);\n            subscriber.error(err);\n        };\n        var openWindow = function () {\n            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();\n            window === null || window === void 0 ? void 0 : window.complete();\n            window = new Subject_1.Subject();\n            subscriber.next(window.asObservable());\n            var closingNotifier;\n            try {\n                closingNotifier = innerFrom_1.innerFrom(closingSelector());\n            }\n            catch (err) {\n                handleError(err);\n                return;\n            }\n            closingNotifier.subscribe((closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError)));\n        };\n        openWindow();\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return window.next(value); }, function () {\n            window.complete();\n            subscriber.complete();\n        }, handleError, function () {\n            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();\n            window = null;\n        }));\n    });\n}\nexports.windowWhen = windowWhen;\n//# sourceMappingURL=windowWhen.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.withLatestFrom = void 0;\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nvar OperatorSubscriber_1 = __webpack_require__(/*! ./OperatorSubscriber */ \"./node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js\");\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar identity_1 = __webpack_require__(/*! ../util/identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nvar noop_1 = __webpack_require__(/*! ../util/noop */ \"./node_modules/rxjs/dist/cjs/internal/util/noop.js\");\nvar args_1 = __webpack_require__(/*! ../util/args */ \"./node_modules/rxjs/dist/cjs/internal/util/args.js\");\nfunction withLatestFrom() {\n    var inputs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        inputs[_i] = arguments[_i];\n    }\n    var project = args_1.popResultSelector(inputs);\n    return lift_1.operate(function (source, subscriber) {\n        var len = inputs.length;\n        var otherValues = new Array(len);\n        var hasValue = inputs.map(function () { return false; });\n        var ready = false;\n        var _loop_1 = function (i) {\n            innerFrom_1.innerFrom(inputs[i]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n                otherValues[i] = value;\n                if (!ready && !hasValue[i]) {\n                    hasValue[i] = true;\n                    (ready = hasValue.every(identity_1.identity)) && (hasValue = null);\n                }\n            }, noop_1.noop));\n        };\n        for (var i = 0; i < len; i++) {\n            _loop_1(i);\n        }\n        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {\n            if (ready) {\n                var values = __spreadArray([value], __read(otherValues));\n                subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);\n            }\n        }));\n    });\n}\nexports.withLatestFrom = withLatestFrom;\n//# sourceMappingURL=withLatestFrom.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/zip.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/zip.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.zip = void 0;\nvar zip_1 = __webpack_require__(/*! ../observable/zip */ \"./node_modules/rxjs/dist/cjs/internal/observable/zip.js\");\nvar lift_1 = __webpack_require__(/*! ../util/lift */ \"./node_modules/rxjs/dist/cjs/internal/util/lift.js\");\nfunction zip() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    return lift_1.operate(function (source, subscriber) {\n        zip_1.zip.apply(void 0, __spreadArray([source], __read(sources))).subscribe(subscriber);\n    });\n}\nexports.zip = zip;\n//# sourceMappingURL=zip.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/zip.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/zipAll.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/zipAll.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.zipAll = void 0;\nvar zip_1 = __webpack_require__(/*! ../observable/zip */ \"./node_modules/rxjs/dist/cjs/internal/observable/zip.js\");\nvar joinAllInternals_1 = __webpack_require__(/*! ./joinAllInternals */ \"./node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js\");\nfunction zipAll(project) {\n    return joinAllInternals_1.joinAllInternals(zip_1.zip, project);\n}\nexports.zipAll = zipAll;\n//# sourceMappingURL=zipAll.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/zipAll.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/operators/zipWith.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/operators/zipWith.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.zipWith = void 0;\nvar zip_1 = __webpack_require__(/*! ./zip */ \"./node_modules/rxjs/dist/cjs/internal/operators/zip.js\");\nfunction zipWith() {\n    var otherInputs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        otherInputs[_i] = arguments[_i];\n    }\n    return zip_1.zip.apply(void 0, __spreadArray([], __read(otherInputs)));\n}\nexports.zipWith = zipWith;\n//# sourceMappingURL=zipWith.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/operators/zipWith.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js":
/*!************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scheduleArray = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nfunction scheduleArray(input, scheduler) {\n    return new Observable_1.Observable(function (subscriber) {\n        var i = 0;\n        return scheduler.schedule(function () {\n            if (i === input.length) {\n                subscriber.complete();\n            }\n            else {\n                subscriber.next(input[i++]);\n                if (!subscriber.closed) {\n                    this.schedule();\n                }\n            }\n        });\n    });\n}\nexports.scheduleArray = scheduleArray;\n//# sourceMappingURL=scheduleArray.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js":
/*!********************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scheduleAsyncIterable = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar executeSchedule_1 = __webpack_require__(/*! ../util/executeSchedule */ \"./node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js\");\nfunction scheduleAsyncIterable(input, scheduler) {\n    if (!input) {\n        throw new Error('Iterable cannot be null');\n    }\n    return new Observable_1.Observable(function (subscriber) {\n        executeSchedule_1.executeSchedule(subscriber, scheduler, function () {\n            var iterator = input[Symbol.asyncIterator]();\n            executeSchedule_1.executeSchedule(subscriber, scheduler, function () {\n                iterator.next().then(function (result) {\n                    if (result.done) {\n                        subscriber.complete();\n                    }\n                    else {\n                        subscriber.next(result.value);\n                    }\n                });\n            }, 0, true);\n        });\n    });\n}\nexports.scheduleAsyncIterable = scheduleAsyncIterable;\n//# sourceMappingURL=scheduleAsyncIterable.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scheduleIterable = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar iterator_1 = __webpack_require__(/*! ../symbol/iterator */ \"./node_modules/rxjs/dist/cjs/internal/symbol/iterator.js\");\nvar isFunction_1 = __webpack_require__(/*! ../util/isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nvar executeSchedule_1 = __webpack_require__(/*! ../util/executeSchedule */ \"./node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js\");\nfunction scheduleIterable(input, scheduler) {\n    return new Observable_1.Observable(function (subscriber) {\n        var iterator;\n        executeSchedule_1.executeSchedule(subscriber, scheduler, function () {\n            iterator = input[iterator_1.iterator]();\n            executeSchedule_1.executeSchedule(subscriber, scheduler, function () {\n                var _a;\n                var value;\n                var done;\n                try {\n                    (_a = iterator.next(), value = _a.value, done = _a.done);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                if (done) {\n                    subscriber.complete();\n                }\n                else {\n                    subscriber.next(value);\n                }\n            }, 0, true);\n        });\n        return function () { return isFunction_1.isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return(); };\n    });\n}\nexports.scheduleIterable = scheduleIterable;\n//# sourceMappingURL=scheduleIterable.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scheduleObservable = void 0;\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar observeOn_1 = __webpack_require__(/*! ../operators/observeOn */ \"./node_modules/rxjs/dist/cjs/internal/operators/observeOn.js\");\nvar subscribeOn_1 = __webpack_require__(/*! ../operators/subscribeOn */ \"./node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js\");\nfunction scheduleObservable(input, scheduler) {\n    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));\n}\nexports.scheduleObservable = scheduleObservable;\n//# sourceMappingURL=scheduleObservable.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.schedulePromise = void 0;\nvar innerFrom_1 = __webpack_require__(/*! ../observable/innerFrom */ \"./node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js\");\nvar observeOn_1 = __webpack_require__(/*! ../operators/observeOn */ \"./node_modules/rxjs/dist/cjs/internal/operators/observeOn.js\");\nvar subscribeOn_1 = __webpack_require__(/*! ../operators/subscribeOn */ \"./node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js\");\nfunction schedulePromise(input, scheduler) {\n    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));\n}\nexports.schedulePromise = schedulePromise;\n//# sourceMappingURL=schedulePromise.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scheduleReadableStreamLike = void 0;\nvar scheduleAsyncIterable_1 = __webpack_require__(/*! ./scheduleAsyncIterable */ \"./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js\");\nvar isReadableStreamLike_1 = __webpack_require__(/*! ../util/isReadableStreamLike */ \"./node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js\");\nfunction scheduleReadableStreamLike(input, scheduler) {\n    return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);\n}\nexports.scheduleReadableStreamLike = scheduleReadableStreamLike;\n//# sourceMappingURL=scheduleReadableStreamLike.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scheduled = void 0;\nvar scheduleObservable_1 = __webpack_require__(/*! ./scheduleObservable */ \"./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js\");\nvar schedulePromise_1 = __webpack_require__(/*! ./schedulePromise */ \"./node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js\");\nvar scheduleArray_1 = __webpack_require__(/*! ./scheduleArray */ \"./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js\");\nvar scheduleIterable_1 = __webpack_require__(/*! ./scheduleIterable */ \"./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js\");\nvar scheduleAsyncIterable_1 = __webpack_require__(/*! ./scheduleAsyncIterable */ \"./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js\");\nvar isInteropObservable_1 = __webpack_require__(/*! ../util/isInteropObservable */ \"./node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js\");\nvar isPromise_1 = __webpack_require__(/*! ../util/isPromise */ \"./node_modules/rxjs/dist/cjs/internal/util/isPromise.js\");\nvar isArrayLike_1 = __webpack_require__(/*! ../util/isArrayLike */ \"./node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js\");\nvar isIterable_1 = __webpack_require__(/*! ../util/isIterable */ \"./node_modules/rxjs/dist/cjs/internal/util/isIterable.js\");\nvar isAsyncIterable_1 = __webpack_require__(/*! ../util/isAsyncIterable */ \"./node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js\");\nvar throwUnobservableError_1 = __webpack_require__(/*! ../util/throwUnobservableError */ \"./node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js\");\nvar isReadableStreamLike_1 = __webpack_require__(/*! ../util/isReadableStreamLike */ \"./node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js\");\nvar scheduleReadableStreamLike_1 = __webpack_require__(/*! ./scheduleReadableStreamLike */ \"./node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js\");\nfunction scheduled(input, scheduler) {\n    if (input != null) {\n        if (isInteropObservable_1.isInteropObservable(input)) {\n            return scheduleObservable_1.scheduleObservable(input, scheduler);\n        }\n        if (isArrayLike_1.isArrayLike(input)) {\n            return scheduleArray_1.scheduleArray(input, scheduler);\n        }\n        if (isPromise_1.isPromise(input)) {\n            return schedulePromise_1.schedulePromise(input, scheduler);\n        }\n        if (isAsyncIterable_1.isAsyncIterable(input)) {\n            return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);\n        }\n        if (isIterable_1.isIterable(input)) {\n            return scheduleIterable_1.scheduleIterable(input, scheduler);\n        }\n        if (isReadableStreamLike_1.isReadableStreamLike(input)) {\n            return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);\n        }\n    }\n    throw throwUnobservableError_1.createInvalidObservableTypeError(input);\n}\nexports.scheduled = scheduled;\n//# sourceMappingURL=scheduled.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/Action.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/Action.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Action = void 0;\nvar Subscription_1 = __webpack_require__(/*! ../Subscription */ \"./node_modules/rxjs/dist/cjs/internal/Subscription.js\");\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        return _super.call(this) || this;\n    }\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/Action.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AnimationFrameAction = void 0;\nvar AsyncAction_1 = __webpack_require__(/*! ./AsyncAction */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js\");\nvar animationFrameProvider_1 = __webpack_require__(/*! ./animationFrameProvider */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js\");\nvar AnimationFrameAction = (function (_super) {\n    __extends(AnimationFrameAction, _super);\n    function AnimationFrameAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function () { return scheduler.flush(undefined); }));\n    };\n    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        var _a;\n        if (delay === void 0) { delay = 0; }\n        if (delay != null ? delay > 0 : this.delay > 0) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        var actions = scheduler.actions;\n        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {\n            animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);\n            scheduler._scheduled = undefined;\n        }\n        return undefined;\n    };\n    return AnimationFrameAction;\n}(AsyncAction_1.AsyncAction));\nexports.AnimationFrameAction = AnimationFrameAction;\n//# sourceMappingURL=AnimationFrameAction.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AnimationFrameScheduler = void 0;\nvar AsyncScheduler_1 = __webpack_require__(/*! ./AsyncScheduler */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js\");\nvar AnimationFrameScheduler = (function (_super) {\n    __extends(AnimationFrameScheduler, _super);\n    function AnimationFrameScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AnimationFrameScheduler.prototype.flush = function (action) {\n        this._active = true;\n        var flushId = this._scheduled;\n        this._scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        action = action || actions.shift();\n        do {\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        } while ((action = actions[0]) && action.id === flushId && actions.shift());\n        this._active = false;\n        if (error) {\n            while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AnimationFrameScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.AnimationFrameScheduler = AnimationFrameScheduler;\n//# sourceMappingURL=AnimationFrameScheduler.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsapAction = void 0;\nvar AsyncAction_1 = __webpack_require__(/*! ./AsyncAction */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js\");\nvar immediateProvider_1 = __webpack_require__(/*! ./immediateProvider */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js\");\nvar AsapAction = (function (_super) {\n    __extends(AsapAction, _super);\n    function AsapAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n    };\n    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        var _a;\n        if (delay === void 0) { delay = 0; }\n        if (delay != null ? delay > 0 : this.delay > 0) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        var actions = scheduler.actions;\n        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {\n            immediateProvider_1.immediateProvider.clearImmediate(id);\n            if (scheduler._scheduled === id) {\n                scheduler._scheduled = undefined;\n            }\n        }\n        return undefined;\n    };\n    return AsapAction;\n}(AsyncAction_1.AsyncAction));\nexports.AsapAction = AsapAction;\n//# sourceMappingURL=AsapAction.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js":
/*!************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsapScheduler = void 0;\nvar AsyncScheduler_1 = __webpack_require__(/*! ./AsyncScheduler */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js\");\nvar AsapScheduler = (function (_super) {\n    __extends(AsapScheduler, _super);\n    function AsapScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AsapScheduler.prototype.flush = function (action) {\n        this._active = true;\n        var flushId = this._scheduled;\n        this._scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        action = action || actions.shift();\n        do {\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        } while ((action = actions[0]) && action.id === flushId && actions.shift());\n        this._active = false;\n        if (error) {\n            while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsapScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.AsapScheduler = AsapScheduler;\n//# sourceMappingURL=AsapScheduler.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsyncAction = void 0;\nvar Action_1 = __webpack_require__(/*! ./Action */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/Action.js\");\nvar intervalProvider_1 = __webpack_require__(/*! ./intervalProvider */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js\");\nvar arrRemove_1 = __webpack_require__(/*! ../util/arrRemove */ \"./node_modules/rxjs/dist/cjs/internal/util/arrRemove.js\");\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        _this.pending = false;\n        return _this;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        var _a;\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        this.state = state;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.pending = true;\n        this.delay = delay;\n        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, _id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (_scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay != null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        if (id != null) {\n            intervalProvider_1.intervalProvider.clearInterval(id);\n        }\n        return undefined;\n    };\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, _delay) {\n        var errored = false;\n        var errorValue;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = e ? e : new Error('Scheduled action threw falsy error');\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            var _a = this, id = _a.id, scheduler = _a.scheduler;\n            var actions = scheduler.actions;\n            this.work = this.state = this.scheduler = null;\n            this.pending = false;\n            arrRemove_1.arrRemove(actions, this);\n            if (id != null) {\n                this.id = this.recycleAsyncId(scheduler, id, null);\n            }\n            this.delay = null;\n            _super.prototype.unsubscribe.call(this);\n        }\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsyncScheduler = void 0;\nvar Scheduler_1 = __webpack_require__(/*! ../Scheduler */ \"./node_modules/rxjs/dist/cjs/internal/Scheduler.js\");\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler_1.Scheduler.now; }\n        var _this = _super.call(this, SchedulerAction, now) || this;\n        _this.actions = [];\n        _this._active = false;\n        return _this;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this._active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this._active = true;\n        do {\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        } while ((action = actions.shift()));\n        this._active = false;\n        if (error) {\n            while ((action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QueueAction = void 0;\nvar AsyncAction_1 = __webpack_require__(/*! ./AsyncAction */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js\");\nvar QueueAction = (function (_super) {\n    __extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        scheduler.flush(this);\n        return 0;\n    };\n    return QueueAction;\n}(AsyncAction_1.AsyncAction));\nexports.QueueAction = QueueAction;\n//# sourceMappingURL=QueueAction.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QueueScheduler = void 0;\nvar AsyncScheduler_1 = __webpack_require__(/*! ./AsyncScheduler */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js\");\nvar QueueScheduler = (function (_super) {\n    __extends(QueueScheduler, _super);\n    function QueueScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return QueueScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.QueueScheduler = QueueScheduler;\n//# sourceMappingURL=QueueScheduler.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VirtualAction = exports.VirtualTimeScheduler = void 0;\nvar AsyncAction_1 = __webpack_require__(/*! ./AsyncAction */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js\");\nvar Subscription_1 = __webpack_require__(/*! ../Subscription */ \"./node_modules/rxjs/dist/cjs/internal/Subscription.js\");\nvar AsyncScheduler_1 = __webpack_require__(/*! ./AsyncScheduler */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js\");\nvar VirtualTimeScheduler = (function (_super) {\n    __extends(VirtualTimeScheduler, _super);\n    function VirtualTimeScheduler(schedulerActionCtor, maxFrames) {\n        if (schedulerActionCtor === void 0) { schedulerActionCtor = VirtualAction; }\n        if (maxFrames === void 0) { maxFrames = Infinity; }\n        var _this = _super.call(this, schedulerActionCtor, function () { return _this.frame; }) || this;\n        _this.maxFrames = maxFrames;\n        _this.frame = 0;\n        _this.index = -1;\n        return _this;\n    }\n    VirtualTimeScheduler.prototype.flush = function () {\n        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;\n        var error;\n        var action;\n        while ((action = actions[0]) && action.delay <= maxFrames) {\n            actions.shift();\n            this.frame = action.delay;\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        }\n        if (error) {\n            while ((action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    VirtualTimeScheduler.frameTimeFactor = 10;\n    return VirtualTimeScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.VirtualTimeScheduler = VirtualTimeScheduler;\nvar VirtualAction = (function (_super) {\n    __extends(VirtualAction, _super);\n    function VirtualAction(scheduler, work, index) {\n        if (index === void 0) { index = (scheduler.index += 1); }\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        _this.index = index;\n        _this.active = true;\n        _this.index = scheduler.index = index;\n        return _this;\n    }\n    VirtualAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (Number.isFinite(delay)) {\n            if (!this.id) {\n                return _super.prototype.schedule.call(this, state, delay);\n            }\n            this.active = false;\n            var action = new VirtualAction(this.scheduler, this.work);\n            this.add(action);\n            return action.schedule(state, delay);\n        }\n        else {\n            return Subscription_1.Subscription.EMPTY;\n        }\n    };\n    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        this.delay = scheduler.frame + delay;\n        var actions = scheduler.actions;\n        actions.push(this);\n        actions.sort(VirtualAction.sortActions);\n        return 1;\n    };\n    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return undefined;\n    };\n    VirtualAction.prototype._execute = function (state, delay) {\n        if (this.active === true) {\n            return _super.prototype._execute.call(this, state, delay);\n        }\n    };\n    VirtualAction.sortActions = function (a, b) {\n        if (a.delay === b.delay) {\n            if (a.index === b.index) {\n                return 0;\n            }\n            else if (a.index > b.index) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        }\n        else if (a.delay > b.delay) {\n            return 1;\n        }\n        else {\n            return -1;\n        }\n    };\n    return VirtualAction;\n}(AsyncAction_1.AsyncAction));\nexports.VirtualAction = VirtualAction;\n//# sourceMappingURL=VirtualTimeScheduler.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.animationFrame = exports.animationFrameScheduler = void 0;\nvar AnimationFrameAction_1 = __webpack_require__(/*! ./AnimationFrameAction */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js\");\nvar AnimationFrameScheduler_1 = __webpack_require__(/*! ./AnimationFrameScheduler */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js\");\nexports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);\nexports.animationFrame = exports.animationFrameScheduler;\n//# sourceMappingURL=animationFrame.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.animationFrameProvider = void 0;\nvar Subscription_1 = __webpack_require__(/*! ../Subscription */ \"./node_modules/rxjs/dist/cjs/internal/Subscription.js\");\nexports.animationFrameProvider = {\n    schedule: function (callback) {\n        var request = requestAnimationFrame;\n        var cancel = cancelAnimationFrame;\n        var delegate = exports.animationFrameProvider.delegate;\n        if (delegate) {\n            request = delegate.requestAnimationFrame;\n            cancel = delegate.cancelAnimationFrame;\n        }\n        var handle = request(function (timestamp) {\n            cancel = undefined;\n            callback(timestamp);\n        });\n        return new Subscription_1.Subscription(function () { return cancel === null || cancel === void 0 ? void 0 : cancel(handle); });\n    },\n    requestAnimationFrame: function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var delegate = exports.animationFrameProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));\n    },\n    cancelAnimationFrame: function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var delegate = exports.animationFrameProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=animationFrameProvider.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/asap.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/asap.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.asap = exports.asapScheduler = void 0;\nvar AsapAction_1 = __webpack_require__(/*! ./AsapAction */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js\");\nvar AsapScheduler_1 = __webpack_require__(/*! ./AsapScheduler */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js\");\nexports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);\nexports.asap = exports.asapScheduler;\n//# sourceMappingURL=asap.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/asap.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/async.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/async.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.async = exports.asyncScheduler = void 0;\nvar AsyncAction_1 = __webpack_require__(/*! ./AsyncAction */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js\");\nvar AsyncScheduler_1 = __webpack_require__(/*! ./AsyncScheduler */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js\");\nexports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\nexports.async = exports.asyncScheduler;\n//# sourceMappingURL=async.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/async.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js":
/*!********************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dateTimestampProvider = void 0;\nexports.dateTimestampProvider = {\n    now: function () {\n        return (exports.dateTimestampProvider.delegate || Date).now();\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=dateTimestampProvider.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js":
/*!****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.immediateProvider = void 0;\nvar Immediate_1 = __webpack_require__(/*! ../util/Immediate */ \"./node_modules/rxjs/dist/cjs/internal/util/Immediate.js\");\nvar setImmediate = Immediate_1.Immediate.setImmediate, clearImmediate = Immediate_1.Immediate.clearImmediate;\nexports.immediateProvider = {\n    setImmediate: function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var delegate = exports.immediateProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));\n    },\n    clearImmediate: function (handle) {\n        var delegate = exports.immediateProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=immediateProvider.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js":
/*!***************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.intervalProvider = void 0;\nexports.intervalProvider = {\n    setInterval: function (handler, timeout) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var delegate = exports.intervalProvider.delegate;\n        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {\n            return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));\n        }\n        return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));\n    },\n    clearInterval: function (handle) {\n        var delegate = exports.intervalProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=intervalProvider.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.performanceTimestampProvider = void 0;\nexports.performanceTimestampProvider = {\n    now: function () {\n        return (exports.performanceTimestampProvider.delegate || performance).now();\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=performanceTimestampProvider.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/queue.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/queue.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.queue = exports.queueScheduler = void 0;\nvar QueueAction_1 = __webpack_require__(/*! ./QueueAction */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js\");\nvar QueueScheduler_1 = __webpack_require__(/*! ./QueueScheduler */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js\");\nexports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\nexports.queue = exports.queueScheduler;\n//# sourceMappingURL=queue.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/queue.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.timeoutProvider = void 0;\nexports.timeoutProvider = {\n    setTimeout: function (handler, timeout) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var delegate = exports.timeoutProvider.delegate;\n        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {\n            return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));\n        }\n        return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));\n    },\n    clearTimeout: function (handle) {\n        var delegate = exports.timeoutProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=timeoutProvider.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/symbol/iterator.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/symbol/iterator.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.iterator = exports.getSymbolIterator = void 0;\nfunction getSymbolIterator() {\n    if (typeof Symbol !== 'function' || !Symbol.iterator) {\n        return '@@iterator';\n    }\n    return Symbol.iterator;\n}\nexports.getSymbolIterator = getSymbolIterator;\nexports.iterator = getSymbolIterator();\n//# sourceMappingURL=iterator.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/symbol/iterator.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/symbol/observable.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/symbol/observable.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.observable = void 0;\nexports.observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();\n//# sourceMappingURL=observable.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/symbol/observable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/types.js":
/*!******************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/types.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/types.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ArgumentOutOfRangeError = void 0;\nvar createErrorClass_1 = __webpack_require__(/*! ./createErrorClass */ \"./node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js\");\nexports.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function (_super) {\n    return function ArgumentOutOfRangeErrorImpl() {\n        _super(this);\n        this.name = 'ArgumentOutOfRangeError';\n        this.message = 'argument out of range';\n    };\n});\n//# sourceMappingURL=ArgumentOutOfRangeError.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/EmptyError.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/EmptyError.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EmptyError = void 0;\nvar createErrorClass_1 = __webpack_require__(/*! ./createErrorClass */ \"./node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js\");\nexports.EmptyError = createErrorClass_1.createErrorClass(function (_super) { return function EmptyErrorImpl() {\n    _super(this);\n    this.name = 'EmptyError';\n    this.message = 'no elements in sequence';\n}; });\n//# sourceMappingURL=EmptyError.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/EmptyError.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/Immediate.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/Immediate.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TestTools = exports.Immediate = void 0;\nvar nextHandle = 1;\nvar resolved;\nvar activeHandles = {};\nfunction findAndClearHandle(handle) {\n    if (handle in activeHandles) {\n        delete activeHandles[handle];\n        return true;\n    }\n    return false;\n}\nexports.Immediate = {\n    setImmediate: function (cb) {\n        var handle = nextHandle++;\n        activeHandles[handle] = true;\n        if (!resolved) {\n            resolved = Promise.resolve();\n        }\n        resolved.then(function () { return findAndClearHandle(handle) && cb(); });\n        return handle;\n    },\n    clearImmediate: function (handle) {\n        findAndClearHandle(handle);\n    },\n};\nexports.TestTools = {\n    pending: function () {\n        return Object.keys(activeHandles).length;\n    }\n};\n//# sourceMappingURL=Immediate.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/Immediate.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NotFoundError = void 0;\nvar createErrorClass_1 = __webpack_require__(/*! ./createErrorClass */ \"./node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js\");\nexports.NotFoundError = createErrorClass_1.createErrorClass(function (_super) {\n    return function NotFoundErrorImpl(message) {\n        _super(this);\n        this.name = 'NotFoundError';\n        this.message = message;\n    };\n});\n//# sourceMappingURL=NotFoundError.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ObjectUnsubscribedError = void 0;\nvar createErrorClass_1 = __webpack_require__(/*! ./createErrorClass */ \"./node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js\");\nexports.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function (_super) {\n    return function ObjectUnsubscribedErrorImpl() {\n        _super(this);\n        this.name = 'ObjectUnsubscribedError';\n        this.message = 'object unsubscribed';\n    };\n});\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/SequenceError.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/SequenceError.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SequenceError = void 0;\nvar createErrorClass_1 = __webpack_require__(/*! ./createErrorClass */ \"./node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js\");\nexports.SequenceError = createErrorClass_1.createErrorClass(function (_super) {\n    return function SequenceErrorImpl(message) {\n        _super(this);\n        this.name = 'SequenceError';\n        this.message = message;\n    };\n});\n//# sourceMappingURL=SequenceError.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/SequenceError.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UnsubscriptionError = void 0;\nvar createErrorClass_1 = __webpack_require__(/*! ./createErrorClass */ \"./node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js\");\nexports.UnsubscriptionError = createErrorClass_1.createErrorClass(function (_super) {\n    return function UnsubscriptionErrorImpl(errors) {\n        _super(this);\n        this.message = errors\n            ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return i + 1 + \") \" + err.toString(); }).join('\\n  ')\n            : '';\n        this.name = 'UnsubscriptionError';\n        this.errors = errors;\n    };\n});\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/args.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/args.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.popNumber = exports.popScheduler = exports.popResultSelector = void 0;\nvar isFunction_1 = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nvar isScheduler_1 = __webpack_require__(/*! ./isScheduler */ \"./node_modules/rxjs/dist/cjs/internal/util/isScheduler.js\");\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nfunction popResultSelector(args) {\n    return isFunction_1.isFunction(last(args)) ? args.pop() : undefined;\n}\nexports.popResultSelector = popResultSelector;\nfunction popScheduler(args) {\n    return isScheduler_1.isScheduler(last(args)) ? args.pop() : undefined;\n}\nexports.popScheduler = popScheduler;\nfunction popNumber(args, defaultValue) {\n    return typeof last(args) === 'number' ? args.pop() : defaultValue;\n}\nexports.popNumber = popNumber;\n//# sourceMappingURL=args.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/args.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.argsArgArrayOrObject = void 0;\nvar isArray = Array.isArray;\nvar getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;\nfunction argsArgArrayOrObject(args) {\n    if (args.length === 1) {\n        var first_1 = args[0];\n        if (isArray(first_1)) {\n            return { args: first_1, keys: null };\n        }\n        if (isPOJO(first_1)) {\n            var keys = getKeys(first_1);\n            return {\n                args: keys.map(function (key) { return first_1[key]; }),\n                keys: keys,\n            };\n        }\n    }\n    return { args: args, keys: null };\n}\nexports.argsArgArrayOrObject = argsArgArrayOrObject;\nfunction isPOJO(obj) {\n    return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n//# sourceMappingURL=argsArgArrayOrObject.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.argsOrArgArray = void 0;\nvar isArray = Array.isArray;\nfunction argsOrArgArray(args) {\n    return args.length === 1 && isArray(args[0]) ? args[0] : args;\n}\nexports.argsOrArgArray = argsOrArgArray;\n//# sourceMappingURL=argsOrArgArray.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/arrRemove.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/arrRemove.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.arrRemove = void 0;\nfunction arrRemove(arr, item) {\n    if (arr) {\n        var index = arr.indexOf(item);\n        0 <= index && arr.splice(index, 1);\n    }\n}\nexports.arrRemove = arrRemove;\n//# sourceMappingURL=arrRemove.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/arrRemove.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createErrorClass = void 0;\nfunction createErrorClass(createImpl) {\n    var _super = function (instance) {\n        Error.call(instance);\n        instance.stack = new Error().stack;\n    };\n    var ctorFunc = createImpl(_super);\n    ctorFunc.prototype = Object.create(Error.prototype);\n    ctorFunc.prototype.constructor = ctorFunc;\n    return ctorFunc;\n}\nexports.createErrorClass = createErrorClass;\n//# sourceMappingURL=createErrorClass.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/createObject.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/createObject.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createObject = void 0;\nfunction createObject(keys, values) {\n    return keys.reduce(function (result, key, i) { return ((result[key] = values[i]), result); }, {});\n}\nexports.createObject = createObject;\n//# sourceMappingURL=createObject.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/createObject.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/errorContext.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/errorContext.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.captureError = exports.errorContext = void 0;\nvar config_1 = __webpack_require__(/*! ../config */ \"./node_modules/rxjs/dist/cjs/internal/config.js\");\nvar context = null;\nfunction errorContext(cb) {\n    if (config_1.config.useDeprecatedSynchronousErrorHandling) {\n        var isRoot = !context;\n        if (isRoot) {\n            context = { errorThrown: false, error: null };\n        }\n        cb();\n        if (isRoot) {\n            var _a = context, errorThrown = _a.errorThrown, error = _a.error;\n            context = null;\n            if (errorThrown) {\n                throw error;\n            }\n        }\n    }\n    else {\n        cb();\n    }\n}\nexports.errorContext = errorContext;\nfunction captureError(err) {\n    if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {\n        context.errorThrown = true;\n        context.error = err;\n    }\n}\nexports.captureError = captureError;\n//# sourceMappingURL=errorContext.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/errorContext.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.executeSchedule = void 0;\nfunction executeSchedule(parentSubscription, scheduler, work, delay, repeat) {\n    if (delay === void 0) { delay = 0; }\n    if (repeat === void 0) { repeat = false; }\n    var scheduleSubscription = scheduler.schedule(function () {\n        work();\n        if (repeat) {\n            parentSubscription.add(this.schedule(null, delay));\n        }\n        else {\n            this.unsubscribe();\n        }\n    }, delay);\n    parentSubscription.add(scheduleSubscription);\n    if (!repeat) {\n        return scheduleSubscription;\n    }\n}\nexports.executeSchedule = executeSchedule;\n//# sourceMappingURL=executeSchedule.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/identity.js":
/*!**************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/identity.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.identity = void 0;\nfunction identity(x) {\n    return x;\n}\nexports.identity = identity;\n//# sourceMappingURL=identity.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/identity.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isArrayLike = void 0;\nexports.isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });\n//# sourceMappingURL=isArrayLike.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isAsyncIterable = void 0;\nvar isFunction_1 = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction isAsyncIterable(obj) {\n    return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);\n}\nexports.isAsyncIterable = isAsyncIterable;\n//# sourceMappingURL=isAsyncIterable.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/isDate.js":
/*!************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/isDate.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isValidDate = void 0;\nfunction isValidDate(value) {\n    return value instanceof Date && !isNaN(value);\n}\nexports.isValidDate = isValidDate;\n//# sourceMappingURL=isDate.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/isDate.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/isFunction.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/isFunction.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isFunction = void 0;\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/isFunction.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isInteropObservable = void 0;\nvar observable_1 = __webpack_require__(/*! ../symbol/observable */ \"./node_modules/rxjs/dist/cjs/internal/symbol/observable.js\");\nvar isFunction_1 = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction isInteropObservable(input) {\n    return isFunction_1.isFunction(input[observable_1.observable]);\n}\nexports.isInteropObservable = isInteropObservable;\n//# sourceMappingURL=isInteropObservable.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/isIterable.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/isIterable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isIterable = void 0;\nvar iterator_1 = __webpack_require__(/*! ../symbol/iterator */ \"./node_modules/rxjs/dist/cjs/internal/symbol/iterator.js\");\nvar isFunction_1 = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction isIterable(input) {\n    return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);\n}\nexports.isIterable = isIterable;\n//# sourceMappingURL=isIterable.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/isIterable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/isObservable.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/isObservable.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isObservable = void 0;\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/rxjs/dist/cjs/internal/Observable.js\");\nvar isFunction_1 = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction isObservable(obj) {\n    return !!obj && (obj instanceof Observable_1.Observable || (isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe)));\n}\nexports.isObservable = isObservable;\n//# sourceMappingURL=isObservable.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/isObservable.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/isPromise.js":
/*!***************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/isPromise.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isPromise = void 0;\nvar isFunction_1 = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction isPromise(value) {\n    return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);\n}\nexports.isPromise = isPromise;\n//# sourceMappingURL=isPromise.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/isPromise.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isReadableStreamLike = exports.readableStreamLikeToAsyncGenerator = void 0;\nvar isFunction_1 = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction readableStreamLikeToAsyncGenerator(readableStream) {\n    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {\n        var reader, _a, value, done;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    reader = readableStream.getReader();\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                case 2:\n                    if (false) {}\n                    return [4, __await(reader.read())];\n                case 3:\n                    _a = _b.sent(), value = _a.value, done = _a.done;\n                    if (!done) return [3, 5];\n                    return [4, __await(void 0)];\n                case 4: return [2, _b.sent()];\n                case 5: return [4, __await(value)];\n                case 6: return [4, _b.sent()];\n                case 7:\n                    _b.sent();\n                    return [3, 2];\n                case 8: return [3, 10];\n                case 9:\n                    reader.releaseLock();\n                    return [7];\n                case 10: return [2];\n            }\n        });\n    });\n}\nexports.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;\nfunction isReadableStreamLike(obj) {\n    return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);\n}\nexports.isReadableStreamLike = isReadableStreamLike;\n//# sourceMappingURL=isReadableStreamLike.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/isScheduler.js":
/*!*****************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/isScheduler.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isScheduler = void 0;\nvar isFunction_1 = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction isScheduler(value) {\n    return value && isFunction_1.isFunction(value.schedule);\n}\nexports.isScheduler = isScheduler;\n//# sourceMappingURL=isScheduler.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/isScheduler.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/lift.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/lift.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.operate = exports.hasLift = void 0;\nvar isFunction_1 = __webpack_require__(/*! ./isFunction */ \"./node_modules/rxjs/dist/cjs/internal/util/isFunction.js\");\nfunction hasLift(source) {\n    return isFunction_1.isFunction(source === null || source === void 0 ? void 0 : source.lift);\n}\nexports.hasLift = hasLift;\nfunction operate(init) {\n    return function (source) {\n        if (hasLift(source)) {\n            return source.lift(function (liftedSource) {\n                try {\n                    return init(liftedSource, this);\n                }\n                catch (err) {\n                    this.error(err);\n                }\n            });\n        }\n        throw new TypeError('Unable to lift unknown Observable type');\n    };\n}\nexports.operate = operate;\n//# sourceMappingURL=lift.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/lift.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapOneOrManyArgs = void 0;\nvar map_1 = __webpack_require__(/*! ../operators/map */ \"./node_modules/rxjs/dist/cjs/internal/operators/map.js\");\nvar isArray = Array.isArray;\nfunction callOrApply(fn, args) {\n    return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);\n}\nfunction mapOneOrManyArgs(fn) {\n    return map_1.map(function (args) { return callOrApply(fn, args); });\n}\nexports.mapOneOrManyArgs = mapOneOrManyArgs;\n//# sourceMappingURL=mapOneOrManyArgs.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/noop.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/noop.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.noop = void 0;\nfunction noop() { }\nexports.noop = noop;\n//# sourceMappingURL=noop.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/noop.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/not.js":
/*!*********************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/not.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.not = void 0;\nfunction not(pred, thisArg) {\n    return function (value, index) { return !pred.call(thisArg, value, index); };\n}\nexports.not = not;\n//# sourceMappingURL=not.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/not.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/pipe.js":
/*!**********************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/pipe.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pipeFromArray = exports.pipe = void 0;\nvar identity_1 = __webpack_require__(/*! ./identity */ \"./node_modules/rxjs/dist/cjs/internal/util/identity.js\");\nfunction pipe() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    return pipeFromArray(fns);\n}\nexports.pipe = pipe;\nfunction pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return identity_1.identity;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n    };\n}\nexports.pipeFromArray = pipeFromArray;\n//# sourceMappingURL=pipe.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/pipe.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.reportUnhandledError = void 0;\nvar config_1 = __webpack_require__(/*! ../config */ \"./node_modules/rxjs/dist/cjs/internal/config.js\");\nvar timeoutProvider_1 = __webpack_require__(/*! ../scheduler/timeoutProvider */ \"./node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js\");\nfunction reportUnhandledError(err) {\n    timeoutProvider_1.timeoutProvider.setTimeout(function () {\n        var onUnhandledError = config_1.config.onUnhandledError;\n        if (onUnhandledError) {\n            onUnhandledError(err);\n        }\n        else {\n            throw err;\n        }\n    });\n}\nexports.reportUnhandledError = reportUnhandledError;\n//# sourceMappingURL=reportUnhandledError.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js":
/*!****************************************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createInvalidObservableTypeError = void 0;\nfunction createInvalidObservableTypeError(input) {\n    return new TypeError(\"You provided \" + (input !== null && typeof input === 'object' ? 'an invalid object' : \"'\" + input + \"'\") + \" where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.\");\n}\nexports.createInvalidObservableTypeError = createInvalidObservableTypeError;\n//# sourceMappingURL=throwUnobservableError.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js?");

/***/ }),

/***/ "./node_modules/rxjs/dist/cjs/operators/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/rxjs/dist/cjs/operators/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mergeAll = exports.merge = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.concat = exports.combineLatestWith = exports.combineLatest = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = void 0;\nexports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.race = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.partition = exports.pairwise = exports.onErrorResumeNext = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = void 0;\nexports.zipWith = exports.zipAll = exports.zip = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = void 0;\nvar audit_1 = __webpack_require__(/*! ../internal/operators/audit */ \"./node_modules/rxjs/dist/cjs/internal/operators/audit.js\");\nObject.defineProperty(exports, \"audit\", ({ enumerable: true, get: function () { return audit_1.audit; } }));\nvar auditTime_1 = __webpack_require__(/*! ../internal/operators/auditTime */ \"./node_modules/rxjs/dist/cjs/internal/operators/auditTime.js\");\nObject.defineProperty(exports, \"auditTime\", ({ enumerable: true, get: function () { return auditTime_1.auditTime; } }));\nvar buffer_1 = __webpack_require__(/*! ../internal/operators/buffer */ \"./node_modules/rxjs/dist/cjs/internal/operators/buffer.js\");\nObject.defineProperty(exports, \"buffer\", ({ enumerable: true, get: function () { return buffer_1.buffer; } }));\nvar bufferCount_1 = __webpack_require__(/*! ../internal/operators/bufferCount */ \"./node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js\");\nObject.defineProperty(exports, \"bufferCount\", ({ enumerable: true, get: function () { return bufferCount_1.bufferCount; } }));\nvar bufferTime_1 = __webpack_require__(/*! ../internal/operators/bufferTime */ \"./node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js\");\nObject.defineProperty(exports, \"bufferTime\", ({ enumerable: true, get: function () { return bufferTime_1.bufferTime; } }));\nvar bufferToggle_1 = __webpack_require__(/*! ../internal/operators/bufferToggle */ \"./node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js\");\nObject.defineProperty(exports, \"bufferToggle\", ({ enumerable: true, get: function () { return bufferToggle_1.bufferToggle; } }));\nvar bufferWhen_1 = __webpack_require__(/*! ../internal/operators/bufferWhen */ \"./node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js\");\nObject.defineProperty(exports, \"bufferWhen\", ({ enumerable: true, get: function () { return bufferWhen_1.bufferWhen; } }));\nvar catchError_1 = __webpack_require__(/*! ../internal/operators/catchError */ \"./node_modules/rxjs/dist/cjs/internal/operators/catchError.js\");\nObject.defineProperty(exports, \"catchError\", ({ enumerable: true, get: function () { return catchError_1.catchError; } }));\nvar combineAll_1 = __webpack_require__(/*! ../internal/operators/combineAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/combineAll.js\");\nObject.defineProperty(exports, \"combineAll\", ({ enumerable: true, get: function () { return combineAll_1.combineAll; } }));\nvar combineLatestAll_1 = __webpack_require__(/*! ../internal/operators/combineLatestAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js\");\nObject.defineProperty(exports, \"combineLatestAll\", ({ enumerable: true, get: function () { return combineLatestAll_1.combineLatestAll; } }));\nvar combineLatest_1 = __webpack_require__(/*! ../internal/operators/combineLatest */ \"./node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js\");\nObject.defineProperty(exports, \"combineLatest\", ({ enumerable: true, get: function () { return combineLatest_1.combineLatest; } }));\nvar combineLatestWith_1 = __webpack_require__(/*! ../internal/operators/combineLatestWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js\");\nObject.defineProperty(exports, \"combineLatestWith\", ({ enumerable: true, get: function () { return combineLatestWith_1.combineLatestWith; } }));\nvar concat_1 = __webpack_require__(/*! ../internal/operators/concat */ \"./node_modules/rxjs/dist/cjs/internal/operators/concat.js\");\nObject.defineProperty(exports, \"concat\", ({ enumerable: true, get: function () { return concat_1.concat; } }));\nvar concatAll_1 = __webpack_require__(/*! ../internal/operators/concatAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/concatAll.js\");\nObject.defineProperty(exports, \"concatAll\", ({ enumerable: true, get: function () { return concatAll_1.concatAll; } }));\nvar concatMap_1 = __webpack_require__(/*! ../internal/operators/concatMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/concatMap.js\");\nObject.defineProperty(exports, \"concatMap\", ({ enumerable: true, get: function () { return concatMap_1.concatMap; } }));\nvar concatMapTo_1 = __webpack_require__(/*! ../internal/operators/concatMapTo */ \"./node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js\");\nObject.defineProperty(exports, \"concatMapTo\", ({ enumerable: true, get: function () { return concatMapTo_1.concatMapTo; } }));\nvar concatWith_1 = __webpack_require__(/*! ../internal/operators/concatWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/concatWith.js\");\nObject.defineProperty(exports, \"concatWith\", ({ enumerable: true, get: function () { return concatWith_1.concatWith; } }));\nvar connect_1 = __webpack_require__(/*! ../internal/operators/connect */ \"./node_modules/rxjs/dist/cjs/internal/operators/connect.js\");\nObject.defineProperty(exports, \"connect\", ({ enumerable: true, get: function () { return connect_1.connect; } }));\nvar count_1 = __webpack_require__(/*! ../internal/operators/count */ \"./node_modules/rxjs/dist/cjs/internal/operators/count.js\");\nObject.defineProperty(exports, \"count\", ({ enumerable: true, get: function () { return count_1.count; } }));\nvar debounce_1 = __webpack_require__(/*! ../internal/operators/debounce */ \"./node_modules/rxjs/dist/cjs/internal/operators/debounce.js\");\nObject.defineProperty(exports, \"debounce\", ({ enumerable: true, get: function () { return debounce_1.debounce; } }));\nvar debounceTime_1 = __webpack_require__(/*! ../internal/operators/debounceTime */ \"./node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js\");\nObject.defineProperty(exports, \"debounceTime\", ({ enumerable: true, get: function () { return debounceTime_1.debounceTime; } }));\nvar defaultIfEmpty_1 = __webpack_require__(/*! ../internal/operators/defaultIfEmpty */ \"./node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js\");\nObject.defineProperty(exports, \"defaultIfEmpty\", ({ enumerable: true, get: function () { return defaultIfEmpty_1.defaultIfEmpty; } }));\nvar delay_1 = __webpack_require__(/*! ../internal/operators/delay */ \"./node_modules/rxjs/dist/cjs/internal/operators/delay.js\");\nObject.defineProperty(exports, \"delay\", ({ enumerable: true, get: function () { return delay_1.delay; } }));\nvar delayWhen_1 = __webpack_require__(/*! ../internal/operators/delayWhen */ \"./node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js\");\nObject.defineProperty(exports, \"delayWhen\", ({ enumerable: true, get: function () { return delayWhen_1.delayWhen; } }));\nvar dematerialize_1 = __webpack_require__(/*! ../internal/operators/dematerialize */ \"./node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js\");\nObject.defineProperty(exports, \"dematerialize\", ({ enumerable: true, get: function () { return dematerialize_1.dematerialize; } }));\nvar distinct_1 = __webpack_require__(/*! ../internal/operators/distinct */ \"./node_modules/rxjs/dist/cjs/internal/operators/distinct.js\");\nObject.defineProperty(exports, \"distinct\", ({ enumerable: true, get: function () { return distinct_1.distinct; } }));\nvar distinctUntilChanged_1 = __webpack_require__(/*! ../internal/operators/distinctUntilChanged */ \"./node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js\");\nObject.defineProperty(exports, \"distinctUntilChanged\", ({ enumerable: true, get: function () { return distinctUntilChanged_1.distinctUntilChanged; } }));\nvar distinctUntilKeyChanged_1 = __webpack_require__(/*! ../internal/operators/distinctUntilKeyChanged */ \"./node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js\");\nObject.defineProperty(exports, \"distinctUntilKeyChanged\", ({ enumerable: true, get: function () { return distinctUntilKeyChanged_1.distinctUntilKeyChanged; } }));\nvar elementAt_1 = __webpack_require__(/*! ../internal/operators/elementAt */ \"./node_modules/rxjs/dist/cjs/internal/operators/elementAt.js\");\nObject.defineProperty(exports, \"elementAt\", ({ enumerable: true, get: function () { return elementAt_1.elementAt; } }));\nvar endWith_1 = __webpack_require__(/*! ../internal/operators/endWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/endWith.js\");\nObject.defineProperty(exports, \"endWith\", ({ enumerable: true, get: function () { return endWith_1.endWith; } }));\nvar every_1 = __webpack_require__(/*! ../internal/operators/every */ \"./node_modules/rxjs/dist/cjs/internal/operators/every.js\");\nObject.defineProperty(exports, \"every\", ({ enumerable: true, get: function () { return every_1.every; } }));\nvar exhaust_1 = __webpack_require__(/*! ../internal/operators/exhaust */ \"./node_modules/rxjs/dist/cjs/internal/operators/exhaust.js\");\nObject.defineProperty(exports, \"exhaust\", ({ enumerable: true, get: function () { return exhaust_1.exhaust; } }));\nvar exhaustAll_1 = __webpack_require__(/*! ../internal/operators/exhaustAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js\");\nObject.defineProperty(exports, \"exhaustAll\", ({ enumerable: true, get: function () { return exhaustAll_1.exhaustAll; } }));\nvar exhaustMap_1 = __webpack_require__(/*! ../internal/operators/exhaustMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js\");\nObject.defineProperty(exports, \"exhaustMap\", ({ enumerable: true, get: function () { return exhaustMap_1.exhaustMap; } }));\nvar expand_1 = __webpack_require__(/*! ../internal/operators/expand */ \"./node_modules/rxjs/dist/cjs/internal/operators/expand.js\");\nObject.defineProperty(exports, \"expand\", ({ enumerable: true, get: function () { return expand_1.expand; } }));\nvar filter_1 = __webpack_require__(/*! ../internal/operators/filter */ \"./node_modules/rxjs/dist/cjs/internal/operators/filter.js\");\nObject.defineProperty(exports, \"filter\", ({ enumerable: true, get: function () { return filter_1.filter; } }));\nvar finalize_1 = __webpack_require__(/*! ../internal/operators/finalize */ \"./node_modules/rxjs/dist/cjs/internal/operators/finalize.js\");\nObject.defineProperty(exports, \"finalize\", ({ enumerable: true, get: function () { return finalize_1.finalize; } }));\nvar find_1 = __webpack_require__(/*! ../internal/operators/find */ \"./node_modules/rxjs/dist/cjs/internal/operators/find.js\");\nObject.defineProperty(exports, \"find\", ({ enumerable: true, get: function () { return find_1.find; } }));\nvar findIndex_1 = __webpack_require__(/*! ../internal/operators/findIndex */ \"./node_modules/rxjs/dist/cjs/internal/operators/findIndex.js\");\nObject.defineProperty(exports, \"findIndex\", ({ enumerable: true, get: function () { return findIndex_1.findIndex; } }));\nvar first_1 = __webpack_require__(/*! ../internal/operators/first */ \"./node_modules/rxjs/dist/cjs/internal/operators/first.js\");\nObject.defineProperty(exports, \"first\", ({ enumerable: true, get: function () { return first_1.first; } }));\nvar groupBy_1 = __webpack_require__(/*! ../internal/operators/groupBy */ \"./node_modules/rxjs/dist/cjs/internal/operators/groupBy.js\");\nObject.defineProperty(exports, \"groupBy\", ({ enumerable: true, get: function () { return groupBy_1.groupBy; } }));\nvar ignoreElements_1 = __webpack_require__(/*! ../internal/operators/ignoreElements */ \"./node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js\");\nObject.defineProperty(exports, \"ignoreElements\", ({ enumerable: true, get: function () { return ignoreElements_1.ignoreElements; } }));\nvar isEmpty_1 = __webpack_require__(/*! ../internal/operators/isEmpty */ \"./node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js\");\nObject.defineProperty(exports, \"isEmpty\", ({ enumerable: true, get: function () { return isEmpty_1.isEmpty; } }));\nvar last_1 = __webpack_require__(/*! ../internal/operators/last */ \"./node_modules/rxjs/dist/cjs/internal/operators/last.js\");\nObject.defineProperty(exports, \"last\", ({ enumerable: true, get: function () { return last_1.last; } }));\nvar map_1 = __webpack_require__(/*! ../internal/operators/map */ \"./node_modules/rxjs/dist/cjs/internal/operators/map.js\");\nObject.defineProperty(exports, \"map\", ({ enumerable: true, get: function () { return map_1.map; } }));\nvar mapTo_1 = __webpack_require__(/*! ../internal/operators/mapTo */ \"./node_modules/rxjs/dist/cjs/internal/operators/mapTo.js\");\nObject.defineProperty(exports, \"mapTo\", ({ enumerable: true, get: function () { return mapTo_1.mapTo; } }));\nvar materialize_1 = __webpack_require__(/*! ../internal/operators/materialize */ \"./node_modules/rxjs/dist/cjs/internal/operators/materialize.js\");\nObject.defineProperty(exports, \"materialize\", ({ enumerable: true, get: function () { return materialize_1.materialize; } }));\nvar max_1 = __webpack_require__(/*! ../internal/operators/max */ \"./node_modules/rxjs/dist/cjs/internal/operators/max.js\");\nObject.defineProperty(exports, \"max\", ({ enumerable: true, get: function () { return max_1.max; } }));\nvar merge_1 = __webpack_require__(/*! ../internal/operators/merge */ \"./node_modules/rxjs/dist/cjs/internal/operators/merge.js\");\nObject.defineProperty(exports, \"merge\", ({ enumerable: true, get: function () { return merge_1.merge; } }));\nvar mergeAll_1 = __webpack_require__(/*! ../internal/operators/mergeAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js\");\nObject.defineProperty(exports, \"mergeAll\", ({ enumerable: true, get: function () { return mergeAll_1.mergeAll; } }));\nvar flatMap_1 = __webpack_require__(/*! ../internal/operators/flatMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/flatMap.js\");\nObject.defineProperty(exports, \"flatMap\", ({ enumerable: true, get: function () { return flatMap_1.flatMap; } }));\nvar mergeMap_1 = __webpack_require__(/*! ../internal/operators/mergeMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js\");\nObject.defineProperty(exports, \"mergeMap\", ({ enumerable: true, get: function () { return mergeMap_1.mergeMap; } }));\nvar mergeMapTo_1 = __webpack_require__(/*! ../internal/operators/mergeMapTo */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js\");\nObject.defineProperty(exports, \"mergeMapTo\", ({ enumerable: true, get: function () { return mergeMapTo_1.mergeMapTo; } }));\nvar mergeScan_1 = __webpack_require__(/*! ../internal/operators/mergeScan */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js\");\nObject.defineProperty(exports, \"mergeScan\", ({ enumerable: true, get: function () { return mergeScan_1.mergeScan; } }));\nvar mergeWith_1 = __webpack_require__(/*! ../internal/operators/mergeWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js\");\nObject.defineProperty(exports, \"mergeWith\", ({ enumerable: true, get: function () { return mergeWith_1.mergeWith; } }));\nvar min_1 = __webpack_require__(/*! ../internal/operators/min */ \"./node_modules/rxjs/dist/cjs/internal/operators/min.js\");\nObject.defineProperty(exports, \"min\", ({ enumerable: true, get: function () { return min_1.min; } }));\nvar multicast_1 = __webpack_require__(/*! ../internal/operators/multicast */ \"./node_modules/rxjs/dist/cjs/internal/operators/multicast.js\");\nObject.defineProperty(exports, \"multicast\", ({ enumerable: true, get: function () { return multicast_1.multicast; } }));\nvar observeOn_1 = __webpack_require__(/*! ../internal/operators/observeOn */ \"./node_modules/rxjs/dist/cjs/internal/operators/observeOn.js\");\nObject.defineProperty(exports, \"observeOn\", ({ enumerable: true, get: function () { return observeOn_1.observeOn; } }));\nvar onErrorResumeNextWith_1 = __webpack_require__(/*! ../internal/operators/onErrorResumeNextWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js\");\nObject.defineProperty(exports, \"onErrorResumeNext\", ({ enumerable: true, get: function () { return onErrorResumeNextWith_1.onErrorResumeNext; } }));\nvar pairwise_1 = __webpack_require__(/*! ../internal/operators/pairwise */ \"./node_modules/rxjs/dist/cjs/internal/operators/pairwise.js\");\nObject.defineProperty(exports, \"pairwise\", ({ enumerable: true, get: function () { return pairwise_1.pairwise; } }));\nvar partition_1 = __webpack_require__(/*! ../internal/operators/partition */ \"./node_modules/rxjs/dist/cjs/internal/operators/partition.js\");\nObject.defineProperty(exports, \"partition\", ({ enumerable: true, get: function () { return partition_1.partition; } }));\nvar pluck_1 = __webpack_require__(/*! ../internal/operators/pluck */ \"./node_modules/rxjs/dist/cjs/internal/operators/pluck.js\");\nObject.defineProperty(exports, \"pluck\", ({ enumerable: true, get: function () { return pluck_1.pluck; } }));\nvar publish_1 = __webpack_require__(/*! ../internal/operators/publish */ \"./node_modules/rxjs/dist/cjs/internal/operators/publish.js\");\nObject.defineProperty(exports, \"publish\", ({ enumerable: true, get: function () { return publish_1.publish; } }));\nvar publishBehavior_1 = __webpack_require__(/*! ../internal/operators/publishBehavior */ \"./node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js\");\nObject.defineProperty(exports, \"publishBehavior\", ({ enumerable: true, get: function () { return publishBehavior_1.publishBehavior; } }));\nvar publishLast_1 = __webpack_require__(/*! ../internal/operators/publishLast */ \"./node_modules/rxjs/dist/cjs/internal/operators/publishLast.js\");\nObject.defineProperty(exports, \"publishLast\", ({ enumerable: true, get: function () { return publishLast_1.publishLast; } }));\nvar publishReplay_1 = __webpack_require__(/*! ../internal/operators/publishReplay */ \"./node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js\");\nObject.defineProperty(exports, \"publishReplay\", ({ enumerable: true, get: function () { return publishReplay_1.publishReplay; } }));\nvar race_1 = __webpack_require__(/*! ../internal/operators/race */ \"./node_modules/rxjs/dist/cjs/internal/operators/race.js\");\nObject.defineProperty(exports, \"race\", ({ enumerable: true, get: function () { return race_1.race; } }));\nvar raceWith_1 = __webpack_require__(/*! ../internal/operators/raceWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/raceWith.js\");\nObject.defineProperty(exports, \"raceWith\", ({ enumerable: true, get: function () { return raceWith_1.raceWith; } }));\nvar reduce_1 = __webpack_require__(/*! ../internal/operators/reduce */ \"./node_modules/rxjs/dist/cjs/internal/operators/reduce.js\");\nObject.defineProperty(exports, \"reduce\", ({ enumerable: true, get: function () { return reduce_1.reduce; } }));\nvar repeat_1 = __webpack_require__(/*! ../internal/operators/repeat */ \"./node_modules/rxjs/dist/cjs/internal/operators/repeat.js\");\nObject.defineProperty(exports, \"repeat\", ({ enumerable: true, get: function () { return repeat_1.repeat; } }));\nvar repeatWhen_1 = __webpack_require__(/*! ../internal/operators/repeatWhen */ \"./node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js\");\nObject.defineProperty(exports, \"repeatWhen\", ({ enumerable: true, get: function () { return repeatWhen_1.repeatWhen; } }));\nvar retry_1 = __webpack_require__(/*! ../internal/operators/retry */ \"./node_modules/rxjs/dist/cjs/internal/operators/retry.js\");\nObject.defineProperty(exports, \"retry\", ({ enumerable: true, get: function () { return retry_1.retry; } }));\nvar retryWhen_1 = __webpack_require__(/*! ../internal/operators/retryWhen */ \"./node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js\");\nObject.defineProperty(exports, \"retryWhen\", ({ enumerable: true, get: function () { return retryWhen_1.retryWhen; } }));\nvar refCount_1 = __webpack_require__(/*! ../internal/operators/refCount */ \"./node_modules/rxjs/dist/cjs/internal/operators/refCount.js\");\nObject.defineProperty(exports, \"refCount\", ({ enumerable: true, get: function () { return refCount_1.refCount; } }));\nvar sample_1 = __webpack_require__(/*! ../internal/operators/sample */ \"./node_modules/rxjs/dist/cjs/internal/operators/sample.js\");\nObject.defineProperty(exports, \"sample\", ({ enumerable: true, get: function () { return sample_1.sample; } }));\nvar sampleTime_1 = __webpack_require__(/*! ../internal/operators/sampleTime */ \"./node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js\");\nObject.defineProperty(exports, \"sampleTime\", ({ enumerable: true, get: function () { return sampleTime_1.sampleTime; } }));\nvar scan_1 = __webpack_require__(/*! ../internal/operators/scan */ \"./node_modules/rxjs/dist/cjs/internal/operators/scan.js\");\nObject.defineProperty(exports, \"scan\", ({ enumerable: true, get: function () { return scan_1.scan; } }));\nvar sequenceEqual_1 = __webpack_require__(/*! ../internal/operators/sequenceEqual */ \"./node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js\");\nObject.defineProperty(exports, \"sequenceEqual\", ({ enumerable: true, get: function () { return sequenceEqual_1.sequenceEqual; } }));\nvar share_1 = __webpack_require__(/*! ../internal/operators/share */ \"./node_modules/rxjs/dist/cjs/internal/operators/share.js\");\nObject.defineProperty(exports, \"share\", ({ enumerable: true, get: function () { return share_1.share; } }));\nvar shareReplay_1 = __webpack_require__(/*! ../internal/operators/shareReplay */ \"./node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js\");\nObject.defineProperty(exports, \"shareReplay\", ({ enumerable: true, get: function () { return shareReplay_1.shareReplay; } }));\nvar single_1 = __webpack_require__(/*! ../internal/operators/single */ \"./node_modules/rxjs/dist/cjs/internal/operators/single.js\");\nObject.defineProperty(exports, \"single\", ({ enumerable: true, get: function () { return single_1.single; } }));\nvar skip_1 = __webpack_require__(/*! ../internal/operators/skip */ \"./node_modules/rxjs/dist/cjs/internal/operators/skip.js\");\nObject.defineProperty(exports, \"skip\", ({ enumerable: true, get: function () { return skip_1.skip; } }));\nvar skipLast_1 = __webpack_require__(/*! ../internal/operators/skipLast */ \"./node_modules/rxjs/dist/cjs/internal/operators/skipLast.js\");\nObject.defineProperty(exports, \"skipLast\", ({ enumerable: true, get: function () { return skipLast_1.skipLast; } }));\nvar skipUntil_1 = __webpack_require__(/*! ../internal/operators/skipUntil */ \"./node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js\");\nObject.defineProperty(exports, \"skipUntil\", ({ enumerable: true, get: function () { return skipUntil_1.skipUntil; } }));\nvar skipWhile_1 = __webpack_require__(/*! ../internal/operators/skipWhile */ \"./node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js\");\nObject.defineProperty(exports, \"skipWhile\", ({ enumerable: true, get: function () { return skipWhile_1.skipWhile; } }));\nvar startWith_1 = __webpack_require__(/*! ../internal/operators/startWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/startWith.js\");\nObject.defineProperty(exports, \"startWith\", ({ enumerable: true, get: function () { return startWith_1.startWith; } }));\nvar subscribeOn_1 = __webpack_require__(/*! ../internal/operators/subscribeOn */ \"./node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js\");\nObject.defineProperty(exports, \"subscribeOn\", ({ enumerable: true, get: function () { return subscribeOn_1.subscribeOn; } }));\nvar switchAll_1 = __webpack_require__(/*! ../internal/operators/switchAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/switchAll.js\");\nObject.defineProperty(exports, \"switchAll\", ({ enumerable: true, get: function () { return switchAll_1.switchAll; } }));\nvar switchMap_1 = __webpack_require__(/*! ../internal/operators/switchMap */ \"./node_modules/rxjs/dist/cjs/internal/operators/switchMap.js\");\nObject.defineProperty(exports, \"switchMap\", ({ enumerable: true, get: function () { return switchMap_1.switchMap; } }));\nvar switchMapTo_1 = __webpack_require__(/*! ../internal/operators/switchMapTo */ \"./node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js\");\nObject.defineProperty(exports, \"switchMapTo\", ({ enumerable: true, get: function () { return switchMapTo_1.switchMapTo; } }));\nvar switchScan_1 = __webpack_require__(/*! ../internal/operators/switchScan */ \"./node_modules/rxjs/dist/cjs/internal/operators/switchScan.js\");\nObject.defineProperty(exports, \"switchScan\", ({ enumerable: true, get: function () { return switchScan_1.switchScan; } }));\nvar take_1 = __webpack_require__(/*! ../internal/operators/take */ \"./node_modules/rxjs/dist/cjs/internal/operators/take.js\");\nObject.defineProperty(exports, \"take\", ({ enumerable: true, get: function () { return take_1.take; } }));\nvar takeLast_1 = __webpack_require__(/*! ../internal/operators/takeLast */ \"./node_modules/rxjs/dist/cjs/internal/operators/takeLast.js\");\nObject.defineProperty(exports, \"takeLast\", ({ enumerable: true, get: function () { return takeLast_1.takeLast; } }));\nvar takeUntil_1 = __webpack_require__(/*! ../internal/operators/takeUntil */ \"./node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js\");\nObject.defineProperty(exports, \"takeUntil\", ({ enumerable: true, get: function () { return takeUntil_1.takeUntil; } }));\nvar takeWhile_1 = __webpack_require__(/*! ../internal/operators/takeWhile */ \"./node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js\");\nObject.defineProperty(exports, \"takeWhile\", ({ enumerable: true, get: function () { return takeWhile_1.takeWhile; } }));\nvar tap_1 = __webpack_require__(/*! ../internal/operators/tap */ \"./node_modules/rxjs/dist/cjs/internal/operators/tap.js\");\nObject.defineProperty(exports, \"tap\", ({ enumerable: true, get: function () { return tap_1.tap; } }));\nvar throttle_1 = __webpack_require__(/*! ../internal/operators/throttle */ \"./node_modules/rxjs/dist/cjs/internal/operators/throttle.js\");\nObject.defineProperty(exports, \"throttle\", ({ enumerable: true, get: function () { return throttle_1.throttle; } }));\nvar throttleTime_1 = __webpack_require__(/*! ../internal/operators/throttleTime */ \"./node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js\");\nObject.defineProperty(exports, \"throttleTime\", ({ enumerable: true, get: function () { return throttleTime_1.throttleTime; } }));\nvar throwIfEmpty_1 = __webpack_require__(/*! ../internal/operators/throwIfEmpty */ \"./node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js\");\nObject.defineProperty(exports, \"throwIfEmpty\", ({ enumerable: true, get: function () { return throwIfEmpty_1.throwIfEmpty; } }));\nvar timeInterval_1 = __webpack_require__(/*! ../internal/operators/timeInterval */ \"./node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js\");\nObject.defineProperty(exports, \"timeInterval\", ({ enumerable: true, get: function () { return timeInterval_1.timeInterval; } }));\nvar timeout_1 = __webpack_require__(/*! ../internal/operators/timeout */ \"./node_modules/rxjs/dist/cjs/internal/operators/timeout.js\");\nObject.defineProperty(exports, \"timeout\", ({ enumerable: true, get: function () { return timeout_1.timeout; } }));\nvar timeoutWith_1 = __webpack_require__(/*! ../internal/operators/timeoutWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js\");\nObject.defineProperty(exports, \"timeoutWith\", ({ enumerable: true, get: function () { return timeoutWith_1.timeoutWith; } }));\nvar timestamp_1 = __webpack_require__(/*! ../internal/operators/timestamp */ \"./node_modules/rxjs/dist/cjs/internal/operators/timestamp.js\");\nObject.defineProperty(exports, \"timestamp\", ({ enumerable: true, get: function () { return timestamp_1.timestamp; } }));\nvar toArray_1 = __webpack_require__(/*! ../internal/operators/toArray */ \"./node_modules/rxjs/dist/cjs/internal/operators/toArray.js\");\nObject.defineProperty(exports, \"toArray\", ({ enumerable: true, get: function () { return toArray_1.toArray; } }));\nvar window_1 = __webpack_require__(/*! ../internal/operators/window */ \"./node_modules/rxjs/dist/cjs/internal/operators/window.js\");\nObject.defineProperty(exports, \"window\", ({ enumerable: true, get: function () { return window_1.window; } }));\nvar windowCount_1 = __webpack_require__(/*! ../internal/operators/windowCount */ \"./node_modules/rxjs/dist/cjs/internal/operators/windowCount.js\");\nObject.defineProperty(exports, \"windowCount\", ({ enumerable: true, get: function () { return windowCount_1.windowCount; } }));\nvar windowTime_1 = __webpack_require__(/*! ../internal/operators/windowTime */ \"./node_modules/rxjs/dist/cjs/internal/operators/windowTime.js\");\nObject.defineProperty(exports, \"windowTime\", ({ enumerable: true, get: function () { return windowTime_1.windowTime; } }));\nvar windowToggle_1 = __webpack_require__(/*! ../internal/operators/windowToggle */ \"./node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js\");\nObject.defineProperty(exports, \"windowToggle\", ({ enumerable: true, get: function () { return windowToggle_1.windowToggle; } }));\nvar windowWhen_1 = __webpack_require__(/*! ../internal/operators/windowWhen */ \"./node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js\");\nObject.defineProperty(exports, \"windowWhen\", ({ enumerable: true, get: function () { return windowWhen_1.windowWhen; } }));\nvar withLatestFrom_1 = __webpack_require__(/*! ../internal/operators/withLatestFrom */ \"./node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js\");\nObject.defineProperty(exports, \"withLatestFrom\", ({ enumerable: true, get: function () { return withLatestFrom_1.withLatestFrom; } }));\nvar zip_1 = __webpack_require__(/*! ../internal/operators/zip */ \"./node_modules/rxjs/dist/cjs/internal/operators/zip.js\");\nObject.defineProperty(exports, \"zip\", ({ enumerable: true, get: function () { return zip_1.zip; } }));\nvar zipAll_1 = __webpack_require__(/*! ../internal/operators/zipAll */ \"./node_modules/rxjs/dist/cjs/internal/operators/zipAll.js\");\nObject.defineProperty(exports, \"zipAll\", ({ enumerable: true, get: function () { return zipAll_1.zipAll; } }));\nvar zipWith_1 = __webpack_require__(/*! ../internal/operators/zipWith */ \"./node_modules/rxjs/dist/cjs/internal/operators/zipWith.js\");\nObject.defineProperty(exports, \"zipWith\", ({ enumerable: true, get: function () { return zipWith_1.zipWith; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ispace/./node_modules/rxjs/dist/cjs/operators/index.js?");

/***/ }),

/***/ "./src/authRequest.ts":
/*!****************************!*\
  !*** ./src/authRequest.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.authRequest = void 0;\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/dist/cjs/index.js\");\nvar httpClient_1 = __importDefault(__webpack_require__(/*! ./httpClient */ \"./src/httpClient.ts\"));\nvar userInfoDto_1 = __webpack_require__(/*! ./dto/userInfoDto */ \"./src/dto/userInfoDto.ts\");\nvar jwtUtil_1 = __webpack_require__(/*! ./util/jwtUtil */ \"./src/util/jwtUtil.ts\");\nvar resultDto_1 = __webpack_require__(/*! ./dto/resultDto */ \"./src/dto/resultDto.ts\");\nvar authRequest = /** @class */ (function () {\n    function authRequest() {\n        this.hc = new httpClient_1.default(\"/api\");\n    }\n    authRequest.prototype.getToken = function (name, password) {\n        return this.hc.post(\"/GetToken\", { name: name, password: password });\n    };\n    authRequest.prototype.validateToken = function (token) {\n        return this.hc.get(\"/VerifyToken\", { params: { token: token } });\n    };\n    authRequest.prototype.login = function (name, password) {\n        var _this = this;\n        var obs = new rxjs_1.Observable(function (observer) {\n            _this.getToken(name, password).subscribe({\n                next: function (r) {\n                    if (r.success && r.data != null) {\n                        var token = r.data;\n                        localStorage.setItem(\"token\", token);\n                    }\n                    observer.next(r);\n                },\n                error: function (error) {\n                    observer.error(error);\n                },\n            });\n        });\n        return obs;\n    };\n    authRequest.prototype.isLogin = function () {\n        var token = this.getLocalToken();\n        if (!token) {\n            var result = new resultDto_1.resultDto();\n            result.success = false;\n            result.message = \"not login\";\n            return (0, rxjs_1.of)(result);\n        }\n        return this.validateToken(token);\n    };\n    authRequest.prototype.getLocalToken = function () {\n        return localStorage.getItem(\"token\") || \"\";\n    };\n    authRequest.prototype.getUserInfo = function () {\n        var userInfo = new userInfoDto_1.userInfoDto();\n        var token = this.getLocalToken();\n        var Payload = jwtUtil_1.jwtUtil.parseJWT(token);\n        userInfo.name = Payload.name;\n        return userInfo;\n    };\n    return authRequest;\n}());\nexports.authRequest = authRequest;\n\n\n//# sourceURL=webpack://ispace/./src/authRequest.ts?");

/***/ }),

/***/ "./src/core.ts":
/*!*********************!*\
  !*** ./src/core.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.auth = exports.folder = exports.file = exports.gv = void 0;\nvar authRequest_1 = __webpack_require__(/*! ./authRequest */ \"./src/authRequest.ts\");\nvar fileHandler_1 = __webpack_require__(/*! ./fileHandler */ \"./src/fileHandler.ts\");\nvar folderHandler_1 = __webpack_require__(/*! ./folderHandler */ \"./src/folderHandler.ts\");\nvar cfg = {\n    defaultWebSocketUrl: \"/ws/default\"\n};\nexports.gv = {\n    token: \"\",\n    info: 1,\n    cfg: cfg,\n};\nexports.file = new fileHandler_1.fileHandler();\nexports.folder = new folderHandler_1.folderHandler();\nexports.auth = new authRequest_1.authRequest();\n\n\n//# sourceURL=webpack://ispace/./src/core.ts?");

/***/ }),

/***/ "./src/dto/resultDto.ts":
/*!******************************!*\
  !*** ./src/dto/resultDto.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.resultDto = void 0;\nvar resultDto = /** @class */ (function () {\n    function resultDto() {\n    }\n    return resultDto;\n}());\nexports.resultDto = resultDto;\n\n\n//# sourceURL=webpack://ispace/./src/dto/resultDto.ts?");

/***/ }),

/***/ "./src/dto/userInfoDto.ts":
/*!********************************!*\
  !*** ./src/dto/userInfoDto.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.userInfoDto = void 0;\nvar userInfoDto = /** @class */ (function () {\n    function userInfoDto() {\n    }\n    return userInfoDto;\n}());\nexports.userInfoDto = userInfoDto;\n\n\n//# sourceURL=webpack://ispace/./src/dto/userInfoDto.ts?");

/***/ }),

/***/ "./src/dto/wsRequestDto.ts":
/*!*********************************!*\
  !*** ./src/dto/wsRequestDto.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wsRequestHeaderDto = exports.wsRequestDto = void 0;\nvar wsRequestDto = /** @class */ (function () {\n    function wsRequestDto() {\n        this.header = new wsRequestHeaderDto();\n    }\n    return wsRequestDto;\n}());\nexports.wsRequestDto = wsRequestDto;\nvar wsRequestHeaderDto = /** @class */ (function () {\n    function wsRequestHeaderDto() {\n    }\n    return wsRequestHeaderDto;\n}());\nexports.wsRequestHeaderDto = wsRequestHeaderDto;\n\n\n//# sourceURL=webpack://ispace/./src/dto/wsRequestDto.ts?");

/***/ }),

/***/ "./src/fileHandler.ts":
/*!****************************!*\
  !*** ./src/fileHandler.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fileHandler = void 0;\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/dist/cjs/index.js\");\nvar ispaceWebSocket_1 = __webpack_require__(/*! ./ispaceWebSocket */ \"./src/ispaceWebSocket.ts\");\nvar wsRequestDto_1 = __webpack_require__(/*! ./dto/wsRequestDto */ \"./src/dto/wsRequestDto.ts\");\nvar fileHandler = /** @class */ (function () {\n    function fileHandler() {\n        // step 2: build ws\n        this.ws = ispaceWebSocket_1.ispaceWebSocket.getSingle();\n        this.ws.connect();\n    }\n    fileHandler.prototype.create = function (folderPath, name) {\n        var _this = this;\n        var ob = new rxjs_1.Observable(function (observer) {\n            // step init:\n            var handler = \"file/create\";\n            // step 1: build request\n            var req = new wsRequestDto_1.wsRequestDto();\n            req.header = new wsRequestDto_1.wsRequestHeaderDto();\n            req.header.handler = handler;\n            req.body = {\n                name: name,\n                folderPath: folderPath\n            };\n            // step 3: send ms\n            _this.ws.request(req).subscribe({\n                next: function (response) {\n                    var _a;\n                    if (((_a = response.header) === null || _a === void 0 ? void 0 : _a.stat) == 200) {\n                        observer.next(true);\n                    }\n                    else {\n                        observer.error(response.body);\n                    }\n                    observer.complete();\n                },\n                error: function (error) {\n                    observer.error(error);\n                    observer.complete();\n                }\n            });\n        });\n        return ob;\n    };\n    // TODO: implement rename\n    fileHandler.prototype.rename = function (folderPath, oldName, newName) {\n        var _this = this;\n        var ob = new rxjs_1.Observable(function (observer) {\n            // step init:\n            var handler = \"file/rename\";\n            // step 1: build request\n            var req = new wsRequestDto_1.wsRequestDto();\n            req.header = new wsRequestDto_1.wsRequestHeaderDto();\n            req.header.handler = handler;\n            req.body = {\n                folderPath: folderPath,\n                oldName: oldName,\n                newName: newName\n            };\n            // step 3: send ms\n            _this.ws.request(req).subscribe({\n                next: function (response) {\n                    var _a;\n                    if (((_a = response.header) === null || _a === void 0 ? void 0 : _a.stat) == 200) {\n                        observer.next(true);\n                    }\n                    else {\n                        observer.error(response.body);\n                    }\n                    observer.complete();\n                },\n                error: function (error) {\n                    observer.error(error);\n                    observer.complete();\n                }\n            });\n        });\n        return ob;\n    };\n    /**\n     * Remove a file\n     * @param folderPath the path where the file is located\n     * @param name the name of the file to remove\n     * @returns an Observable that emits a boolean indicating if the file was successfully removed\n     */\n    fileHandler.prototype.remove = function (folderPath, name) {\n        var _this = this;\n        var ob = new rxjs_1.Observable(function (observer) {\n            // step init:\n            var handler = \"file/remove\";\n            // step 1: build request\n            var req = new wsRequestDto_1.wsRequestDto();\n            req.header = new wsRequestDto_1.wsRequestHeaderDto();\n            req.header.handler = handler;\n            req.body = {\n                folderPath: folderPath,\n                name: name\n            };\n            // step 3: send ms\n            _this.ws.request(req).subscribe({\n                next: function (response) {\n                    var _a;\n                    if (((_a = response.header) === null || _a === void 0 ? void 0 : _a.stat) == 200) {\n                        observer.next(true);\n                    }\n                    else {\n                        observer.error(response.body);\n                    }\n                    observer.complete();\n                },\n                error: function (error) {\n                    observer.error(error);\n                    observer.complete();\n                }\n            });\n        });\n        return ob;\n    };\n    /**\n     * Retrieves information about a file.\n     * @param filePath the path of the file to retrieve information about\n     * @returns an Observable that emits a fileInfoDto object containing information about the file\n     */\n    fileHandler.prototype.statf = function (filePath) {\n        var _this = this;\n        var ob = new rxjs_1.Observable(function (observer) {\n            // step init:\n            var handler = \"file/stat\";\n            // step 1: build request\n            var req = new wsRequestDto_1.wsRequestDto();\n            req.header = new wsRequestDto_1.wsRequestHeaderDto();\n            req.header.handler = handler;\n            req.body = {\n                filePath: filePath\n            };\n            // step 3: send ms\n            _this.ws.request(req).subscribe({\n                next: function (response) {\n                    var _a;\n                    if (((_a = response.header) === null || _a === void 0 ? void 0 : _a.stat) == 200) {\n                        observer.next(response.body);\n                    }\n                    else {\n                        observer.error(response.body);\n                    }\n                    observer.complete();\n                },\n                error: function (error) {\n                    observer.error(error);\n                    observer.complete();\n                }\n            });\n        });\n        return ob;\n    };\n    return fileHandler;\n}());\nexports.fileHandler = fileHandler;\n\n\n//# sourceURL=webpack://ispace/./src/fileHandler.ts?");

/***/ }),

/***/ "./src/folderHandler.ts":
/*!******************************!*\
  !*** ./src/folderHandler.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.folderHandler = void 0;\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/dist/cjs/index.js\");\nvar ispaceWebSocket_1 = __webpack_require__(/*! ./ispaceWebSocket */ \"./src/ispaceWebSocket.ts\");\nvar wsRequestDto_1 = __webpack_require__(/*! ./dto/wsRequestDto */ \"./src/dto/wsRequestDto.ts\");\nvar folderHandler = /** @class */ (function () {\n    function folderHandler() {\n        // step 2: build ws\n        this.ws = ispaceWebSocket_1.ispaceWebSocket.getSingle();\n        this.ws.connect();\n    }\n    folderHandler.prototype.create = function (folderPath, name) {\n        var _this = this;\n        var ob = new rxjs_1.Observable(function (observer) {\n            // step init:\n            var handler = \"folder/create\";\n            // step 1: build request\n            var req = new wsRequestDto_1.wsRequestDto();\n            req.header = new wsRequestDto_1.wsRequestHeaderDto();\n            req.header.handler = handler;\n            req.body = {\n                folderPath: folderPath,\n                name: name\n            };\n            // step 3: send ms\n            _this.ws.request(req).subscribe({\n                next: function (response) {\n                    var _a;\n                    if (((_a = response.header) === null || _a === void 0 ? void 0 : _a.stat) == 200) {\n                        observer.next(true);\n                    }\n                    else {\n                        observer.error(response.body);\n                    }\n                    observer.complete();\n                },\n                error: function (error) {\n                    observer.error(error);\n                    observer.complete();\n                }\n            });\n        });\n        return ob;\n    };\n    folderHandler.prototype.rename = function (folderPath, oldName, newName) {\n        var _this = this;\n        var ob = new rxjs_1.Observable(function (observer) {\n            // step init:\n            var handler = \"folder/rename\";\n            // step 1: build request\n            var req = new wsRequestDto_1.wsRequestDto();\n            req.header = new wsRequestDto_1.wsRequestHeaderDto();\n            req.header.handler = handler;\n            req.body = {\n                folderPath: folderPath,\n                oldName: oldName,\n                newName: newName\n            };\n            // step 3: send ms\n            _this.ws.request(req).subscribe({\n                next: function (response) {\n                    var _a;\n                    if (((_a = response.header) === null || _a === void 0 ? void 0 : _a.stat) == 200) {\n                        observer.next(true);\n                    }\n                    else {\n                        observer.error(response.body);\n                    }\n                    observer.complete();\n                },\n                error: function (error) {\n                    observer.error(error);\n                    observer.complete();\n                }\n            });\n        });\n        return ob;\n    };\n    folderHandler.prototype.remove = function (folderPath, name) {\n        var _this = this;\n        var ob = new rxjs_1.Observable(function (observer) {\n            // step init:\n            var handler = \"folder/remove\";\n            // step 1: build request\n            var req = new wsRequestDto_1.wsRequestDto();\n            req.header = new wsRequestDto_1.wsRequestHeaderDto();\n            req.header.handler = handler;\n            req.body = {\n                folderPath: folderPath,\n                name: name\n            };\n            // step 3: send ms\n            _this.ws.request(req).subscribe({\n                next: function (response) {\n                    var _a;\n                    if (((_a = response.header) === null || _a === void 0 ? void 0 : _a.stat) == 200) {\n                        observer.next(true);\n                    }\n                    else {\n                        observer.error(response.body);\n                    }\n                    observer.complete();\n                },\n                error: function (error) {\n                    observer.error(error);\n                    observer.complete();\n                }\n            });\n        });\n        return ob;\n    };\n    folderHandler.prototype.statf = function (folderPath) {\n        var _this = this;\n        var ob = new rxjs_1.Observable(function (observer) {\n            // step init:\n            var handler = \"folder/stat\";\n            // step 1: build request\n            var req = new wsRequestDto_1.wsRequestDto();\n            req.header = new wsRequestDto_1.wsRequestHeaderDto();\n            req.header.handler = handler;\n            req.body = {\n                folderPath: folderPath\n            };\n            // step 3: send ms\n            _this.ws.request(req).subscribe({\n                next: function (response) {\n                    var _a;\n                    if (((_a = response.header) === null || _a === void 0 ? void 0 : _a.stat) == 200) {\n                        observer.next(response.body);\n                    }\n                    else {\n                        observer.error(response.body);\n                    }\n                    observer.complete();\n                },\n                error: function (error) {\n                    observer.error(error);\n                    observer.complete();\n                }\n            });\n        });\n        return ob;\n    };\n    folderHandler.prototype.children = function (folderPath) {\n        var _this = this;\n        var ob = new rxjs_1.Observable(function (observer) {\n            // step init:\n            var handler = \"folder/children\";\n            // step 1: build request\n            var req = new wsRequestDto_1.wsRequestDto();\n            req.header = new wsRequestDto_1.wsRequestHeaderDto();\n            req.header.handler = handler;\n            req.body = {\n                folderPath: folderPath\n            };\n            // step 3: send ms\n            _this.ws.request(req).subscribe({\n                next: function (response) {\n                    var _a;\n                    if (((_a = response.header) === null || _a === void 0 ? void 0 : _a.stat) == 200) {\n                        observer.next(response.body);\n                    }\n                    else {\n                        observer.error(response.body);\n                    }\n                    observer.complete();\n                },\n                error: function (error) {\n                    observer.error(error);\n                    observer.complete();\n                }\n            });\n        });\n        return ob;\n    };\n    return folderHandler;\n}());\nexports.folderHandler = folderHandler;\n\n\n//# sourceURL=webpack://ispace/./src/folderHandler.ts?");

/***/ }),

/***/ "./src/httpClient.ts":
/*!***************************!*\
  !*** ./src/httpClient.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar axios_1 = __importDefault(__webpack_require__(/*! axios */ \"./node_modules/axios/dist/browser/axios.cjs\"));\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/dist/cjs/index.js\");\nvar operators_1 = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/dist/cjs/operators/index.js\");\nvar HttpClient = /** @class */ (function () {\n    function HttpClient(baseURL) {\n        this.axiosInstance = axios_1.default.create({\n            baseURL: baseURL\n        });\n    }\n    HttpClient.prototype.get = function (url, config) {\n        return (0, rxjs_1.from)(this.axiosInstance.get(url, config)).pipe((0, operators_1.map)(function (response) { return response.data; }), (0, operators_1.catchError)(function (error) { throw error; }));\n    };\n    HttpClient.prototype.post = function (url, data, config) {\n        return (0, rxjs_1.from)(this.axiosInstance.post(url, data, config)).pipe((0, operators_1.map)(function (response) { return response.data; }), (0, operators_1.catchError)(function (error) { throw error; }));\n    };\n    HttpClient.prototype.put = function (url, data, config) {\n        return (0, rxjs_1.from)(this.axiosInstance.put(url, data, config)).pipe((0, operators_1.map)(function (response) { return response.data; }), (0, operators_1.catchError)(function (error) { throw error; }));\n    };\n    HttpClient.prototype.delete = function (url, config) {\n        return (0, rxjs_1.from)(this.axiosInstance.delete(url, config)).pipe((0, operators_1.map)(function (response) { return response.data; }), (0, operators_1.catchError)(function (error) { throw error; }));\n    };\n    return HttpClient;\n}());\nexports[\"default\"] = HttpClient;\n\n\n//# sourceURL=webpack://ispace/./src/httpClient.ts?");

/***/ }),

/***/ "./src/ispaceWebSocket.ts":
/*!********************************!*\
  !*** ./src/ispaceWebSocket.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ispaceWebSocket = void 0;\nvar rxjs_1 = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/dist/cjs/index.js\");\nvar core_1 = __webpack_require__(/*! ./core */ \"./src/core.ts\");\nvar uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/commonjs-browser/index.js\");\nvar ispaceWebSocket = /** @class */ (function () {\n    function ispaceWebSocket() {\n    }\n    ispaceWebSocket.getSingle = function (tag, url) {\n        if (tag === void 0) { tag = \"\"; }\n        if (url === void 0) { url = core_1.gv.cfg.defaultWebSocketUrl; }\n        var iws = this.wsMap.get(tag);\n        if (iws) {\n            return iws;\n        }\n        iws = new ispaceWebSocket();\n        iws.url = url;\n        this.wsMap.set(tag, iws);\n        return iws;\n    };\n    ispaceWebSocket.prototype.connect = function () {\n        var _a, _b, _c, _d, _e;\n        if (((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) !== WebSocket.OPEN) {\n            this.ws = new WebSocket(this.url);\n        }\n        this.ws.onopen = (_b = this.onopen) !== null && _b !== void 0 ? _b : (function () { });\n        this.ws.onmessage = (_c = this.onmessage) !== null && _c !== void 0 ? _c : (function () { });\n        this.ws.onclose = (_d = this.onclose) !== null && _d !== void 0 ? _d : (function () { });\n        this.ws.onerror = (_e = this.onerror) !== null && _e !== void 0 ? _e : (function () { });\n    };\n    ispaceWebSocket.prototype.request = function (req) {\n        var _this = this;\n        var ob = new rxjs_1.Observable(function (observer) {\n            var _a;\n            // step 1: headerstring data\n            req.header.id = (0, uuid_1.v4)();\n            req.header.token = core_1.gv.token;\n            var data = JSON.stringify(req);\n            // step 2: send \n            if (_this.ws && _this.ws.readyState === WebSocket.OPEN) {\n                _this.ws.send(data);\n            }\n            else {\n                _this.connect();\n                var si_1 = setInterval(function () {\n                    if (_this.ws && _this.ws.readyState === WebSocket.OPEN) {\n                        _this.ws.send(data);\n                        clearInterval(si_1);\n                    }\n                }, 10);\n            }\n            // step 3: deal response\n            var receive = function (e) {\n                var _a;\n                try {\n                    var response = JSON.parse(e.data);\n                    if (response.header.id == req.header.id) {\n                        observer.next(response);\n                        observer.complete();\n                    }\n                }\n                catch (e) {\n                    observer.error(e);\n                }\n                finally {\n                    (_a = _this.ws) === null || _a === void 0 ? void 0 : _a.addEventListener('message', receive);\n                }\n            };\n            (_a = _this.ws) === null || _a === void 0 ? void 0 : _a.addEventListener('message', receive);\n        });\n        return ob;\n    };\n    ispaceWebSocket.prototype.close = function () {\n        if (this.ws) {\n            this.ws.close();\n        }\n    };\n    ispaceWebSocket.wsMap = new Map();\n    return ispaceWebSocket;\n}());\nexports.ispaceWebSocket = ispaceWebSocket;\n\n\n//# sourceURL=webpack://ispace/./src/ispaceWebSocket.ts?");

/***/ }),

/***/ "./src/util/jwtUtil.ts":
/*!*****************************!*\
  !*** ./src/util/jwtUtil.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.jwtUtil = void 0;\nvar jwtUtil = /** @class */ (function () {\n    function jwtUtil() {\n    }\n    jwtUtil.parseJWT = function (token) {\n        var base64Url = token.split('.')[1];\n        var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n        var jsonPayload = decodeURIComponent(atob(base64).split('').map(function (c) {\n            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n        }).join(''));\n        return JSON.parse(jsonPayload);\n    };\n    return jwtUtil;\n}());\nexports.jwtUtil = jwtUtil;\n\n\n//# sourceURL=webpack://ispace/./src/util/jwtUtil.ts?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"MAX\", ({\n  enumerable: true,\n  get: function get() {\n    return _max.default;\n  }\n}));\nObject.defineProperty(exports, \"NIL\", ({\n  enumerable: true,\n  get: function get() {\n    return _nil.default;\n  }\n}));\nObject.defineProperty(exports, \"parse\", ({\n  enumerable: true,\n  get: function get() {\n    return _parse.default;\n  }\n}));\nObject.defineProperty(exports, \"stringify\", ({\n  enumerable: true,\n  get: function get() {\n    return _stringify.default;\n  }\n}));\nObject.defineProperty(exports, \"v1\", ({\n  enumerable: true,\n  get: function get() {\n    return _v.default;\n  }\n}));\nObject.defineProperty(exports, \"v1ToV6\", ({\n  enumerable: true,\n  get: function get() {\n    return _v1ToV.default;\n  }\n}));\nObject.defineProperty(exports, \"v3\", ({\n  enumerable: true,\n  get: function get() {\n    return _v2.default;\n  }\n}));\nObject.defineProperty(exports, \"v4\", ({\n  enumerable: true,\n  get: function get() {\n    return _v3.default;\n  }\n}));\nObject.defineProperty(exports, \"v5\", ({\n  enumerable: true,\n  get: function get() {\n    return _v4.default;\n  }\n}));\nObject.defineProperty(exports, \"v6\", ({\n  enumerable: true,\n  get: function get() {\n    return _v5.default;\n  }\n}));\nObject.defineProperty(exports, \"v6ToV1\", ({\n  enumerable: true,\n  get: function get() {\n    return _v6ToV.default;\n  }\n}));\nObject.defineProperty(exports, \"v7\", ({\n  enumerable: true,\n  get: function get() {\n    return _v6.default;\n  }\n}));\nObject.defineProperty(exports, \"validate\", ({\n  enumerable: true,\n  get: function get() {\n    return _validate.default;\n  }\n}));\nObject.defineProperty(exports, \"version\", ({\n  enumerable: true,\n  get: function get() {\n    return _version.default;\n  }\n}));\nvar _max = _interopRequireDefault(__webpack_require__(/*! ./max.js */ \"./node_modules/uuid/dist/commonjs-browser/max.js\"));\nvar _nil = _interopRequireDefault(__webpack_require__(/*! ./nil.js */ \"./node_modules/uuid/dist/commonjs-browser/nil.js\"));\nvar _parse = _interopRequireDefault(__webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/commonjs-browser/parse.js\"));\nvar _stringify = _interopRequireDefault(__webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\"));\nvar _v = _interopRequireDefault(__webpack_require__(/*! ./v1.js */ \"./node_modules/uuid/dist/commonjs-browser/v1.js\"));\nvar _v1ToV = _interopRequireDefault(__webpack_require__(/*! ./v1ToV6.js */ \"./node_modules/uuid/dist/commonjs-browser/v1ToV6.js\"));\nvar _v2 = _interopRequireDefault(__webpack_require__(/*! ./v3.js */ \"./node_modules/uuid/dist/commonjs-browser/v3.js\"));\nvar _v3 = _interopRequireDefault(__webpack_require__(/*! ./v4.js */ \"./node_modules/uuid/dist/commonjs-browser/v4.js\"));\nvar _v4 = _interopRequireDefault(__webpack_require__(/*! ./v5.js */ \"./node_modules/uuid/dist/commonjs-browser/v5.js\"));\nvar _v5 = _interopRequireDefault(__webpack_require__(/*! ./v6.js */ \"./node_modules/uuid/dist/commonjs-browser/v6.js\"));\nvar _v6ToV = _interopRequireDefault(__webpack_require__(/*! ./v6ToV1.js */ \"./node_modules/uuid/dist/commonjs-browser/v6ToV1.js\"));\nvar _v6 = _interopRequireDefault(__webpack_require__(/*! ./v7.js */ \"./node_modules/uuid/dist/commonjs-browser/v7.js\"));\nvar _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/commonjs-browser/validate.js\"));\nvar _version = _interopRequireDefault(__webpack_require__(/*! ./version.js */ \"./node_modules/uuid/dist/commonjs-browser/version.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/index.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/max.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/max.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _default = exports[\"default\"] = 'ffffffff-ffff-ffff-ffff-ffffffffffff';\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/max.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/md5.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/md5.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n    for (var i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n\n/*\n * Convert an array of little-endian words to an array of bytes\n */\nfunction md5ToHexEncodedArray(input) {\n  var output = [];\n  var length32 = input.length * 32;\n  var hexTab = '0123456789abcdef';\n  for (var i = 0; i < length32; i += 8) {\n    var x = input[i >> 5] >>> i % 32 & 0xff;\n    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n  return output;\n}\n\n/**\n * Calculate output length with padding and bit length\n */\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n  for (var i = 0; i < x.length; i += 16) {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n  return [a, b, c, d];\n}\n\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n  var length8 = input.length * 8;\n  var output = new Uint32Array(getOutputLength(length8));\n  for (var i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n  return output;\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safeAdd(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\nvar _default = exports[\"default\"] = md5;\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/md5.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/native.js":
/*!***********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/native.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nvar _default = exports[\"default\"] = {\n  randomUUID\n};\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/native.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/nil.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/nil.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _default = exports[\"default\"] = '00000000-0000-0000-0000-000000000000';\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/nil.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/parse.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/parse.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/commonjs-browser/validate.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction parse(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  var v;\n  var arr = new Uint8Array(16);\n\n  // Parse ########-....-....-....-............\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff;\n\n  // Parse ........-####-....-....-............\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Parse ........-....-####-....-............\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Parse ........-....-....-####-............\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\nvar _default = exports[\"default\"] = parse;\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/parse.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/regex.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/regex.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _default = exports[\"default\"] = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/regex.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/rng.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/rng.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = rng;\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n  return getRandomValues(rnds8);\n}\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/rng.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/sha1.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/sha1.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n    case 1:\n      return x ^ y ^ z;\n    case 2:\n      return x & y ^ x & z ^ y & z;\n    case 3:\n      return x ^ y ^ z;\n  }\n}\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n    M[_i] = arr;\n  }\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\nvar _default = exports[\"default\"] = sha1;\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/sha1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/stringify.js":
/*!**************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/stringify.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nexports.unsafeStringify = unsafeStringify;\nvar _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/commonjs-browser/validate.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  var uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\nvar _default = exports[\"default\"] = stringify;\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/stringify.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v1.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v1.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/commonjs-browser/rng.js\"));\nvar _stringify = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || new Array(16);\n  options = options || {};\n  var node = options.node;\n  var clockseq = options.clockseq;\n\n  // v1 only: Use cached `node` and `clockseq` values\n  if (!options._v6) {\n    if (!node) {\n      node = _nodeId;\n    }\n    if (clockseq == null) {\n      clockseq = _clockseq;\n    }\n  }\n\n  // Handle cases where we need entropy.  We do this lazily to minimize issues\n  // related to insufficient system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = options.random || (options.rng || _rng.default)();\n\n    // Randomize node\n    if (node == null) {\n      node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n\n      // v1 only: cache node value for reuse\n      if (!_nodeId && !options._v6) {\n        // per RFC4122 4.5: Set MAC multicast bit (v1 only)\n        node[0] |= 0x01; // Set multicast bit\n\n        _nodeId = node;\n      }\n    }\n\n    // Randomize clockseq\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n      if (_clockseq === undefined && !options._v6) {\n        _clockseq = clockseq;\n      }\n    }\n  }\n\n  // v1 & v6 timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so time is\n  // handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n  return buf || (0, _stringify.unsafeStringify)(b);\n}\nvar _default = exports[\"default\"] = v1;\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/v1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v1ToV6.js":
/*!***********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v1ToV6.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = v1ToV6;\nvar _parse = _interopRequireDefault(__webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/commonjs-browser/parse.js\"));\nvar _stringify = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/**\n * Convert a v1 UUID to a v6 UUID\n *\n * @param {string|Uint8Array} uuid - The v1 UUID to convert to v6\n * @returns {string|Uint8Array} The v6 UUID as the same type as the `uuid` arg\n * (string or Uint8Array)\n */\nfunction v1ToV6(uuid) {\n  var v1Bytes = typeof uuid === 'string' ? (0, _parse.default)(uuid) : uuid;\n  var v6Bytes = _v1ToV6(v1Bytes);\n  return typeof uuid === 'string' ? (0, _stringify.unsafeStringify)(v6Bytes) : v6Bytes;\n}\n\n// Do the field transformation needed for v1 -> v6\nfunction _v1ToV6(v1Bytes, randomize = false) {\n  return Uint8Array.of((v1Bytes[6] & 0x0f) << 4 | v1Bytes[7] >> 4 & 0x0f, (v1Bytes[7] & 0x0f) << 4 | (v1Bytes[4] & 0xf0) >> 4, (v1Bytes[4] & 0x0f) << 4 | (v1Bytes[5] & 0xf0) >> 4, (v1Bytes[5] & 0x0f) << 4 | (v1Bytes[0] & 0xf0) >> 4, (v1Bytes[0] & 0x0f) << 4 | (v1Bytes[1] & 0xf0) >> 4, (v1Bytes[1] & 0x0f) << 4 | (v1Bytes[2] & 0xf0) >> 4, 0x60 | v1Bytes[2] & 0x0f, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);\n}\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/v1ToV6.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v3.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v3.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _v = _interopRequireDefault(__webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/commonjs-browser/v35.js\"));\nvar _md = _interopRequireDefault(__webpack_require__(/*! ./md5.js */ \"./node_modules/uuid/dist/commonjs-browser/md5.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nvar v3 = (0, _v.default)('v3', 0x30, _md.default);\nvar _default = exports[\"default\"] = v3;\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/v3.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v35.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v35.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.URL = exports.DNS = void 0;\nexports[\"default\"] = v35;\nvar _stringify = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\");\nvar _parse = _interopRequireDefault(__webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/commonjs-browser/parse.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n  return bytes;\n}\nvar DNS = exports.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nvar URL = exports.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n    if (typeof namespace === 'string') {\n      namespace = (0, _parse.default)(namespace);\n    }\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n\n    // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n    if (buf) {\n      offset = offset || 0;\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n      return buf;\n    }\n    return (0, _stringify.unsafeStringify)(bytes);\n  }\n\n  // Function#name is not settable on some platforms (#270)\n  try {\n    generateUUID.name = name;\n  } catch (err) {}\n\n  // For CommonJS default export support\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/v35.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v4.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v4.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _native = _interopRequireDefault(__webpack_require__(/*! ./native.js */ \"./node_modules/uuid/dist/commonjs-browser/native.js\"));\nvar _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/commonjs-browser/rng.js\"));\nvar _stringify = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction v4(options, buf, offset) {\n  if (_native.default.randomUUID && !buf && !options) {\n    return _native.default.randomUUID();\n  }\n  options = options || {};\n  var rnds = options.random || (options.rng || _rng.default)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return (0, _stringify.unsafeStringify)(rnds);\n}\nvar _default = exports[\"default\"] = v4;\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/v4.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v5.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v5.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _v = _interopRequireDefault(__webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/commonjs-browser/v35.js\"));\nvar _sha = _interopRequireDefault(__webpack_require__(/*! ./sha1.js */ \"./node_modules/uuid/dist/commonjs-browser/sha1.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nvar v5 = (0, _v.default)('v5', 0x50, _sha.default);\nvar _default = exports[\"default\"] = v5;\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/v5.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v6.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v6.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = v6;\nvar _stringify = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\");\nvar _v = _interopRequireDefault(__webpack_require__(/*! ./v1.js */ \"./node_modules/uuid/dist/commonjs-browser/v1.js\"));\nvar _v1ToV = _interopRequireDefault(__webpack_require__(/*! ./v1ToV6.js */ \"./node_modules/uuid/dist/commonjs-browser/v1ToV6.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n *\n * @param {object} options\n * @param {Uint8Array=} buf\n * @param {number=} offset\n * @returns\n */\nfunction v6(options = {}, buf, offset = 0) {\n  // v6 is v1 with different field layout, so we start with a v1 UUID, albeit\n  // with slightly different behavior around how the clock_seq and node fields\n  // are randomized, which is why we call v1 with _v6: true.\n  var bytes = (0, _v.default)(_objectSpread(_objectSpread({}, options), {}, {\n    _v6: true\n  }), new Uint8Array(16));\n\n  // Reorder the fields to v6 layout.\n  bytes = (0, _v1ToV.default)(bytes);\n\n  // Return as a byte array if requested\n  if (buf) {\n    for (var i = 0; i < 16; i++) {\n      buf[offset + i] = bytes[i];\n    }\n    return buf;\n  }\n  return (0, _stringify.unsafeStringify)(bytes);\n}\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/v6.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v6ToV1.js":
/*!***********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v6ToV1.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = v6ToV1;\nvar _parse = _interopRequireDefault(__webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/commonjs-browser/parse.js\"));\nvar _stringify = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/**\n * Convert a v6 UUID to a v1 UUID\n *\n * @param {string|Uint8Array} uuid - The v6 UUID to convert to v6\n * @returns {string|Uint8Array} The v1 UUID as the same type as the `uuid` arg\n * (string or Uint8Array)\n */\nfunction v6ToV1(uuid) {\n  var v6Bytes = typeof uuid === 'string' ? (0, _parse.default)(uuid) : uuid;\n  var v1Bytes = _v6ToV1(v6Bytes);\n  return typeof uuid === 'string' ? (0, _stringify.unsafeStringify)(v1Bytes) : v1Bytes;\n}\n\n// Do the field transformation needed for v6 -> v1\nfunction _v6ToV1(v6Bytes) {\n  return Uint8Array.of((v6Bytes[3] & 0x0f) << 4 | v6Bytes[4] >> 4 & 0x0f, (v6Bytes[4] & 0x0f) << 4 | (v6Bytes[5] & 0xf0) >> 4, (v6Bytes[5] & 0x0f) << 4 | v6Bytes[6] & 0x0f, v6Bytes[7], (v6Bytes[1] & 0x0f) << 4 | (v6Bytes[2] & 0xf0) >> 4, (v6Bytes[2] & 0x0f) << 4 | (v6Bytes[3] & 0xf0) >> 4, 0x10 | (v6Bytes[0] & 0xf0) >> 4, (v6Bytes[0] & 0x0f) << 4 | (v6Bytes[1] & 0xf0) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);\n}\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/v6ToV1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v7.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v7.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/commonjs-browser/rng.js\"));\nvar _stringify = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/commonjs-browser/stringify.js\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/**\n * UUID V7 - Unix Epoch time-based UUID\n *\n * The IETF has published RFC9562, introducing 3 new UUID versions (6,7,8). This\n * implementation of V7 is based on the accepted, though not yet approved,\n * revisions.\n *\n * RFC 9562:https://www.rfc-editor.org/rfc/rfc9562.html Universally Unique\n * IDentifiers (UUIDs)\n\n *\n * Sample V7 value:\n * https://www.rfc-editor.org/rfc/rfc9562.html#name-example-of-a-uuidv7-value\n *\n * Monotonic Bit Layout: RFC rfc9562.6.2 Method 1, Dedicated Counter Bits ref:\n *     https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-5.1\n *\n *   0                   1                   2                   3 0 1 2 3 4 5 6\n *   7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                          unix_ts_ms                           |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |          unix_ts_ms           |  ver  |        seq_hi         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |var|               seq_low               |        rand         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                             rand                              |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * seq is a 31 bit serialized counter; comprised of 12 bit seq_hi and 19 bit\n * seq_low, and randomly initialized upon timestamp change. 31 bit counter size\n * was selected as any bitwise operations in node are done as _signed_ 32 bit\n * ints. we exclude the sign bit.\n */\n\nvar _seqLow = null;\nvar _seqHigh = null;\nvar _msecs = 0;\nfunction v7(options, buf, offset) {\n  options = options || {};\n\n  // initialize buffer and pointer\n  var i = buf && offset || 0;\n  var b = buf || new Uint8Array(16);\n\n  // rnds is Uint8Array(16) filled with random bytes\n  var rnds = options.random || (options.rng || _rng.default)();\n\n  // milliseconds since unix epoch, 1970-01-01 00:00\n  var msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // seq is user provided 31 bit counter\n  var seq = options.seq !== undefined ? options.seq : null;\n\n  // initialize local seq high/low parts\n  var seqHigh = _seqHigh;\n  var seqLow = _seqLow;\n\n  // check if clock has advanced and user has not provided msecs\n  if (msecs > _msecs && options.msecs === undefined) {\n    _msecs = msecs;\n\n    // unless user provided seq, reset seq parts\n    if (seq !== null) {\n      seqHigh = null;\n      seqLow = null;\n    }\n  }\n\n  // if we have a user provided seq\n  if (seq !== null) {\n    // trim provided seq to 31 bits of value, avoiding overflow\n    if (seq > 0x7fffffff) {\n      seq = 0x7fffffff;\n    }\n\n    // split provided seq into high/low parts\n    seqHigh = seq >>> 19 & 0xfff;\n    seqLow = seq & 0x7ffff;\n  }\n\n  // randomly initialize seq\n  if (seqHigh === null || seqLow === null) {\n    seqHigh = rnds[6] & 0x7f;\n    seqHigh = seqHigh << 8 | rnds[7];\n    seqLow = rnds[8] & 0x3f; // pad for var\n    seqLow = seqLow << 8 | rnds[9];\n    seqLow = seqLow << 5 | rnds[10] >>> 3;\n  }\n\n  // increment seq if within msecs window\n  if (msecs + 10000 > _msecs && seq === null) {\n    if (++seqLow > 0x7ffff) {\n      seqLow = 0;\n      if (++seqHigh > 0xfff) {\n        seqHigh = 0;\n\n        // increment internal _msecs. this allows us to continue incrementing\n        // while staying monotonic. Note, once we hit 10k milliseconds beyond system\n        // clock, we will reset breaking monotonicity (after (2^31)*10000 generations)\n        _msecs++;\n      }\n    }\n  } else {\n    // resetting; we have advanced more than\n    // 10k milliseconds beyond system clock\n    _msecs = msecs;\n  }\n  _seqHigh = seqHigh;\n  _seqLow = seqLow;\n\n  // [bytes 0-5] 48 bits of local timestamp\n  b[i++] = _msecs / 0x10000000000 & 0xff;\n  b[i++] = _msecs / 0x100000000 & 0xff;\n  b[i++] = _msecs / 0x1000000 & 0xff;\n  b[i++] = _msecs / 0x10000 & 0xff;\n  b[i++] = _msecs / 0x100 & 0xff;\n  b[i++] = _msecs & 0xff;\n\n  // [byte 6] - set 4 bits of version (7) with first 4 bits seq_hi\n  b[i++] = seqHigh >>> 4 & 0x0f | 0x70;\n\n  // [byte 7] remaining 8 bits of seq_hi\n  b[i++] = seqHigh & 0xff;\n\n  // [byte 8] - variant (2 bits), first 6 bits seq_low\n  b[i++] = seqLow >>> 13 & 0x3f | 0x80;\n\n  // [byte 9] 8 bits seq_low\n  b[i++] = seqLow >>> 5 & 0xff;\n\n  // [byte 10] remaining 5 bits seq_low, 3 bits random\n  b[i++] = seqLow << 3 & 0xff | rnds[10] & 0x07;\n\n  // [bytes 11-15] always random\n  b[i++] = rnds[11];\n  b[i++] = rnds[12];\n  b[i++] = rnds[13];\n  b[i++] = rnds[14];\n  b[i++] = rnds[15];\n  return buf || (0, _stringify.unsafeStringify)(b);\n}\nvar _default = exports[\"default\"] = v7;\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/v7.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/validate.js":
/*!*************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/validate.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _regex = _interopRequireDefault(__webpack_require__(/*! ./regex.js */ \"./node_modules/uuid/dist/commonjs-browser/regex.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex.default.test(uuid);\n}\nvar _default = exports[\"default\"] = validate;\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/validate.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/version.js":
/*!************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/version.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/commonjs-browser/validate.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction version(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  return parseInt(uuid.slice(14, 15), 16);\n}\nvar _default = exports[\"default\"] = version;\n\n//# sourceURL=webpack://ispace/./node_modules/uuid/dist/commonjs-browser/version.js?");

/***/ }),

/***/ "./node_modules/axios/dist/browser/axios.cjs":
/*!***************************************************!*\
  !*** ./node_modules/axios/dist/browser/axios.cjs ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Axios v1.7.2 Copyright (c) 2024 Matt Zabriskie and contributors\n\n\nfunction bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {toString} = Object.prototype;\nconst {getPrototypeOf} = Object;\n\nconst kindOf = (cache => thing => {\n    const str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type) => {\n  type = type.toLowerCase();\n  return (thing) => kindOf(thing) === type\n};\n\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {isArray} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest('undefined');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest('string');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction = typeOfTest('function');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest('number');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = (thing) => thing !== null && typeof thing === 'object';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = (val) => {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);\n};\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = (thing) => {\n  let kind;\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) || (\n      isFunction(thing.append) && (\n        (kind = kindOf(thing)) === 'formdata' ||\n        // detect form-data instance\n        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')\n      )\n    )\n  )\n};\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest('URLSearchParams');\n\nconst [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = (str) => str.trim ?\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\n\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : __webpack_require__.g)\n})();\n\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  const {caseless} = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  };\n\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {allOwnKeys});\n  return a;\n};\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = (content) => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n};\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n};\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n};\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n};\n\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = (thing) => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n};\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[Symbol.iterator];\n\n  const iterator = generator.call(obj);\n\n  let result;\n\n  while ((result = iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n};\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n};\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest('HTMLFormElement');\n\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g,\n    function replacer(m, p1, p2) {\n      return p1.toUpperCase() + p2;\n    }\n  );\n};\n\n/* Creating a function that will check if an object has a property. */\nconst hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest('RegExp');\n\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n\n  forEach(descriptors, (descriptor, name) => {\n    let ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n\n  Object.defineProperties(obj, reducedDescriptors);\n};\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = (obj) => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    const value = obj[name];\n\n    if (!isFunction(value)) return;\n\n    descriptor.enumerable = false;\n\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n};\n\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n\n  const define = (arr) => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  };\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n\n  return obj;\n};\n\nconst noop = () => {};\n\nconst toFiniteNumber = (value, defaultValue) => {\n  return value != null && Number.isFinite(value = +value) ? value : defaultValue;\n};\n\nconst ALPHA = 'abcdefghijklmnopqrstuvwxyz';\n\nconst DIGIT = '0123456789';\n\nconst ALPHABET = {\n  DIGIT,\n  ALPHA,\n  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT\n};\n\nconst generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {\n  let str = '';\n  const {length} = alphabet;\n  while (size--) {\n    str += alphabet[Math.random() * length|0];\n  }\n\n  return str;\n};\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);\n}\n\nconst toJSONObject = (obj) => {\n  const stack = new Array(10);\n\n  const visit = (source, i) => {\n\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      if(!('toJSON' in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n\n        stack[i] = undefined;\n\n        return target;\n      }\n    }\n\n    return source;\n  };\n\n  return visit(obj, 0);\n};\n\nconst isAsyncFn = kindOfTest('AsyncFunction');\n\nconst isThenable = (thing) =>\n  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n\nvar utils$1 = {\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isReadableStream,\n  isRequest,\n  isResponse,\n  isHeaders,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty,\n  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  ALPHABET,\n  generateString,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable\n};\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  response && (this.response = response);\n}\n\nutils$1.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: utils$1.toJSONObject(this.config),\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }\n});\n\nconst prototype$1 = AxiosError.prototype;\nconst descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED',\n  'ERR_NOT_SUPPORT',\n  'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype$1, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(prototype$1);\n\n  utils$1.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== 'isAxiosError';\n  });\n\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n\n  axiosError.cause = error;\n\n  axiosError.name = error.name;\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\n// eslint-disable-next-line strict\nvar httpAdapter = null;\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils$1.isArray(arr) && !arr.some(isVisitable);\n}\n\nconst predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils$1.isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils$1.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils$1.isUndefined(source[option]);\n  });\n\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);\n\n  if (!utils$1.isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils$1.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (!useBlob && utils$1.isBlob(value)) {\n      throw new AxiosError('Blob is not supported. Use a Buffer instead.');\n    }\n\n    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n\n    if (value && !path && typeof value === 'object') {\n      if (utils$1.endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (utils$1.isArray(value) && isFlatArray(value)) ||\n        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !(utils$1.isUndefined(el) || el === null) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  const stack = [];\n\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n\n  function build(value, path) {\n    if (utils$1.isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n\n    stack.push(value);\n\n    utils$1.forEach(value, function each(el, key) {\n      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(\n        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!utils$1.isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode$1(str) {\n  const charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && toFormData(params, this, options);\n}\n\nconst prototype = AxiosURLSearchParams.prototype;\n\nprototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nprototype.toString = function toString(encoder) {\n  const _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode$1);\n  } : encode$1;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?object} options\n *\n * @returns {string} The formatted url\n */\nfunction buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  \n  const _encode = options && options.encode || encode;\n\n  const serializeFn = options && options.serialize;\n\n  let serializedParams;\n\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils$1.isURLSearchParams(params) ?\n      params.toString() :\n      new AxiosURLSearchParams(params, options).toString(_encode);\n  }\n\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf(\"#\");\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n}\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    utils$1.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n\nvar InterceptorManager$1 = InterceptorManager;\n\nvar transitionalDefaults = {\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n};\n\nvar URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;\n\nvar FormData$1 = typeof FormData !== 'undefined' ? FormData : null;\n\nvar Blob$1 = typeof Blob !== 'undefined' ? Blob : null;\n\nvar platform$1 = {\n  isBrowser: true,\n  classes: {\n    URLSearchParams: URLSearchParams$1,\n    FormData: FormData$1,\n    Blob: Blob$1\n  },\n  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n};\n\nconst hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */\nconst hasStandardBrowserEnv = (\n  (product) => {\n    return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0\n  })(typeof navigator !== 'undefined' && navigator.product);\n\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nconst hasStandardBrowserWebWorkerEnv = (() => {\n  return (\n    typeof WorkerGlobalScope !== 'undefined' &&\n    // eslint-disable-next-line no-undef\n    self instanceof WorkerGlobalScope &&\n    typeof self.importScripts === 'function'\n  );\n})();\n\nconst origin = hasBrowserEnv && window.location.href || 'http://localhost';\n\nvar utils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  hasBrowserEnv: hasBrowserEnv,\n  hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,\n  hasStandardBrowserEnv: hasStandardBrowserEnv,\n  origin: origin\n});\n\nvar platform = {\n  ...utils,\n  ...platform$1\n};\n\nfunction toURLEncodedForm(data, options) {\n  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({\n    visitor: function(value, key, path, helpers) {\n      if (platform.isNode && utils$1.isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    }\n  }, options));\n}\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils$1.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n\n    if (name === '__proto__') return true;\n\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && utils$1.isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (utils$1.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !utils$1.isObject(target[name])) {\n      target[name] = [];\n    }\n\n    const result = buildPath(path, value, target[name], index);\n\n    if (result && utils$1.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {\n    const obj = {};\n\n    utils$1.forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils$1.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils$1.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nconst defaults = {\n\n  transitional: transitionalDefaults,\n\n  adapter: ['xhr', 'http', 'fetch'],\n\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || '';\n    const hasJSONContentType = contentType.indexOf('application/json') > -1;\n    const isObjectPayload = utils$1.isObject(data);\n\n    if (isObjectPayload && utils$1.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    const isFormData = utils$1.isFormData(data);\n\n    if (isFormData) {\n      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n    }\n\n    if (utils$1.isArrayBuffer(data) ||\n      utils$1.isBuffer(data) ||\n      utils$1.isStream(data) ||\n      utils$1.isFile(data) ||\n      utils$1.isBlob(data) ||\n      utils$1.isReadableStream(data)\n    ) {\n      return data;\n    }\n    if (utils$1.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils$1.isURLSearchParams(data)) {\n      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n      return data.toString();\n    }\n\n    let isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        const _FormData = this.env && this.env.FormData;\n\n        return toFormData(\n          isFileList ? {'files[]': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      headers.setContentType('application/json', false);\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === 'json';\n\n    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {\n      return data;\n    }\n\n    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*',\n      'Content-Type': undefined\n    }\n  }\n};\n\nutils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {\n  defaults.headers[method] = {};\n});\n\nvar defaults$1 = defaults;\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils$1.toObjectSet([\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n]);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\nvar parseHeaders = rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n\n  rawHeaders && rawHeaders.split('\\n').forEach(function parser(line) {\n    i = line.indexOf(':');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n\n    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {\n      return;\n    }\n\n    if (key === 'set-cookie') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils$1.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils$1.isString(value)) return;\n\n  if (utils$1.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils$1.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils$1.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils$1.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite);\n    } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else if (utils$1.isHeaders(header)) {\n      for (const [key, value] of header.entries()) {\n        setHeader(value, key, rewrite);\n      }\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils$1.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils$1.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils$1.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils$1.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils$1.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils$1.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils$1.forEach(this, (value, header) => {\n      const key = utils$1.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils$1.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\nutils$1.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\nutils$1.freezeMethods(AxiosHeaders);\n\nvar AxiosHeaders$1 = AxiosHeaders;\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nfunction transformData(fns, response) {\n  const config = this || defaults$1;\n  const context = response || config;\n  const headers = AxiosHeaders$1.from(context.headers);\n  let data = context.data;\n\n  utils$1.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n\n  headers.normalize();\n\n  return data;\n}\n\nfunction isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\n\nutils$1.inherits(CanceledError, AxiosError, {\n  __CANCEL__: true\n});\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nfunction settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new AxiosError(\n      'Request failed with status code ' + response.status,\n      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n}\n\nfunction parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n}\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\n/**\n * Throttle decorator\n * @param {Function} fn\n * @param {Number} freq\n * @return {Function}\n */\nfunction throttle(fn, freq) {\n  let timestamp = 0;\n  const threshold = 1000 / freq;\n  let timer = null;\n  return function throttled() {\n    const force = this === true;\n\n    const now = Date.now();\n    if (force || now - timestamp > threshold) {\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      timestamp = now;\n      return fn.apply(null, arguments);\n    }\n    if (!timer) {\n      timer = setTimeout(() => {\n        timer = null;\n        timestamp = Date.now();\n        return fn.apply(null, arguments);\n      }, threshold - (now - timestamp));\n    }\n  };\n}\n\nvar progressEventReducer = (listener, isDownloadStream, freq = 3) => {\n  let bytesNotified = 0;\n  const _speedometer = speedometer(50, 250);\n\n  return throttle(e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n\n    bytesNotified = loaded;\n\n    const data = {\n      loaded,\n      total,\n      progress: total ? (loaded / total) : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e,\n      lengthComputable: total != null\n    };\n\n    data[isDownloadStream ? 'download' : 'upload'] = true;\n\n    listener(data);\n  }, freq);\n};\n\nvar isURLSameOrigin = platform.hasStandardBrowserEnv ?\n\n// Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    const msie = /(msie|trident)/i.test(navigator.userAgent);\n    const urlParsingNode = document.createElement('a');\n    let originURL;\n\n    /**\n    * Parse a URL to discover its components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      let href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n          urlParsingNode.pathname :\n          '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      const parsed = (utils$1.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n          parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })();\n\nvar cookies = platform.hasStandardBrowserEnv ?\n\n  // Standard browser envs support document.cookie\n  {\n    write(name, value, expires, path, domain, secure) {\n      const cookie = [name + '=' + encodeURIComponent(value)];\n\n      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());\n\n      utils$1.isString(path) && cookie.push('path=' + path);\n\n      utils$1.isString(domain) && cookie.push('domain=' + domain);\n\n      secure === true && cookie.push('secure');\n\n      document.cookie = cookie.join('; ');\n    },\n\n    read(name) {\n      const match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return (match ? decodeURIComponent(match[3]) : null);\n    },\n\n    remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  }\n\n  :\n\n  // Non-standard browser env (web workers, react-native) lack needed support.\n  {\n    write() {},\n    read() {\n      return null;\n    },\n    remove() {}\n  };\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nfunction isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nfunction combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/?\\/$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n}\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nfunction buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n\nconst headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nfunction mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n\n  function getMergedValue(target, source, caseless) {\n    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {\n      return utils$1.merge.call({caseless}, target, source);\n    } else if (utils$1.isPlainObject(source)) {\n      return utils$1.merge({}, source);\n    } else if (utils$1.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, caseless) {\n    if (!utils$1.isUndefined(b)) {\n      return getMergedValue(a, b, caseless);\n    } else if (!utils$1.isUndefined(a)) {\n      return getMergedValue(undefined, a, caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils$1.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils$1.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils$1.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    withXSRFToken: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)\n  };\n\n  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n}\n\nvar resolveConfig = (config) => {\n  const newConfig = mergeConfig({}, config);\n\n  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;\n\n  newConfig.headers = headers = AxiosHeaders$1.from(headers);\n\n  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);\n\n  // HTTP basic authentication\n  if (auth) {\n    headers.set('Authorization', 'Basic ' +\n      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))\n    );\n  }\n\n  let contentType;\n\n  if (utils$1.isFormData(data)) {\n    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {\n      headers.setContentType(undefined); // Let the browser set it\n    } else if ((contentType = headers.getContentType()) !== false) {\n      // fix semicolon duplication issue for ReactNative FormData implementation\n      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];\n      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));\n    }\n  }\n\n  // Add xsrf header\n  // This is only done if running in a standard browser environment.\n  // Specifically not if we're in a web worker, or react-native.\n\n  if (platform.hasStandardBrowserEnv) {\n    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));\n\n    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {\n      // Add xsrf header\n      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);\n\n      if (xsrfValue) {\n        headers.set(xsrfHeaderName, xsrfValue);\n      }\n    }\n  }\n\n  return newConfig;\n};\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\nvar xhrAdapter = isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    const _config = resolveConfig(config);\n    let requestData = _config.data;\n    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();\n    let {responseType} = _config;\n    let onCanceled;\n    function done() {\n      if (_config.cancelToken) {\n        _config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (_config.signal) {\n        _config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    let request = new XMLHttpRequest();\n\n    request.open(_config.method.toUpperCase(), _config.url, true);\n\n    // Set the request timeout in MS\n    request.timeout = _config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = AxiosHeaders$1.from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, _config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, _config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = _config.transitional || transitionalDefaults;\n      if (_config.timeoutErrorMessage) {\n        timeoutErrorMessage = _config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        _config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils$1.isUndefined(_config.withCredentials)) {\n      request.withCredentials = !!_config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = _config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof _config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', progressEventReducer(_config.onDownloadProgress, true));\n    }\n\n    // Not all browsers support upload events\n    if (typeof _config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', progressEventReducer(_config.onUploadProgress));\n    }\n\n    if (_config.cancelToken || _config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);\n      if (_config.signal) {\n        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(_config.url);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n};\n\nconst composeSignals = (signals, timeout) => {\n  let controller = new AbortController();\n\n  let aborted;\n\n  const onabort = function (cancel) {\n    if (!aborted) {\n      aborted = true;\n      unsubscribe();\n      const err = cancel instanceof Error ? cancel : this.reason;\n      controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));\n    }\n  };\n\n  let timer = timeout && setTimeout(() => {\n    onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));\n  }, timeout);\n\n  const unsubscribe = () => {\n    if (signals) {\n      timer && clearTimeout(timer);\n      timer = null;\n      signals.forEach(signal => {\n        signal &&\n        (signal.removeEventListener ? signal.removeEventListener('abort', onabort) : signal.unsubscribe(onabort));\n      });\n      signals = null;\n    }\n  };\n\n  signals.forEach((signal) => signal && signal.addEventListener && signal.addEventListener('abort', onabort));\n\n  const {signal} = controller;\n\n  signal.unsubscribe = unsubscribe;\n\n  return [signal, () => {\n    timer && clearTimeout(timer);\n    timer = null;\n  }];\n};\n\nvar composeSignals$1 = composeSignals;\n\nconst streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n};\n\nconst readBytes = async function* (iterable, chunkSize, encode) {\n  for await (const chunk of iterable) {\n    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : (await encode(String(chunk))), chunkSize);\n  }\n};\n\nconst trackStream = (stream, chunkSize, onProgress, onFinish, encode) => {\n  const iterator = readBytes(stream, chunkSize, encode);\n\n  let bytes = 0;\n\n  return new ReadableStream({\n    type: 'bytes',\n\n    async pull(controller) {\n      const {done, value} = await iterator.next();\n\n      if (done) {\n        controller.close();\n        onFinish();\n        return;\n      }\n\n      let len = value.byteLength;\n      onProgress && onProgress(bytes += len);\n      controller.enqueue(new Uint8Array(value));\n    },\n    cancel(reason) {\n      onFinish(reason);\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  })\n};\n\nconst fetchProgressDecorator = (total, fn) => {\n  const lengthComputable = total != null;\n  return (loaded) => setTimeout(() => fn({\n    lengthComputable,\n    total,\n    loaded\n  }));\n};\n\nconst isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';\nconst isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';\n\n// used only inside the fetch adapter\nconst encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\n    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n    async (str) => new Uint8Array(await new Response(str).arrayBuffer())\n);\n\nconst supportsRequestStream = isReadableStreamSupported && (() => {\n  let duplexAccessed = false;\n\n  const hasContentType = new Request(platform.origin, {\n    body: new ReadableStream(),\n    method: 'POST',\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    },\n  }).headers.has('Content-Type');\n\n  return duplexAccessed && !hasContentType;\n})();\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst supportsResponseStream = isReadableStreamSupported && !!(()=> {\n  try {\n    return utils$1.isReadableStream(new Response('').body);\n  } catch(err) {\n    // return undefined\n  }\n})();\n\nconst resolvers = {\n  stream: supportsResponseStream && ((res) => res.body)\n};\n\nisFetchSupported && (((res) => {\n  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res) => res[type]() :\n      (_, config) => {\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n      });\n  });\n})(new Response));\n\nconst getBodyLength = async (body) => {\n  if (body == null) {\n    return 0;\n  }\n\n  if(utils$1.isBlob(body)) {\n    return body.size;\n  }\n\n  if(utils$1.isSpecCompliantForm(body)) {\n    return (await new Request(body).arrayBuffer()).byteLength;\n  }\n\n  if(utils$1.isArrayBufferView(body)) {\n    return body.byteLength;\n  }\n\n  if(utils$1.isURLSearchParams(body)) {\n    body = body + '';\n  }\n\n  if(utils$1.isString(body)) {\n    return (await encodeText(body)).byteLength;\n  }\n};\n\nconst resolveBodyLength = async (headers, body) => {\n  const length = utils$1.toFiniteNumber(headers.getContentLength());\n\n  return length == null ? getBodyLength(body) : length;\n};\n\nvar fetchAdapter = isFetchSupported && (async (config) => {\n  let {\n    url,\n    method,\n    data,\n    signal,\n    cancelToken,\n    timeout,\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    headers,\n    withCredentials = 'same-origin',\n    fetchOptions\n  } = resolveConfig(config);\n\n  responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n\n  let [composedSignal, stopTimeout] = (signal || cancelToken || timeout) ?\n    composeSignals$1([signal, cancelToken], timeout) : [];\n\n  let finished, request;\n\n  const onFinish = () => {\n    !finished && setTimeout(() => {\n      composedSignal && composedSignal.unsubscribe();\n    });\n\n    finished = true;\n  };\n\n  let requestContentLength;\n\n  try {\n    if (\n      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\n      (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n    ) {\n      let _request = new Request(url, {\n        method: 'POST',\n        body: data,\n        duplex: \"half\"\n      });\n\n      let contentTypeHeader;\n\n      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n        headers.setContentType(contentTypeHeader);\n      }\n\n      if (_request.body) {\n        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(\n          requestContentLength,\n          progressEventReducer(onUploadProgress)\n        ), null, encodeText);\n      }\n    }\n\n    if (!utils$1.isString(withCredentials)) {\n      withCredentials = withCredentials ? 'cors' : 'omit';\n    }\n\n    request = new Request(url, {\n      ...fetchOptions,\n      signal: composedSignal,\n      method: method.toUpperCase(),\n      headers: headers.normalize().toJSON(),\n      body: data,\n      duplex: \"half\",\n      withCredentials\n    });\n\n    let response = await fetch(request);\n\n    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {\n      const options = {};\n\n      ['status', 'statusText', 'headers'].forEach(prop => {\n        options[prop] = response[prop];\n      });\n\n      const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));\n\n      response = new Response(\n        trackStream(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(\n          responseContentLength,\n          progressEventReducer(onDownloadProgress, true)\n        ), isStreamResponse && onFinish, encodeText),\n        options\n      );\n    }\n\n    responseType = responseType || 'text';\n\n    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);\n\n    !isStreamResponse && onFinish();\n\n    stopTimeout && stopTimeout();\n\n    return await new Promise((resolve, reject) => {\n      settle(resolve, reject, {\n        data: responseData,\n        headers: AxiosHeaders$1.from(response.headers),\n        status: response.status,\n        statusText: response.statusText,\n        config,\n        request\n      });\n    })\n  } catch (err) {\n    onFinish();\n\n    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {\n      throw Object.assign(\n        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),\n        {\n          cause: err.cause || err\n        }\n      )\n    }\n\n    throw AxiosError.from(err, err && err.code, config, request);\n  }\n});\n\nconst knownAdapters = {\n  http: httpAdapter,\n  xhr: xhrAdapter,\n  fetch: fetchAdapter\n};\n\nutils$1.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', {value});\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', {value});\n  }\n});\n\nconst renderReason = (reason) => `- ${reason}`;\n\nconst isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;\n\nvar adapters = {\n  getAdapter: (adapters) => {\n    adapters = utils$1.isArray(adapters) ? adapters : [adapters];\n\n    const {length} = adapters;\n    let nameOrAdapter;\n    let adapter;\n\n    const rejectedReasons = {};\n\n    for (let i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      let id;\n\n      adapter = nameOrAdapter;\n\n      if (!isResolvedHandle(nameOrAdapter)) {\n        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n\n        if (adapter === undefined) {\n          throw new AxiosError(`Unknown adapter '${id}'`);\n        }\n      }\n\n      if (adapter) {\n        break;\n      }\n\n      rejectedReasons[id || '#' + i] = adapter;\n    }\n\n    if (!adapter) {\n\n      const reasons = Object.entries(rejectedReasons)\n        .map(([id, state]) => `adapter ${id} ` +\n          (state === false ? 'is not supported by the environment' : 'is not available in the build')\n        );\n\n      let s = length ?\n        (reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0])) :\n        'as no adapter specified';\n\n      throw new AxiosError(\n        `There is no suitable adapter to dispatch the request ` + s,\n        'ERR_NOT_SUPPORT'\n      );\n    }\n\n    return adapter;\n  },\n  adapters: knownAdapters\n};\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new CanceledError(null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nfunction dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  config.headers = AxiosHeaders$1.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.transformRequest\n  );\n\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }\n\n  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      config.transformResponse,\n      response\n    );\n\n    response.headers = AxiosHeaders$1.from(response.headers);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          config.transformResponse,\n          reason.response\n        );\n        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n}\n\nconst VERSION = \"1.7.2\";\n\nconst validators$1 = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {\n  validators$1[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators$1.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new AxiosError(\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\nvar validator = {\n  assertOptions,\n  validators: validators$1\n};\n\nconst validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig;\n    this.interceptors = {\n      request: new InterceptorManager$1(),\n      response: new InterceptorManager$1()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  async request(configOrUrl, config) {\n    try {\n      return await this._request(configOrUrl, config);\n    } catch (err) {\n      if (err instanceof Error) {\n        let dummy;\n\n        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : (dummy = new Error());\n\n        // slice off the Error: ... line\n        const stack = dummy.stack ? dummy.stack.replace(/^.+\\n/, '') : '';\n        try {\n          if (!err.stack) {\n            err.stack = stack;\n            // match without the 2 top stack lines\n          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\\n.+\\n/, ''))) {\n            err.stack += '\\n' + stack;\n          }\n        } catch (e) {\n          // ignore the case where \"stack\" is an un-writable property\n        }\n      }\n\n      throw err;\n    }\n  }\n\n  _request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios('example/url'[, config]) a la fetch API\n    if (typeof configOrUrl === 'string') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n\n    config = mergeConfig(this.defaults, config);\n\n    const {transitional, paramsSerializer, headers} = config;\n\n    if (transitional !== undefined) {\n      validator.assertOptions(transitional, {\n        silentJSONParsing: validators.transitional(validators.boolean),\n        forcedJSONParsing: validators.transitional(validators.boolean),\n        clarifyTimeoutError: validators.transitional(validators.boolean)\n      }, false);\n    }\n\n    if (paramsSerializer != null) {\n      if (utils$1.isFunction(paramsSerializer)) {\n        config.paramsSerializer = {\n          serialize: paramsSerializer\n        };\n      } else {\n        validator.assertOptions(paramsSerializer, {\n          encode: validators.function,\n          serialize: validators.function\n        }, true);\n      }\n    }\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n\n    // Flatten headers\n    let contextHeaders = headers && utils$1.merge(\n      headers.common,\n      headers[config.method]\n    );\n\n    headers && utils$1.forEach(\n      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n      (method) => {\n        delete headers[method];\n      }\n    );\n\n    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n        return;\n      }\n\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    let promise;\n    let i = 0;\n    let len;\n\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift.apply(chain, requestInterceptorChain);\n      chain.push.apply(chain, responseInterceptorChain);\n      len = chain.length;\n\n      promise = Promise.resolve(config);\n\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n\n      return promise;\n    }\n\n    len = requestInterceptorChain.length;\n\n    let newConfig = config;\n\n    i = 0;\n\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    i = 0;\n    len = responseInterceptorChain.length;\n\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n\n    return promise;\n  }\n\n  getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    return buildURL(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\nutils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\nvar Axios$1 = Axios;\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\nvar CancelToken$1 = CancelToken;\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nfunction spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nfunction isAxiosError(payload) {\n  return utils$1.isObject(payload) && (payload.isAxiosError === true);\n}\n\nconst HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511,\n};\n\nObject.entries(HttpStatusCode).forEach(([key, value]) => {\n  HttpStatusCode[value] = key;\n});\n\nvar HttpStatusCode$1 = HttpStatusCode;\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new Axios$1(defaultConfig);\n  const instance = bind(Axios$1.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});\n\n  // Copy context to instance\n  utils$1.extend(instance, context, null, {allOwnKeys: true});\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios = createInstance(defaults$1);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios$1;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = CanceledError;\naxios.CancelToken = CancelToken$1;\naxios.isCancel = isCancel;\naxios.VERSION = VERSION;\naxios.toFormData = toFormData;\n\n// Expose AxiosError class\naxios.AxiosError = AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = spread;\n\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError;\n\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig;\n\naxios.AxiosHeaders = AxiosHeaders$1;\n\naxios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);\n\naxios.getAdapter = adapters.getAdapter;\n\naxios.HttpStatusCode = HttpStatusCode$1;\n\naxios.default = axios;\n\nmodule.exports = axios;\n//# sourceMappingURL=axios.cjs.map\n\n\n//# sourceURL=webpack://ispace/./node_modules/axios/dist/browser/axios.cjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_704310__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_704310__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__nested_webpack_require_704310__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_704310__("./src/core.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3JjX2Fzc2V0X3RzX3Rlc3RfdHMuOWUwYmExMTRkMDhmZWE4NTM5OGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXVDO0FBRWhDLE1BQU0sSUFBSTtJQUliO1FBQ0ksa0RBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFDLFVBQVUsQ0FBQyxDQUFDLFNBQVMsQ0FBRSxHQUFHLENBQUMsRUFBRTtZQUMzQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztRQUNwQixDQUFDLENBQUM7UUFDRixJQUFJLENBQUMsSUFBSSxHQUFHLE1BQU07UUFDbEIsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQzFCLENBQUM7Q0FDSjs7Ozs7Ozs7Ozs7QUNiRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUt1QjtBQUM3QixDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5R0FBeUcsbUNBQW1DLHFDQUFxQyxvQ0FBb0MsZ0JBQWdCLEVBQUUsR0FBRyw0QkFBNEIsbUNBQW1DLG1CQUFtQixHQUFHLEdBQUcsMEVBQTBFLGtJQUFrSSxJQUFJLG9EQUFvRCxhQUFhLEdBQUcsa25DQUFrbkMscytCQUFzK0IsczhCQUFzOEIsc2RBQXNkLCtIQUErSCxvREFBb0QscUNBQXFDLG1DQUFtQyxHQUFHLHNMQUFzTCwrREFBK0QscUNBQXFDLHlEQUF5RCxHQUFHLDZJQUE2SSxvREFBb0QscUNBQXFDLG1DQUFtQyxHQUFHLDRLQUE0Syx5REFBeUQscUNBQXFDLDZDQUE2QyxHQUFHLHNIQUFzSCxpREFBaUQscUNBQXFDLDZCQUE2QixHQUFHLDhJQUE4SSx5REFBeUQscUNBQXFDLDZDQUE2QyxHQUFHLHdJQUF3SSx1REFBdUQscUNBQXFDLHlDQUF5QyxHQUFHLHFJQUFxSSxzREFBc0QscUNBQXFDLHVDQUF1QyxHQUFHLGlJQUFp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QTtBQUNBLFlBQVk7QUFDWixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQkFBbUIsR0FBRyxpQ0FBbUI7QUFDdkQ7QUFDQSxpQkFBaUIsMEJBQW1CO0FBQ3BDLFVBQVU7QUFDVjtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXNrdG9wLy4vc3JjL2Fzc2V0L3RzL3Rlc3QudHMiLCJ3ZWJwYWNrOi8vZGVza3RvcC8uLi8uLi9jb3JlL2Zyb250L2Rpc3QvY29yZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhdXRoIH0gZnJvbSBcImlzcGFjZS5jb3JlLm1haW5cIlxuXG5leHBvcnQgY2xhc3MgVGVzdCB7XG4gICAgbmFtZTogc3RyaW5nXG4gICAgdmVyc2lvbjogc3RyaW5nXG4gICAgdmVyc2lvbjI/OiBzdHJpbmdcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgYXV0aC5sb2dpbihcImFsZWlcIixcIjFxYXpAV1NYXCIpLnN1YnNjcmliZSggcmVzID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlcykgICAgXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMubmFtZSA9IFwidGVzdFwiXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IFwiMS4wLjBcIlxuICAgIH1cbn0iLCIvKlxuICogQVRURU5USU9OOiBUaGUgXCJldmFsXCIgZGV2dG9vbCBoYXMgYmVlbiB1c2VkIChtYXliZSBieSBkZWZhdWx0IGluIG1vZGU6IFwiZGV2ZWxvcG1lbnRcIikuXG4gKiBUaGlzIGRldnRvb2wgaXMgbmVpdGhlciBtYWRlIGZvciBwcm9kdWN0aW9uIG5vciBmb3IgcmVhZGFibGUgb3V0cHV0IGZpbGVzLlxuICogSXQgdXNlcyBcImV2YWwoKVwiIGNhbGxzIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIHNvdXJjZSBmaWxlIGluIHRoZSBicm93c2VyIGRldnRvb2xzLlxuICogSWYgeW91IGFyZSB0cnlpbmcgdG8gcmVhZCB0aGUgb3V0cHV0IGZpbGUsIHNlbGVjdCBhIGRpZmZlcmVudCBkZXZ0b29sIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vZGV2dG9vbC8pXG4gKiBvciBkaXNhYmxlIHRoZSBkZWZhdWx0IGRldnRvb2wgd2l0aCBcImRldnRvb2w6IGZhbHNlXCIuXG4gKiBJZiB5b3UgYXJlIGxvb2tpbmcgZm9yIHByb2R1Y3Rpb24tcmVhZHkgb3V0cHV0IGZpbGVzLCBzZWUgbW9kZTogXCJwcm9kdWN0aW9uXCIgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9tb2RlLykuXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImlzcGFjZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJpc3BhY2VcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCAoKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XFxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XFxuICAgIG9bazJdID0gbVtrXTtcXG59KSk7XFxudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XFxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFxcXCJkZWZhdWx0XFxcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XFxufTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5pbnRlcnZhbCA9IGV4cG9ydHMuaWlmID0gZXhwb3J0cy5nZW5lcmF0ZSA9IGV4cG9ydHMuZnJvbUV2ZW50UGF0dGVybiA9IGV4cG9ydHMuZnJvbUV2ZW50ID0gZXhwb3J0cy5mcm9tID0gZXhwb3J0cy5mb3JrSm9pbiA9IGV4cG9ydHMuZW1wdHkgPSBleHBvcnRzLmRlZmVyID0gZXhwb3J0cy5jb25uZWN0YWJsZSA9IGV4cG9ydHMuY29uY2F0ID0gZXhwb3J0cy5jb21iaW5lTGF0ZXN0ID0gZXhwb3J0cy5iaW5kTm9kZUNhbGxiYWNrID0gZXhwb3J0cy5iaW5kQ2FsbGJhY2sgPSBleHBvcnRzLlVuc3Vic2NyaXB0aW9uRXJyb3IgPSBleHBvcnRzLlRpbWVvdXRFcnJvciA9IGV4cG9ydHMuU2VxdWVuY2VFcnJvciA9IGV4cG9ydHMuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSBleHBvcnRzLk5vdEZvdW5kRXJyb3IgPSBleHBvcnRzLkVtcHR5RXJyb3IgPSBleHBvcnRzLkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yID0gZXhwb3J0cy5maXJzdFZhbHVlRnJvbSA9IGV4cG9ydHMubGFzdFZhbHVlRnJvbSA9IGV4cG9ydHMuaXNPYnNlcnZhYmxlID0gZXhwb3J0cy5pZGVudGl0eSA9IGV4cG9ydHMubm9vcCA9IGV4cG9ydHMucGlwZSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uS2luZCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TdWJzY3JpYmVyID0gZXhwb3J0cy5TdWJzY3JpcHRpb24gPSBleHBvcnRzLlNjaGVkdWxlciA9IGV4cG9ydHMuVmlydHVhbEFjdGlvbiA9IGV4cG9ydHMuVmlydHVhbFRpbWVTY2hlZHVsZXIgPSBleHBvcnRzLmFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyID0gZXhwb3J0cy5hbmltYXRpb25GcmFtZSA9IGV4cG9ydHMucXVldWVTY2hlZHVsZXIgPSBleHBvcnRzLnF1ZXVlID0gZXhwb3J0cy5hc3luY1NjaGVkdWxlciA9IGV4cG9ydHMuYXN5bmMgPSBleHBvcnRzLmFzYXBTY2hlZHVsZXIgPSBleHBvcnRzLmFzYXAgPSBleHBvcnRzLkFzeW5jU3ViamVjdCA9IGV4cG9ydHMuUmVwbGF5U3ViamVjdCA9IGV4cG9ydHMuQmVoYXZpb3JTdWJqZWN0ID0gZXhwb3J0cy5TdWJqZWN0ID0gZXhwb3J0cy5hbmltYXRpb25GcmFtZXMgPSBleHBvcnRzLm9ic2VydmFibGUgPSBleHBvcnRzLkNvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IGV4cG9ydHMuT2JzZXJ2YWJsZSA9IHZvaWQgMDtcXG5leHBvcnRzLmZpbHRlciA9IGV4cG9ydHMuZXhwYW5kID0gZXhwb3J0cy5leGhhdXN0TWFwID0gZXhwb3J0cy5leGhhdXN0QWxsID0gZXhwb3J0cy5leGhhdXN0ID0gZXhwb3J0cy5ldmVyeSA9IGV4cG9ydHMuZW5kV2l0aCA9IGV4cG9ydHMuZWxlbWVudEF0ID0gZXhwb3J0cy5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCA9IGV4cG9ydHMuZGlzdGluY3RVbnRpbENoYW5nZWQgPSBleHBvcnRzLmRpc3RpbmN0ID0gZXhwb3J0cy5kZW1hdGVyaWFsaXplID0gZXhwb3J0cy5kZWxheVdoZW4gPSBleHBvcnRzLmRlbGF5ID0gZXhwb3J0cy5kZWZhdWx0SWZFbXB0eSA9IGV4cG9ydHMuZGVib3VuY2VUaW1lID0gZXhwb3J0cy5kZWJvdW5jZSA9IGV4cG9ydHMuY291bnQgPSBleHBvcnRzLmNvbm5lY3QgPSBleHBvcnRzLmNvbmNhdFdpdGggPSBleHBvcnRzLmNvbmNhdE1hcFRvID0gZXhwb3J0cy5jb25jYXRNYXAgPSBleHBvcnRzLmNvbmNhdEFsbCA9IGV4cG9ydHMuY29tYmluZUxhdGVzdFdpdGggPSBleHBvcnRzLmNvbWJpbmVMYXRlc3RBbGwgPSBleHBvcnRzLmNvbWJpbmVBbGwgPSBleHBvcnRzLmNhdGNoRXJyb3IgPSBleHBvcnRzLmJ1ZmZlcldoZW4gPSBleHBvcnRzLmJ1ZmZlclRvZ2dsZSA9IGV4cG9ydHMuYnVmZmVyVGltZSA9IGV4cG9ydHMuYnVmZmVyQ291bnQgPSBleHBvcnRzLmJ1ZmZlciA9IGV4cG9ydHMuYXVkaXRUaW1lID0gZXhwb3J0cy5hdWRpdCA9IGV4cG9ydHMuY29uZmlnID0gZXhwb3J0cy5ORVZFUiA9IGV4cG9ydHMuRU1QVFkgPSBleHBvcnRzLnNjaGVkdWxlZCA9IGV4cG9ydHMuemlwID0gZXhwb3J0cy51c2luZyA9IGV4cG9ydHMudGltZXIgPSBleHBvcnRzLnRocm93RXJyb3IgPSBleHBvcnRzLnJhbmdlID0gZXhwb3J0cy5yYWNlID0gZXhwb3J0cy5wYXJ0aXRpb24gPSBleHBvcnRzLnBhaXJzID0gZXhwb3J0cy5vbkVycm9yUmVzdW1lTmV4dCA9IGV4cG9ydHMub2YgPSBleHBvcnRzLm5ldmVyID0gZXhwb3J0cy5tZXJnZSA9IHZvaWQgMDtcXG5leHBvcnRzLnN3aXRjaE1hcCA9IGV4cG9ydHMuc3dpdGNoQWxsID0gZXhwb3J0cy5zdWJzY3JpYmVPbiA9IGV4cG9ydHMuc3RhcnRXaXRoID0gZXhwb3J0cy5za2lwV2hpbGUgPSBleHBvcnRzLnNraXBVbnRpbCA9IGV4cG9ydHMuc2tpcExhc3QgPSBleHBvcnRzLnNraXAgPSBleHBvcnRzLnNpbmdsZSA9IGV4cG9ydHMuc2hhcmVSZXBsYXkgPSBleHBvcnRzLnNoYXJlID0gZXhwb3J0cy5zZXF1ZW5jZUVxdWFsID0gZXhwb3J0cy5zY2FuID0gZXhwb3J0cy5zYW1wbGVUaW1lID0gZXhwb3J0cy5zYW1wbGUgPSBleHBvcnRzLnJlZkNvdW50ID0gZXhwb3J0cy5yZXRyeVdoZW4gPSBleHBvcnRzLnJldHJ5ID0gZXhwb3J0cy5yZXBlYXRXaGVuID0gZXhwb3J0cy5yZXBlYXQgPSBleHBvcnRzLnJlZHVjZSA9IGV4cG9ydHMucmFjZVdpdGggPSBleHBvcnRzLnB1Ymxpc2hSZXBsYXkgPSBleHBvcnRzLnB1Ymxpc2hMYXN0ID0gZXhwb3J0cy5wdWJsaXNoQmVoYXZpb3IgPSBleHBvcnRzLnB1Ymxpc2ggPSBleHBvcnRzLnBsdWNrID0gZXhwb3J0cy5wYWlyd2lzZSA9IGV4cG9ydHMub25FcnJvclJlc3VtZU5leHRXaXRoID0gZXhwb3J0cy5vYnNlcnZlT24gPSBleHBvcnRzLm11bHRpY2FzdCA9IGV4cG9ydHMubWluID0gZXhwb3J0cy5tZXJnZVdpdGggPSBleHBvcnRzLm1lcmdlU2NhbiA9IGV4cG9ydHMubWVyZ2VNYXBUbyA9IGV4cG9ydHMubWVyZ2VNYXAgPSBleHBvcnRzLmZsYXRNYXAgPSBleHBvcnRzLm1lcmdlQWxsID0gZXhwb3J0cy5tYXggPSBleHBvcnRzLm1hdGVyaWFsaXplID0gZXhwb3J0cy5tYXBUbyA9IGV4cG9ydHMubWFwID0gZXhwb3J0cy5sYXN0ID0gZXhwb3J0cy5pc0VtcHR5ID0gZXhwb3J0cy5pZ25vcmVFbGVtZW50cyA9IGV4cG9ydHMuZ3JvdXBCeSA9IGV4cG9ydHMuZmlyc3QgPSBleHBvcnRzLmZpbmRJbmRleCA9IGV4cG9ydHMuZmluZCA9IGV4cG9ydHMuZmluYWxpemUgPSB2b2lkIDA7XFxuZXhwb3J0cy56aXBXaXRoID0gZXhwb3J0cy56aXBBbGwgPSBleHBvcnRzLndpdGhMYXRlc3RGcm9tID0gZXhwb3J0cy53aW5kb3dXaGVuID0gZXhwb3J0cy53aW5kb3dUb2dnbGUgPSBleHBvcnRzLndpbmRvd1RpbWUgPSBleHBvcnRzLndpbmRvd0NvdW50ID0gZXhwb3J0cy53aW5kb3cgPSBleHBvcnRzLnRvQXJyYXkgPSBleHBvcnRzLnRpbWVzdGFtcCA9IGV4cG9ydHMudGltZW91dFdpdGggPSBleHBvcnRzLnRpbWVvdXQgPSBleHBvcnRzLnRpbWVJbnRlcnZhbCA9IGV4cG9ydHMudGhyb3dJZkVtcHR5ID0gZXhwb3J0cy50aHJvdHRsZVRpbWUgPSBleHBvcnRzLnRocm90dGxlID0gZXhwb3J0cy50YXAgPSBleHBvcnRzLnRha2VXaGlsZSA9IGV4cG9ydHMudGFrZVVudGlsID0gZXhwb3J0cy50YWtlTGFzdCA9IGV4cG9ydHMudGFrZSA9IGV4cG9ydHMuc3dpdGNoU2NhbiA9IGV4cG9ydHMuc3dpdGNoTWFwVG8gPSB2b2lkIDA7XFxudmFyIE9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvT2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJPYnNlcnZhYmxlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZTsgfSB9KSk7XFxudmFyIENvbm5lY3RhYmxlT2JzZXJ2YWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiQ29ubmVjdGFibGVPYnNlcnZhYmxlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDb25uZWN0YWJsZU9ic2VydmFibGVfMS5Db25uZWN0YWJsZU9ic2VydmFibGU7IH0gfSkpO1xcbnZhciBvYnNlcnZhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL3N5bWJvbC9vYnNlcnZhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3N5bWJvbC9vYnNlcnZhYmxlLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJvYnNlcnZhYmxlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvYnNlcnZhYmxlXzEub2JzZXJ2YWJsZTsgfSB9KSk7XFxudmFyIGFuaW1hdGlvbkZyYW1lc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vYnNlcnZhYmxlL2RvbS9hbmltYXRpb25GcmFtZXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9kb20vYW5pbWF0aW9uRnJhbWVzLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJhbmltYXRpb25GcmFtZXNcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFuaW1hdGlvbkZyYW1lc18xLmFuaW1hdGlvbkZyYW1lczsgfSB9KSk7XFxudmFyIFN1YmplY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvU3ViamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJqZWN0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJTdWJqZWN0XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTdWJqZWN0XzEuU3ViamVjdDsgfSB9KSk7XFxudmFyIEJlaGF2aW9yU3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9CZWhhdmlvclN1YmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvQmVoYXZpb3JTdWJqZWN0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJCZWhhdmlvclN1YmplY3RcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJlaGF2aW9yU3ViamVjdF8xLkJlaGF2aW9yU3ViamVjdDsgfSB9KSk7XFxudmFyIFJlcGxheVN1YmplY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvUmVwbGF5U3ViamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9SZXBsYXlTdWJqZWN0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJSZXBsYXlTdWJqZWN0XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBSZXBsYXlTdWJqZWN0XzEuUmVwbGF5U3ViamVjdDsgfSB9KSk7XFxudmFyIEFzeW5jU3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9Bc3luY1N1YmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvQXN5bmNTdWJqZWN0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJBc3luY1N1YmplY3RcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFzeW5jU3ViamVjdF8xLkFzeW5jU3ViamVjdDsgfSB9KSk7XFxudmFyIGFzYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvc2NoZWR1bGVyL2FzYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL2FzYXAuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImFzYXBcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzYXBfMS5hc2FwOyB9IH0pKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImFzYXBTY2hlZHVsZXJcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzYXBfMS5hc2FwU2NoZWR1bGVyOyB9IH0pKTtcXG52YXIgYXN5bmNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvc2NoZWR1bGVyL2FzeW5jICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9hc3luYy5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiYXN5bmNcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzeW5jXzEuYXN5bmM7IH0gfSkpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiYXN5bmNTY2hlZHVsZXJcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzeW5jXzEuYXN5bmNTY2hlZHVsZXI7IH0gfSkpO1xcbnZhciBxdWV1ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9zY2hlZHVsZXIvcXVldWUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL3F1ZXVlLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJxdWV1ZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcXVldWVfMS5xdWV1ZTsgfSB9KSk7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJxdWV1ZVNjaGVkdWxlclxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcXVldWVfMS5xdWV1ZVNjaGVkdWxlcjsgfSB9KSk7XFxudmFyIGFuaW1hdGlvbkZyYW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL3NjaGVkdWxlci9hbmltYXRpb25GcmFtZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvYW5pbWF0aW9uRnJhbWUuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImFuaW1hdGlvbkZyYW1lXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhbmltYXRpb25GcmFtZV8xLmFuaW1hdGlvbkZyYW1lOyB9IH0pKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhbmltYXRpb25GcmFtZV8xLmFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyOyB9IH0pKTtcXG52YXIgVmlydHVhbFRpbWVTY2hlZHVsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvc2NoZWR1bGVyL1ZpcnR1YWxUaW1lU2NoZWR1bGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9WaXJ0dWFsVGltZVNjaGVkdWxlci5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiVmlydHVhbFRpbWVTY2hlZHVsZXJcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFZpcnR1YWxUaW1lU2NoZWR1bGVyXzEuVmlydHVhbFRpbWVTY2hlZHVsZXI7IH0gfSkpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiVmlydHVhbEFjdGlvblxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVmlydHVhbFRpbWVTY2hlZHVsZXJfMS5WaXJ0dWFsQWN0aW9uOyB9IH0pKTtcXG52YXIgU2NoZWR1bGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL1NjaGVkdWxlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TY2hlZHVsZXIuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIlNjaGVkdWxlclxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2NoZWR1bGVyXzEuU2NoZWR1bGVyOyB9IH0pKTtcXG52YXIgU3Vic2NyaXB0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL1N1YnNjcmlwdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJzY3JpcHRpb24uanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIlN1YnNjcmlwdGlvblxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uOyB9IH0pKTtcXG52YXIgU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9TdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YnNjcmliZXIuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIlN1YnNjcmliZXJcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyOyB9IH0pKTtcXG52YXIgTm90aWZpY2F0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL05vdGlmaWNhdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9Ob3RpZmljYXRpb24uanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIk5vdGlmaWNhdGlvblxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uOyB9IH0pKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIk5vdGlmaWNhdGlvbktpbmRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbktpbmQ7IH0gfSkpO1xcbnZhciBwaXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL3V0aWwvcGlwZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL3BpcGUuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInBpcGVcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBpcGVfMS5waXBlOyB9IH0pKTtcXG52YXIgbm9vcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC91dGlsL25vb3AgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9ub29wLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJub29wXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBub29wXzEubm9vcDsgfSB9KSk7XFxudmFyIGlkZW50aXR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL3V0aWwvaWRlbnRpdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pZGVudGl0eS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiaWRlbnRpdHlcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlkZW50aXR5XzEuaWRlbnRpdHk7IH0gfSkpO1xcbnZhciBpc09ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvdXRpbC9pc09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc09ic2VydmFibGUuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImlzT2JzZXJ2YWJsZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNPYnNlcnZhYmxlXzEuaXNPYnNlcnZhYmxlOyB9IH0pKTtcXG52YXIgbGFzdFZhbHVlRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9sYXN0VmFsdWVGcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL2xhc3RWYWx1ZUZyb20uanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImxhc3RWYWx1ZUZyb21cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhc3RWYWx1ZUZyb21fMS5sYXN0VmFsdWVGcm9tOyB9IH0pKTtcXG52YXIgZmlyc3RWYWx1ZUZyb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvZmlyc3RWYWx1ZUZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvZmlyc3RWYWx1ZUZyb20uanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImZpcnN0VmFsdWVGcm9tXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaXJzdFZhbHVlRnJvbV8xLmZpcnN0VmFsdWVGcm9tOyB9IH0pKTtcXG52YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJBcmd1bWVudE91dE9mUmFuZ2VFcnJvclxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMS5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcjsgfSB9KSk7XFxudmFyIEVtcHR5RXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvdXRpbC9FbXB0eUVycm9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvRW1wdHlFcnJvci5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiRW1wdHlFcnJvclxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRW1wdHlFcnJvcl8xLkVtcHR5RXJyb3I7IH0gfSkpO1xcbnZhciBOb3RGb3VuZEVycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL3V0aWwvTm90Rm91bmRFcnJvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL05vdEZvdW5kRXJyb3IuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIk5vdEZvdW5kRXJyb3JcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5vdEZvdW5kRXJyb3JfMS5Ob3RGb3VuZEVycm9yOyB9IH0pKTtcXG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJPYmplY3RVbnN1YnNjcmliZWRFcnJvclxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcjsgfSB9KSk7XFxudmFyIFNlcXVlbmNlRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvdXRpbC9TZXF1ZW5jZUVycm9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvU2VxdWVuY2VFcnJvci5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiU2VxdWVuY2VFcnJvclxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VxdWVuY2VFcnJvcl8xLlNlcXVlbmNlRXJyb3I7IH0gfSkpO1xcbnZhciB0aW1lb3V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy90aW1lb3V0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90aW1lb3V0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJUaW1lb3V0RXJyb3JcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRpbWVvdXRfMS5UaW1lb3V0RXJyb3I7IH0gfSkpO1xcbnZhciBVbnN1YnNjcmlwdGlvbkVycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIlVuc3Vic2NyaXB0aW9uRXJyb3JcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yOyB9IH0pKTtcXG52YXIgYmluZENhbGxiYWNrXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29ic2VydmFibGUvYmluZENhbGxiYWNrICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvYmluZENhbGxiYWNrLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJiaW5kQ2FsbGJhY2tcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpbmRDYWxsYmFja18xLmJpbmRDYWxsYmFjazsgfSB9KSk7XFxudmFyIGJpbmROb2RlQ2FsbGJhY2tfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9iaW5kTm9kZUNhbGxiYWNrICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvYmluZE5vZGVDYWxsYmFjay5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiYmluZE5vZGVDYWxsYmFja1xcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmluZE5vZGVDYWxsYmFja18xLmJpbmROb2RlQ2FsbGJhY2s7IH0gfSkpO1xcbnZhciBjb21iaW5lTGF0ZXN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29ic2VydmFibGUvY29tYmluZUxhdGVzdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2NvbWJpbmVMYXRlc3QuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImNvbWJpbmVMYXRlc3RcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbWJpbmVMYXRlc3RfMS5jb21iaW5lTGF0ZXN0OyB9IH0pKTtcXG52YXIgY29uY2F0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29ic2VydmFibGUvY29uY2F0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvY29uY2F0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb25jYXRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmNhdF8xLmNvbmNhdDsgfSB9KSk7XFxudmFyIGNvbm5lY3RhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29ic2VydmFibGUvY29ubmVjdGFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9jb25uZWN0YWJsZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiY29ubmVjdGFibGVcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3RhYmxlXzEuY29ubmVjdGFibGU7IH0gfSkpO1xcbnZhciBkZWZlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vYnNlcnZhYmxlL2RlZmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZGVmZXIuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImRlZmVyXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWZlcl8xLmRlZmVyOyB9IH0pKTtcXG52YXIgZW1wdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9lbXB0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2VtcHR5LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJlbXB0eVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW1wdHlfMS5lbXB0eTsgfSB9KSk7XFxudmFyIGZvcmtKb2luXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29ic2VydmFibGUvZm9ya0pvaW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mb3JrSm9pbi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiZm9ya0pvaW5cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvcmtKb2luXzEuZm9ya0pvaW47IH0gfSkpO1xcbnZhciBmcm9tXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29ic2VydmFibGUvZnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb20uanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImZyb21cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21fMS5mcm9tOyB9IH0pKTtcXG52YXIgZnJvbUV2ZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29ic2VydmFibGUvZnJvbUV2ZW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZnJvbUV2ZW50LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJmcm9tRXZlbnRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21FdmVudF8xLmZyb21FdmVudDsgfSB9KSk7XFxudmFyIGZyb21FdmVudFBhdHRlcm5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9mcm9tRXZlbnRQYXR0ZXJuICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZnJvbUV2ZW50UGF0dGVybi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiZnJvbUV2ZW50UGF0dGVyblxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJvbUV2ZW50UGF0dGVybl8xLmZyb21FdmVudFBhdHRlcm47IH0gfSkpO1xcbnZhciBnZW5lcmF0ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vYnNlcnZhYmxlL2dlbmVyYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZ2VuZXJhdGUuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImdlbmVyYXRlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0ZV8xLmdlbmVyYXRlOyB9IH0pKTtcXG52YXIgaWlmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29ic2VydmFibGUvaWlmICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvaWlmLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJpaWZcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlpZl8xLmlpZjsgfSB9KSk7XFxudmFyIGludGVydmFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29ic2VydmFibGUvaW50ZXJ2YWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbnRlcnZhbC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiaW50ZXJ2YWxcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVydmFsXzEuaW50ZXJ2YWw7IH0gfSkpO1xcbnZhciBtZXJnZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vYnNlcnZhYmxlL21lcmdlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvbWVyZ2UuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIm1lcmdlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXJnZV8xLm1lcmdlOyB9IH0pKTtcXG52YXIgbmV2ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9uZXZlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL25ldmVyLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJuZXZlclxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV2ZXJfMS5uZXZlcjsgfSB9KSk7XFxudmFyIG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29ic2VydmFibGUvb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9vZi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwib2ZcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9mXzEub2Y7IH0gfSkpO1xcbnZhciBvbkVycm9yUmVzdW1lTmV4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vYnNlcnZhYmxlL29uRXJyb3JSZXN1bWVOZXh0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvb25FcnJvclJlc3VtZU5leHQuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIm9uRXJyb3JSZXN1bWVOZXh0XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvbkVycm9yUmVzdW1lTmV4dF8xLm9uRXJyb3JSZXN1bWVOZXh0OyB9IH0pKTtcXG52YXIgcGFpcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9wYWlycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3BhaXJzLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJwYWlyc1xcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFpcnNfMS5wYWlyczsgfSB9KSk7XFxudmFyIHBhcnRpdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vYnNlcnZhYmxlL3BhcnRpdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3BhcnRpdGlvbi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicGFydGl0aW9uXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJ0aXRpb25fMS5wYXJ0aXRpb247IH0gfSkpO1xcbnZhciByYWNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29ic2VydmFibGUvcmFjZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3JhY2UuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInJhY2VcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhY2VfMS5yYWNlOyB9IH0pKTtcXG52YXIgcmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb2JzZXJ2YWJsZS9yYW5nZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3JhbmdlLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJyYW5nZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmFuZ2VfMS5yYW5nZTsgfSB9KSk7XFxudmFyIHRocm93RXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb2JzZXJ2YWJsZS90aHJvd0Vycm9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvdGhyb3dFcnJvci5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGhyb3dFcnJvclxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhyb3dFcnJvcl8xLnRocm93RXJyb3I7IH0gfSkpO1xcbnZhciB0aW1lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vYnNlcnZhYmxlL3RpbWVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvdGltZXIuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInRpbWVyXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aW1lcl8xLnRpbWVyOyB9IH0pKTtcXG52YXIgdXNpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb2JzZXJ2YWJsZS91c2luZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3VzaW5nLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJ1c2luZ1xcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXNpbmdfMS51c2luZzsgfSB9KSk7XFxudmFyIHppcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vYnNlcnZhYmxlL3ppcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3ppcC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiemlwXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB6aXBfMS56aXA7IH0gfSkpO1xcbnZhciBzY2hlZHVsZWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVkLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJzY2hlZHVsZWRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjaGVkdWxlZF8xLnNjaGVkdWxlZDsgfSB9KSk7XFxudmFyIGVtcHR5XzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29ic2VydmFibGUvZW1wdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9lbXB0eS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiRU1QVFlcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVtcHR5XzIuRU1QVFk7IH0gfSkpO1xcbnZhciBuZXZlcl8yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vYnNlcnZhYmxlL25ldmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvbmV2ZXIuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIk5FVkVSXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXZlcl8yLk5FVkVSOyB9IH0pKTtcXG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC90eXBlcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC90eXBlcy5qc1xcXCIpLCBleHBvcnRzKTtcXG52YXIgY29uZmlnXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL2NvbmZpZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9jb25maWcuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImNvbmZpZ1xcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnXzEuY29uZmlnOyB9IH0pKTtcXG52YXIgYXVkaXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL2F1ZGl0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9hdWRpdC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiYXVkaXRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGF1ZGl0XzEuYXVkaXQ7IH0gfSkpO1xcbnZhciBhdWRpdFRpbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL2F1ZGl0VGltZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvYXVkaXRUaW1lLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJhdWRpdFRpbWVcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGF1ZGl0VGltZV8xLmF1ZGl0VGltZTsgfSB9KSk7XFxudmFyIGJ1ZmZlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXIuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImJ1ZmZlclxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyXzEuYnVmZmVyOyB9IH0pKTtcXG52YXIgYnVmZmVyQ291bnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL2J1ZmZlckNvdW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJDb3VudC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiYnVmZmVyQ291bnRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ1ZmZlckNvdW50XzEuYnVmZmVyQ291bnQ7IH0gfSkpO1xcbnZhciBidWZmZXJUaW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJUaW1lICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJUaW1lLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJidWZmZXJUaW1lXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJUaW1lXzEuYnVmZmVyVGltZTsgfSB9KSk7XFxudmFyIGJ1ZmZlclRvZ2dsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyVG9nZ2xlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJUb2dnbGUuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImJ1ZmZlclRvZ2dsZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyVG9nZ2xlXzEuYnVmZmVyVG9nZ2xlOyB9IH0pKTtcXG52YXIgYnVmZmVyV2hlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyV2hlbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyV2hlbi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiYnVmZmVyV2hlblxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyV2hlbl8xLmJ1ZmZlcldoZW47IH0gfSkpO1xcbnZhciBjYXRjaEVycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9jYXRjaEVycm9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jYXRjaEVycm9yLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjYXRjaEVycm9yXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYXRjaEVycm9yXzEuY2F0Y2hFcnJvcjsgfSB9KSk7XFxudmFyIGNvbWJpbmVBbGxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL2NvbWJpbmVBbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbWJpbmVBbGwuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImNvbWJpbmVBbGxcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbWJpbmVBbGxfMS5jb21iaW5lQWxsOyB9IH0pKTtcXG52YXIgY29tYmluZUxhdGVzdEFsbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvY29tYmluZUxhdGVzdEFsbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29tYmluZUxhdGVzdEFsbC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiY29tYmluZUxhdGVzdEFsbFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tYmluZUxhdGVzdEFsbF8xLmNvbWJpbmVMYXRlc3RBbGw7IH0gfSkpO1xcbnZhciBjb21iaW5lTGF0ZXN0V2l0aF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvY29tYmluZUxhdGVzdFdpdGggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbWJpbmVMYXRlc3RXaXRoLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb21iaW5lTGF0ZXN0V2l0aFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tYmluZUxhdGVzdFdpdGhfMS5jb21iaW5lTGF0ZXN0V2l0aDsgfSB9KSk7XFxudmFyIGNvbmNhdEFsbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0QWxsICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb25jYXRBbGwuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImNvbmNhdEFsbFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uY2F0QWxsXzEuY29uY2F0QWxsOyB9IH0pKTtcXG52YXIgY29uY2F0TWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9jb25jYXRNYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbmNhdE1hcC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiY29uY2F0TWFwXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25jYXRNYXBfMS5jb25jYXRNYXA7IH0gfSkpO1xcbnZhciBjb25jYXRNYXBUb18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0TWFwVG8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbmNhdE1hcFRvLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb25jYXRNYXBUb1xcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uY2F0TWFwVG9fMS5jb25jYXRNYXBUbzsgfSB9KSk7XFxudmFyIGNvbmNhdFdpdGhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL2NvbmNhdFdpdGggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbmNhdFdpdGguanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImNvbmNhdFdpdGhcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmNhdFdpdGhfMS5jb25jYXRXaXRoOyB9IH0pKTtcXG52YXIgY29ubmVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvY29ubmVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29ubmVjdC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiY29ubmVjdFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdF8xLmNvbm5lY3Q7IH0gfSkpO1xcbnZhciBjb3VudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvY291bnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvdW50LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb3VudFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY291bnRfMS5jb3VudDsgfSB9KSk7XFxudmFyIGRlYm91bmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9kZWJvdW5jZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVib3VuY2UuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImRlYm91bmNlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWJvdW5jZV8xLmRlYm91bmNlOyB9IH0pKTtcXG52YXIgZGVib3VuY2VUaW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9kZWJvdW5jZVRpbWUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlYm91bmNlVGltZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiZGVib3VuY2VUaW1lXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWJvdW5jZVRpbWVfMS5kZWJvdW5jZVRpbWU7IH0gfSkpO1xcbnZhciBkZWZhdWx0SWZFbXB0eV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvZGVmYXVsdElmRW1wdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlZmF1bHRJZkVtcHR5LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJkZWZhdWx0SWZFbXB0eVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVmYXVsdElmRW1wdHlfMS5kZWZhdWx0SWZFbXB0eTsgfSB9KSk7XFxudmFyIGRlbGF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9kZWxheSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVsYXkuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImRlbGF5XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWxheV8xLmRlbGF5OyB9IH0pKTtcXG52YXIgZGVsYXlXaGVuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9kZWxheVdoZW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlbGF5V2hlbi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiZGVsYXlXaGVuXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWxheVdoZW5fMS5kZWxheVdoZW47IH0gfSkpO1xcbnZhciBkZW1hdGVyaWFsaXplXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9kZW1hdGVyaWFsaXplICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kZW1hdGVyaWFsaXplLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJkZW1hdGVyaWFsaXplXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZW1hdGVyaWFsaXplXzEuZGVtYXRlcmlhbGl6ZTsgfSB9KSk7XFxudmFyIGRpc3RpbmN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9kaXN0aW5jdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZGlzdGluY3QuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImRpc3RpbmN0XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXN0aW5jdF8xLmRpc3RpbmN0OyB9IH0pKTtcXG52YXIgZGlzdGluY3RVbnRpbENoYW5nZWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL2Rpc3RpbmN0VW50aWxDaGFuZ2VkICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kaXN0aW5jdFVudGlsQ2hhbmdlZC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiZGlzdGluY3RVbnRpbENoYW5nZWRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3RpbmN0VW50aWxDaGFuZ2VkXzEuZGlzdGluY3RVbnRpbENoYW5nZWQ7IH0gfSkpO1xcbnZhciBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvZGlzdGluY3RVbnRpbEtleUNoYW5nZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzdGluY3RVbnRpbEtleUNoYW5nZWRfMS5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZDsgfSB9KSk7XFxudmFyIGVsZW1lbnRBdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvZWxlbWVudEF0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9lbGVtZW50QXQuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImVsZW1lbnRBdFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZWxlbWVudEF0XzEuZWxlbWVudEF0OyB9IH0pKTtcXG52YXIgZW5kV2l0aF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvZW5kV2l0aCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZW5kV2l0aC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiZW5kV2l0aFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5kV2l0aF8xLmVuZFdpdGg7IH0gfSkpO1xcbnZhciBldmVyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvZXZlcnkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2V2ZXJ5LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJldmVyeVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlcnlfMS5ldmVyeTsgfSB9KSk7XFxudmFyIGV4aGF1c3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL2V4aGF1c3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2V4aGF1c3QuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImV4aGF1c3RcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4aGF1c3RfMS5leGhhdXN0OyB9IH0pKTtcXG52YXIgZXhoYXVzdEFsbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvZXhoYXVzdEFsbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZXhoYXVzdEFsbC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiZXhoYXVzdEFsbFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhoYXVzdEFsbF8xLmV4aGF1c3RBbGw7IH0gfSkpO1xcbnZhciBleGhhdXN0TWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9leGhhdXN0TWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9leGhhdXN0TWFwLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJleGhhdXN0TWFwXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGhhdXN0TWFwXzEuZXhoYXVzdE1hcDsgfSB9KSk7XFxudmFyIGV4cGFuZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvZXhwYW5kICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9leHBhbmQuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImV4cGFuZFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhwYW5kXzEuZXhwYW5kOyB9IH0pKTtcXG52YXIgZmlsdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9maWx0ZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbHRlci5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiZmlsdGVyXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfMS5maWx0ZXI7IH0gfSkpO1xcbnZhciBmaW5hbGl6ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvZmluYWxpemUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbmFsaXplLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJmaW5hbGl6ZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmluYWxpemVfMS5maW5hbGl6ZTsgfSB9KSk7XFxudmFyIGZpbmRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbmQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbmQuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImZpbmRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpbmRfMS5maW5kOyB9IH0pKTtcXG52YXIgZmluZEluZGV4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9maW5kSW5kZXggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbmRJbmRleC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiZmluZEluZGV4XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaW5kSW5kZXhfMS5maW5kSW5kZXg7IH0gfSkpO1xcbnZhciBmaXJzdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvZmlyc3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpcnN0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJmaXJzdFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlyc3RfMS5maXJzdDsgfSB9KSk7XFxudmFyIGdyb3VwQnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL2dyb3VwQnkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2dyb3VwQnkuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImdyb3VwQnlcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdyb3VwQnlfMS5ncm91cEJ5OyB9IH0pKTtcXG52YXIgaWdub3JlRWxlbWVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL2lnbm9yZUVsZW1lbnRzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9pZ25vcmVFbGVtZW50cy5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiaWdub3JlRWxlbWVudHNcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlnbm9yZUVsZW1lbnRzXzEuaWdub3JlRWxlbWVudHM7IH0gfSkpO1xcbnZhciBpc0VtcHR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9pc0VtcHR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9pc0VtcHR5LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJpc0VtcHR5XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc0VtcHR5XzEuaXNFbXB0eTsgfSB9KSk7XFxudmFyIGxhc3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL2xhc3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2xhc3QuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImxhc3RcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhc3RfMS5sYXN0OyB9IH0pKTtcXG52YXIgbWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9tYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21hcC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwibWFwXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXBfMS5tYXA7IH0gfSkpO1xcbnZhciBtYXBUb18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvbWFwVG8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21hcFRvLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtYXBUb1xcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFwVG9fMS5tYXBUbzsgfSB9KSk7XFxudmFyIG1hdGVyaWFsaXplXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9tYXRlcmlhbGl6ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWF0ZXJpYWxpemUuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIm1hdGVyaWFsaXplXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRlcmlhbGl6ZV8xLm1hdGVyaWFsaXplOyB9IH0pKTtcXG52YXIgbWF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9tYXggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21heC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwibWF4XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXhfMS5tYXg7IH0gfSkpO1xcbnZhciBtZXJnZUFsbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VBbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlQWxsLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtZXJnZUFsbFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVyZ2VBbGxfMS5tZXJnZUFsbDsgfSB9KSk7XFxudmFyIGZsYXRNYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL2ZsYXRNYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZsYXRNYXAuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcImZsYXRNYXBcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZsYXRNYXBfMS5mbGF0TWFwOyB9IH0pKTtcXG52YXIgbWVyZ2VNYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlTWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZU1hcC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwibWVyZ2VNYXBcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lcmdlTWFwXzEubWVyZ2VNYXA7IH0gfSkpO1xcbnZhciBtZXJnZU1hcFRvXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZU1hcFRvICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZU1hcFRvLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtZXJnZU1hcFRvXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXJnZU1hcFRvXzEubWVyZ2VNYXBUbzsgfSB9KSk7XFxudmFyIG1lcmdlU2Nhbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VTY2FuICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZVNjYW4uanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIm1lcmdlU2NhblxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVyZ2VTY2FuXzEubWVyZ2VTY2FuOyB9IH0pKTtcXG52YXIgbWVyZ2VXaXRoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZVdpdGggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlV2l0aC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwibWVyZ2VXaXRoXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXJnZVdpdGhfMS5tZXJnZVdpdGg7IH0gfSkpO1xcbnZhciBtaW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL21pbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWluLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtaW5cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pbl8xLm1pbjsgfSB9KSk7XFxudmFyIG11bHRpY2FzdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvbXVsdGljYXN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tdWx0aWNhc3QuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIm11bHRpY2FzdFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbXVsdGljYXN0XzEubXVsdGljYXN0OyB9IH0pKTtcXG52YXIgb2JzZXJ2ZU9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9vYnNlcnZlT24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmVPbi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwib2JzZXJ2ZU9uXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvYnNlcnZlT25fMS5vYnNlcnZlT247IH0gfSkpO1xcbnZhciBvbkVycm9yUmVzdW1lTmV4dFdpdGhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL29uRXJyb3JSZXN1bWVOZXh0V2l0aCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvb25FcnJvclJlc3VtZU5leHRXaXRoLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJvbkVycm9yUmVzdW1lTmV4dFdpdGhcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9uRXJyb3JSZXN1bWVOZXh0V2l0aF8xLm9uRXJyb3JSZXN1bWVOZXh0V2l0aDsgfSB9KSk7XFxudmFyIHBhaXJ3aXNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9wYWlyd2lzZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcGFpcndpc2UuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInBhaXJ3aXNlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYWlyd2lzZV8xLnBhaXJ3aXNlOyB9IH0pKTtcXG52YXIgcGx1Y2tfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3BsdWNrICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9wbHVjay5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicGx1Y2tcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBsdWNrXzEucGx1Y2s7IH0gfSkpO1xcbnZhciBwdWJsaXNoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9wdWJsaXNoICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9wdWJsaXNoLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJwdWJsaXNoXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwdWJsaXNoXzEucHVibGlzaDsgfSB9KSk7XFxudmFyIHB1Ymxpc2hCZWhhdmlvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvcHVibGlzaEJlaGF2aW9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9wdWJsaXNoQmVoYXZpb3IuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInB1Ymxpc2hCZWhhdmlvclxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHVibGlzaEJlaGF2aW9yXzEucHVibGlzaEJlaGF2aW9yOyB9IH0pKTtcXG52YXIgcHVibGlzaExhc3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3B1Ymxpc2hMYXN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9wdWJsaXNoTGFzdC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicHVibGlzaExhc3RcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHB1Ymxpc2hMYXN0XzEucHVibGlzaExhc3Q7IH0gfSkpO1xcbnZhciBwdWJsaXNoUmVwbGF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9wdWJsaXNoUmVwbGF5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9wdWJsaXNoUmVwbGF5LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJwdWJsaXNoUmVwbGF5XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwdWJsaXNoUmVwbGF5XzEucHVibGlzaFJlcGxheTsgfSB9KSk7XFxudmFyIHJhY2VXaXRoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9yYWNlV2l0aCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmFjZVdpdGguanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInJhY2VXaXRoXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByYWNlV2l0aF8xLnJhY2VXaXRoOyB9IH0pKTtcXG52YXIgcmVkdWNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9yZWR1Y2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3JlZHVjZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicmVkdWNlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWR1Y2VfMS5yZWR1Y2U7IH0gfSkpO1xcbnZhciByZXBlYXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3JlcGVhdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmVwZWF0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJyZXBlYXRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcGVhdF8xLnJlcGVhdDsgfSB9KSk7XFxudmFyIHJlcGVhdFdoZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3JlcGVhdFdoZW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3JlcGVhdFdoZW4uanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInJlcGVhdFdoZW5cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcGVhdFdoZW5fMS5yZXBlYXRXaGVuOyB9IH0pKTtcXG52YXIgcmV0cnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3JldHJ5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yZXRyeS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicmV0cnlcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHJ5XzEucmV0cnk7IH0gfSkpO1xcbnZhciByZXRyeVdoZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3JldHJ5V2hlbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmV0cnlXaGVuLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJyZXRyeVdoZW5cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHJ5V2hlbl8xLnJldHJ5V2hlbjsgfSB9KSk7XFxudmFyIHJlZkNvdW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9yZWZDb3VudCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmVmQ291bnQuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInJlZkNvdW50XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWZDb3VudF8xLnJlZkNvdW50OyB9IH0pKTtcXG52YXIgc2FtcGxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9zYW1wbGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NhbXBsZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2FtcGxlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzYW1wbGVfMS5zYW1wbGU7IH0gfSkpO1xcbnZhciBzYW1wbGVUaW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9zYW1wbGVUaW1lICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zYW1wbGVUaW1lLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJzYW1wbGVUaW1lXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzYW1wbGVUaW1lXzEuc2FtcGxlVGltZTsgfSB9KSk7XFxudmFyIHNjYW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3NjYW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NjYW4uanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInNjYW5cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjYW5fMS5zY2FuOyB9IH0pKTtcXG52YXIgc2VxdWVuY2VFcXVhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvc2VxdWVuY2VFcXVhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2VxdWVuY2VFcXVhbC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2VxdWVuY2VFcXVhbFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VxdWVuY2VFcXVhbF8xLnNlcXVlbmNlRXF1YWw7IH0gfSkpO1xcbnZhciBzaGFyZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvc2hhcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NoYXJlLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJzaGFyZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVfMS5zaGFyZTsgfSB9KSk7XFxudmFyIHNoYXJlUmVwbGF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9zaGFyZVJlcGxheSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2hhcmVSZXBsYXkuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInNoYXJlUmVwbGF5XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZVJlcGxheV8xLnNoYXJlUmVwbGF5OyB9IH0pKTtcXG52YXIgc2luZ2xlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9zaW5nbGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NpbmdsZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2luZ2xlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaW5nbGVfMS5zaW5nbGU7IH0gfSkpO1xcbnZhciBza2lwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9za2lwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9za2lwLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJza2lwXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBza2lwXzEuc2tpcDsgfSB9KSk7XFxudmFyIHNraXBMYXN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9za2lwTGFzdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2tpcExhc3QuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInNraXBMYXN0XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBza2lwTGFzdF8xLnNraXBMYXN0OyB9IH0pKTtcXG52YXIgc2tpcFVudGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9za2lwVW50aWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NraXBVbnRpbC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2tpcFVudGlsXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBza2lwVW50aWxfMS5za2lwVW50aWw7IH0gfSkpO1xcbnZhciBza2lwV2hpbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3NraXBXaGlsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2tpcFdoaWxlLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJza2lwV2hpbGVcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNraXBXaGlsZV8xLnNraXBXaGlsZTsgfSB9KSk7XFxudmFyIHN0YXJ0V2l0aF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvc3RhcnRXaXRoICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zdGFydFdpdGguanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInN0YXJ0V2l0aFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhcnRXaXRoXzEuc3RhcnRXaXRoOyB9IH0pKTtcXG52YXIgc3Vic2NyaWJlT25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3N1YnNjcmliZU9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zdWJzY3JpYmVPbi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic3Vic2NyaWJlT25cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmliZU9uXzEuc3Vic2NyaWJlT247IH0gfSkpO1xcbnZhciBzd2l0Y2hBbGxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3N3aXRjaEFsbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoQWxsLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJzd2l0Y2hBbGxcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN3aXRjaEFsbF8xLnN3aXRjaEFsbDsgfSB9KSk7XFxudmFyIHN3aXRjaE1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoTWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zd2l0Y2hNYXAuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInN3aXRjaE1hcFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3dpdGNoTWFwXzEuc3dpdGNoTWFwOyB9IH0pKTtcXG52YXIgc3dpdGNoTWFwVG9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3N3aXRjaE1hcFRvICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zd2l0Y2hNYXBUby5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic3dpdGNoTWFwVG9cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN3aXRjaE1hcFRvXzEuc3dpdGNoTWFwVG87IH0gfSkpO1xcbnZhciBzd2l0Y2hTY2FuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy9zd2l0Y2hTY2FuICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zd2l0Y2hTY2FuLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJzd2l0Y2hTY2FuXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzd2l0Y2hTY2FuXzEuc3dpdGNoU2NhbjsgfSB9KSk7XFxudmFyIHRha2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2UuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInRha2VcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRha2VfMS50YWtlOyB9IH0pKTtcXG52YXIgdGFrZUxhc3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2VMYXN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90YWtlTGFzdC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGFrZUxhc3RcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRha2VMYXN0XzEudGFrZUxhc3Q7IH0gfSkpO1xcbnZhciB0YWtlVW50aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2VVbnRpbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZVVudGlsLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJ0YWtlVW50aWxcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRha2VVbnRpbF8xLnRha2VVbnRpbDsgfSB9KSk7XFxudmFyIHRha2VXaGlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZVdoaWxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90YWtlV2hpbGUuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInRha2VXaGlsZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGFrZVdoaWxlXzEudGFrZVdoaWxlOyB9IH0pKTtcXG52YXIgdGFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy90YXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3RhcC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGFwXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0YXBfMS50YXA7IH0gfSkpO1xcbnZhciB0aHJvdHRsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvdGhyb3R0bGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm90dGxlLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJ0aHJvdHRsZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhyb3R0bGVfMS50aHJvdHRsZTsgfSB9KSk7XFxudmFyIHRocm90dGxlVGltZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvdGhyb3R0bGVUaW1lICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90aHJvdHRsZVRpbWUuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInRocm90dGxlVGltZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhyb3R0bGVUaW1lXzEudGhyb3R0bGVUaW1lOyB9IH0pKTtcXG52YXIgdGhyb3dJZkVtcHR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy90aHJvd0lmRW1wdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm93SWZFbXB0eS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGhyb3dJZkVtcHR5XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aHJvd0lmRW1wdHlfMS50aHJvd0lmRW1wdHk7IH0gfSkpO1xcbnZhciB0aW1lSW50ZXJ2YWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3RpbWVJbnRlcnZhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGltZUludGVydmFsLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJ0aW1lSW50ZXJ2YWxcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRpbWVJbnRlcnZhbF8xLnRpbWVJbnRlcnZhbDsgfSB9KSk7XFxudmFyIHRpbWVvdXRfMiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3RpbWVvdXQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3RpbWVvdXQuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInRpbWVvdXRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRpbWVvdXRfMi50aW1lb3V0OyB9IH0pKTtcXG52YXIgdGltZW91dFdpdGhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3RpbWVvdXRXaXRoICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90aW1lb3V0V2l0aC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGltZW91dFdpdGhcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRpbWVvdXRXaXRoXzEudGltZW91dFdpdGg7IH0gfSkpO1xcbnZhciB0aW1lc3RhbXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3RpbWVzdGFtcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGltZXN0YW1wLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJ0aW1lc3RhbXBcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRpbWVzdGFtcF8xLnRpbWVzdGFtcDsgfSB9KSk7XFxudmFyIHRvQXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3RvQXJyYXkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3RvQXJyYXkuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInRvQXJyYXlcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvQXJyYXlfMS50b0FycmF5OyB9IH0pKTtcXG52YXIgd2luZG93XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3cgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvdy5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwid2luZG93XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3dfMS53aW5kb3c7IH0gfSkpO1xcbnZhciB3aW5kb3dDb3VudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnRlcm5hbC9vcGVyYXRvcnMvd2luZG93Q291bnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvd0NvdW50LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJ3aW5kb3dDb3VudFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93Q291bnRfMS53aW5kb3dDb3VudDsgfSB9KSk7XFxudmFyIHdpbmRvd1RpbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvd1RpbWUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvd1RpbWUuanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIndpbmRvd1RpbWVcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvd1RpbWVfMS53aW5kb3dUaW1lOyB9IH0pKTtcXG52YXIgd2luZG93VG9nZ2xlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3dUb2dnbGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvd1RvZ2dsZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwid2luZG93VG9nZ2xlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3dUb2dnbGVfMS53aW5kb3dUb2dnbGU7IH0gfSkpO1xcbnZhciB3aW5kb3dXaGVuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3dXaGVuICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3dXaGVuLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJ3aW5kb3dXaGVuXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3dXaGVuXzEud2luZG93V2hlbjsgfSB9KSk7XFxudmFyIHdpdGhMYXRlc3RGcm9tXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy93aXRoTGF0ZXN0RnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvd2l0aExhdGVzdEZyb20uanNcXFwiKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIndpdGhMYXRlc3RGcm9tXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3aXRoTGF0ZXN0RnJvbV8xLndpdGhMYXRlc3RGcm9tOyB9IH0pKTtcXG52YXIgemlwQWxsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy96aXBBbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3ppcEFsbC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiemlwQWxsXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB6aXBBbGxfMS56aXBBbGw7IH0gfSkpO1xcbnZhciB6aXBXaXRoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVybmFsL29wZXJhdG9ycy96aXBXaXRoICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy96aXBXaXRoLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJ6aXBXaXRoXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB6aXBXaXRoXzEuemlwV2l0aDsgfSB9KSk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL0FzeW5jU3ViamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL0FzeW5jU3ViamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XFxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgYiAhPT0gbnVsbClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDbGFzcyBleHRlbmRzIHZhbHVlIFxcXCIgKyBTdHJpbmcoYikgKyBcXFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcXFwiKTtcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcXG4gICAgfTtcXG59KSgpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLkFzeW5jU3ViamVjdCA9IHZvaWQgMDtcXG52YXIgU3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9TdWJqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YmplY3QuanNcXFwiKTtcXG52YXIgQXN5bmNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcXG4gICAgX19leHRlbmRzKEFzeW5jU3ViamVjdCwgX3N1cGVyKTtcXG4gICAgZnVuY3Rpb24gQXN5bmNTdWJqZWN0KCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XFxuICAgICAgICBfdGhpcy5fdmFsdWUgPSBudWxsO1xcbiAgICAgICAgX3RoaXMuX2hhc1ZhbHVlID0gZmFsc2U7XFxuICAgICAgICBfdGhpcy5faXNDb21wbGV0ZSA9IGZhbHNlO1xcbiAgICAgICAgcmV0dXJuIF90aGlzO1xcbiAgICB9XFxuICAgIEFzeW5jU3ViamVjdC5wcm90b3R5cGUuX2NoZWNrRmluYWxpemVkU3RhdHVzZXMgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIF9hID0gdGhpcywgaGFzRXJyb3IgPSBfYS5oYXNFcnJvciwgX2hhc1ZhbHVlID0gX2EuX2hhc1ZhbHVlLCBfdmFsdWUgPSBfYS5fdmFsdWUsIHRocm93bkVycm9yID0gX2EudGhyb3duRXJyb3IsIGlzU3RvcHBlZCA9IF9hLmlzU3RvcHBlZCwgX2lzQ29tcGxldGUgPSBfYS5faXNDb21wbGV0ZTtcXG4gICAgICAgIGlmIChoYXNFcnJvcikge1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IodGhyb3duRXJyb3IpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoaXNTdG9wcGVkIHx8IF9pc0NvbXBsZXRlKSB7XFxuICAgICAgICAgICAgX2hhc1ZhbHVlICYmIHN1YnNjcmliZXIubmV4dChfdmFsdWUpO1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgQXN5bmNTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XFxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcXG4gICAgICAgICAgICB0aGlzLl9oYXNWYWx1ZSA9IHRydWU7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIEFzeW5jU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfaGFzVmFsdWUgPSBfYS5faGFzVmFsdWUsIF92YWx1ZSA9IF9hLl92YWx1ZSwgX2lzQ29tcGxldGUgPSBfYS5faXNDb21wbGV0ZTtcXG4gICAgICAgIGlmICghX2lzQ29tcGxldGUpIHtcXG4gICAgICAgICAgICB0aGlzLl9pc0NvbXBsZXRlID0gdHJ1ZTtcXG4gICAgICAgICAgICBfaGFzVmFsdWUgJiYgX3N1cGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcywgX3ZhbHVlKTtcXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmNvbXBsZXRlLmNhbGwodGhpcyk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIHJldHVybiBBc3luY1N1YmplY3Q7XFxufShTdWJqZWN0XzEuU3ViamVjdCkpO1xcbmV4cG9ydHMuQXN5bmNTdWJqZWN0ID0gQXN5bmNTdWJqZWN0O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzeW5jU3ViamVjdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9Bc3luY1N1YmplY3QuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL0JlaGF2aW9yU3ViamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL0JlaGF2aW9yU3ViamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XFxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgYiAhPT0gbnVsbClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDbGFzcyBleHRlbmRzIHZhbHVlIFxcXCIgKyBTdHJpbmcoYikgKyBcXFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcXFwiKTtcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcXG4gICAgfTtcXG59KSgpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLkJlaGF2aW9yU3ViamVjdCA9IHZvaWQgMDtcXG52YXIgU3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9TdWJqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YmplY3QuanNcXFwiKTtcXG52YXIgQmVoYXZpb3JTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcXG4gICAgX19leHRlbmRzKEJlaGF2aW9yU3ViamVjdCwgX3N1cGVyKTtcXG4gICAgZnVuY3Rpb24gQmVoYXZpb3JTdWJqZWN0KF92YWx1ZSkge1xcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcXG4gICAgICAgIF90aGlzLl92YWx1ZSA9IF92YWx1ZTtcXG4gICAgICAgIHJldHVybiBfdGhpcztcXG4gICAgfVxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZSwgXFxcInZhbHVlXFxcIiwge1xcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxcbiAgICB9KTtcXG4gICAgQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBfc3VwZXIucHJvdG90eXBlLl9zdWJzY3JpYmUuY2FsbCh0aGlzLCBzdWJzY3JpYmVyKTtcXG4gICAgICAgICFzdWJzY3JpcHRpb24uY2xvc2VkICYmIHN1YnNjcmliZXIubmV4dCh0aGlzLl92YWx1ZSk7XFxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xcbiAgICB9O1xcbiAgICBCZWhhdmlvclN1YmplY3QucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIF9hID0gdGhpcywgaGFzRXJyb3IgPSBfYS5oYXNFcnJvciwgdGhyb3duRXJyb3IgPSBfYS50aHJvd25FcnJvciwgX3ZhbHVlID0gX2EuX3ZhbHVlO1xcbiAgICAgICAgaWYgKGhhc0Vycm9yKSB7XFxuICAgICAgICAgICAgdGhyb3cgdGhyb3duRXJyb3I7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLl90aHJvd0lmQ2xvc2VkKCk7XFxuICAgICAgICByZXR1cm4gX3ZhbHVlO1xcbiAgICB9O1xcbiAgICBCZWhhdmlvclN1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsICh0aGlzLl92YWx1ZSA9IHZhbHVlKSk7XFxuICAgIH07XFxuICAgIHJldHVybiBCZWhhdmlvclN1YmplY3Q7XFxufShTdWJqZWN0XzEuU3ViamVjdCkpO1xcbmV4cG9ydHMuQmVoYXZpb3JTdWJqZWN0ID0gQmVoYXZpb3JTdWJqZWN0O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJlaGF2aW9yU3ViamVjdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9CZWhhdmlvclN1YmplY3QuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL05vdGlmaWNhdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL05vdGlmaWNhdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLm9ic2VydmVOb3RpZmljYXRpb24gPSBleHBvcnRzLk5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uS2luZCA9IHZvaWQgMDtcXG52YXIgZW1wdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vb2JzZXJ2YWJsZS9lbXB0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2VtcHR5LmpzXFxcIik7XFxudmFyIG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29ic2VydmFibGUvb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9vZi5qc1xcXCIpO1xcbnZhciB0aHJvd0Vycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29ic2VydmFibGUvdGhyb3dFcnJvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3Rocm93RXJyb3IuanNcXFwiKTtcXG52YXIgaXNGdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL2lzRnVuY3Rpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxudmFyIE5vdGlmaWNhdGlvbktpbmQ7XFxuKGZ1bmN0aW9uIChOb3RpZmljYXRpb25LaW5kKSB7XFxuICAgIE5vdGlmaWNhdGlvbktpbmRbXFxcIk5FWFRcXFwiXSA9IFxcXCJOXFxcIjtcXG4gICAgTm90aWZpY2F0aW9uS2luZFtcXFwiRVJST1JcXFwiXSA9IFxcXCJFXFxcIjtcXG4gICAgTm90aWZpY2F0aW9uS2luZFtcXFwiQ09NUExFVEVcXFwiXSA9IFxcXCJDXFxcIjtcXG59KShOb3RpZmljYXRpb25LaW5kID0gZXhwb3J0cy5Ob3RpZmljYXRpb25LaW5kIHx8IChleHBvcnRzLk5vdGlmaWNhdGlvbktpbmQgPSB7fSkpO1xcbnZhciBOb3RpZmljYXRpb24gPSAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBOb3RpZmljYXRpb24oa2luZCwgdmFsdWUsIGVycm9yKSB7XFxuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGtpbmQgPT09ICdOJztcXG4gICAgfVxcbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcXG4gICAgICAgIHJldHVybiBvYnNlcnZlTm90aWZpY2F0aW9uKHRoaXMsIG9ic2VydmVyKTtcXG4gICAgfTtcXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5kbyA9IGZ1bmN0aW9uIChuZXh0SGFuZGxlciwgZXJyb3JIYW5kbGVyLCBjb21wbGV0ZUhhbmRsZXIpIHtcXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGtpbmQgPSBfYS5raW5kLCB2YWx1ZSA9IF9hLnZhbHVlLCBlcnJvciA9IF9hLmVycm9yO1xcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09ICdOJyA/IG5leHRIYW5kbGVyID09PSBudWxsIHx8IG5leHRIYW5kbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXh0SGFuZGxlcih2YWx1ZSkgOiBraW5kID09PSAnRScgPyBlcnJvckhhbmRsZXIgPT09IG51bGwgfHwgZXJyb3JIYW5kbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvckhhbmRsZXIoZXJyb3IpIDogY29tcGxldGVIYW5kbGVyID09PSBudWxsIHx8IGNvbXBsZXRlSGFuZGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcGxldGVIYW5kbGVyKCk7XFxuICAgIH07XFxuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbigoX2EgPSBuZXh0T3JPYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5leHQpXFxuICAgICAgICAgICAgPyB0aGlzLm9ic2VydmUobmV4dE9yT2JzZXJ2ZXIpXFxuICAgICAgICAgICAgOiB0aGlzLmRvKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xcbiAgICB9O1xcbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLnRvT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGtpbmQgPSBfYS5raW5kLCB2YWx1ZSA9IF9hLnZhbHVlLCBlcnJvciA9IF9hLmVycm9yO1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IGtpbmQgPT09ICdOJ1xcbiAgICAgICAgICAgID9cXG4gICAgICAgICAgICAgICAgb2ZfMS5vZih2YWx1ZSlcXG4gICAgICAgICAgICA6XFxuICAgICAgICAgICAgICAgIGtpbmQgPT09ICdFJ1xcbiAgICAgICAgICAgICAgICAgICAgP1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JfMS50aHJvd0Vycm9yKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yOyB9KVxcbiAgICAgICAgICAgICAgICAgICAgOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQgPT09ICdDJ1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbXB0eV8xLkVNUFRZXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XFxuICAgICAgICBpZiAoIXJlc3VsdCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlVuZXhwZWN0ZWQgbm90aWZpY2F0aW9uIGtpbmQgXFxcIiArIGtpbmQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfTtcXG4gICAgTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBuZXcgTm90aWZpY2F0aW9uKCdOJywgdmFsdWUpO1xcbiAgICB9O1xcbiAgICBOb3RpZmljYXRpb24uY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICByZXR1cm4gbmV3IE5vdGlmaWNhdGlvbignRScsIHVuZGVmaW5lZCwgZXJyKTtcXG4gICAgfTtcXG4gICAgTm90aWZpY2F0aW9uLmNyZWF0ZUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIE5vdGlmaWNhdGlvbi5jb21wbGV0ZU5vdGlmaWNhdGlvbjtcXG4gICAgfTtcXG4gICAgTm90aWZpY2F0aW9uLmNvbXBsZXRlTm90aWZpY2F0aW9uID0gbmV3IE5vdGlmaWNhdGlvbignQycpO1xcbiAgICByZXR1cm4gTm90aWZpY2F0aW9uO1xcbn0oKSk7XFxuZXhwb3J0cy5Ob3RpZmljYXRpb24gPSBOb3RpZmljYXRpb247XFxuZnVuY3Rpb24gb2JzZXJ2ZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb24sIG9ic2VydmVyKSB7XFxuICAgIHZhciBfYSwgX2IsIF9jO1xcbiAgICB2YXIgX2QgPSBub3RpZmljYXRpb24sIGtpbmQgPSBfZC5raW5kLCB2YWx1ZSA9IF9kLnZhbHVlLCBlcnJvciA9IF9kLmVycm9yO1xcbiAgICBpZiAodHlwZW9mIGtpbmQgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vdGlmaWNhdGlvbiwgbWlzc2luZyBcXFwia2luZFxcXCInKTtcXG4gICAgfVxcbiAgICBraW5kID09PSAnTicgPyAoX2EgPSBvYnNlcnZlci5uZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvYnNlcnZlciwgdmFsdWUpIDoga2luZCA9PT0gJ0UnID8gKF9iID0gb2JzZXJ2ZXIuZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKG9ic2VydmVyLCBlcnJvcikgOiAoX2MgPSBvYnNlcnZlci5jb21wbGV0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwob2JzZXJ2ZXIpO1xcbn1cXG5leHBvcnRzLm9ic2VydmVOb3RpZmljYXRpb24gPSBvYnNlcnZlTm90aWZpY2F0aW9uO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5vdGlmaWNhdGlvbi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9Ob3RpZmljYXRpb24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL05vdGlmaWNhdGlvbkZhY3Rvcmllcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL05vdGlmaWNhdGlvbkZhY3Rvcmllcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmNyZWF0ZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMubmV4dE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuZXJyb3JOb3RpZmljYXRpb24gPSBleHBvcnRzLkNPTVBMRVRFX05PVElGSUNBVElPTiA9IHZvaWQgMDtcXG5leHBvcnRzLkNPTVBMRVRFX05PVElGSUNBVElPTiA9IChmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVOb3RpZmljYXRpb24oJ0MnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7IH0pKCk7XFxuZnVuY3Rpb24gZXJyb3JOb3RpZmljYXRpb24oZXJyb3IpIHtcXG4gICAgcmV0dXJuIGNyZWF0ZU5vdGlmaWNhdGlvbignRScsIHVuZGVmaW5lZCwgZXJyb3IpO1xcbn1cXG5leHBvcnRzLmVycm9yTm90aWZpY2F0aW9uID0gZXJyb3JOb3RpZmljYXRpb247XFxuZnVuY3Rpb24gbmV4dE5vdGlmaWNhdGlvbih2YWx1ZSkge1xcbiAgICByZXR1cm4gY3JlYXRlTm90aWZpY2F0aW9uKCdOJywgdmFsdWUsIHVuZGVmaW5lZCk7XFxufVxcbmV4cG9ydHMubmV4dE5vdGlmaWNhdGlvbiA9IG5leHROb3RpZmljYXRpb247XFxuZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uKGtpbmQsIHZhbHVlLCBlcnJvcikge1xcbiAgICByZXR1cm4ge1xcbiAgICAgICAga2luZDoga2luZCxcXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcXG4gICAgICAgIGVycm9yOiBlcnJvcixcXG4gICAgfTtcXG59XFxuZXhwb3J0cy5jcmVhdGVOb3RpZmljYXRpb24gPSBjcmVhdGVOb3RpZmljYXRpb247XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm90aWZpY2F0aW9uRmFjdG9yaWVzLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL05vdGlmaWNhdGlvbkZhY3Rvcmllcy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLk9ic2VydmFibGUgPSB2b2lkIDA7XFxudmFyIFN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJzY3JpYmVyLmpzXFxcIik7XFxudmFyIFN1YnNjcmlwdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9TdWJzY3JpcHRpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvU3Vic2NyaXB0aW9uLmpzXFxcIik7XFxudmFyIG9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3ltYm9sL29ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc3ltYm9sL29ic2VydmFibGUuanNcXFwiKTtcXG52YXIgcGlwZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL3BpcGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9waXBlLmpzXFxcIik7XFxudmFyIGNvbmZpZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25maWcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvY29uZmlnLmpzXFxcIik7XFxudmFyIGlzRnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbC9pc0Z1bmN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNGdW5jdGlvbi5qc1xcXCIpO1xcbnZhciBlcnJvckNvbnRleHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbC9lcnJvckNvbnRleHQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9lcnJvckNvbnRleHQuanNcXFwiKTtcXG52YXIgT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XFxuICAgICAgICBpZiAoc3Vic2NyaWJlKSB7XFxuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcXG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcXG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcXG4gICAgICAgIG9ic2VydmFibGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xcbiAgICB9O1xcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIHZhciBzdWJzY3JpYmVyID0gaXNTdWJzY3JpYmVyKG9ic2VydmVyT3JOZXh0KSA/IG9ic2VydmVyT3JOZXh0IDogbmV3IFN1YnNjcmliZXJfMS5TYWZlU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcXG4gICAgICAgIGVycm9yQ29udGV4dF8xLmVycm9yQ29udGV4dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMsIG9wZXJhdG9yID0gX2Eub3BlcmF0b3IsIHNvdXJjZSA9IF9hLnNvdXJjZTtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmFkZChvcGVyYXRvclxcbiAgICAgICAgICAgICAgICA/XFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvci5jYWxsKHN1YnNjcmliZXIsIHNvdXJjZSlcXG4gICAgICAgICAgICAgICAgOiBzb3VyY2VcXG4gICAgICAgICAgICAgICAgICAgID9cXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3Vic2NyaWJlKHN1YnNjcmliZXIpXFxuICAgICAgICAgICAgICAgICAgICA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RyeVN1YnNjcmliZShzdWJzY3JpYmVyKSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xcbiAgICB9O1xcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gKHNpbmspIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShzaW5rKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICBzaW5rLmVycm9yKGVycik7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAobmV4dCwgcHJvbWlzZUN0b3IpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICBwcm9taXNlQ3RvciA9IGdldFByb21pc2VDdG9yKHByb21pc2VDdG9yKTtcXG4gICAgICAgIHJldHVybiBuZXcgcHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgICAgICAgIHZhciBzdWJzY3JpYmVyID0gbmV3IFN1YnNjcmliZXJfMS5TYWZlU3Vic2NyaWJlcih7XFxuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGVycm9yOiByZWplY3QsXFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiByZXNvbHZlLFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIF90aGlzLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnNvdXJjZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcXG4gICAgfTtcXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGVbb2JzZXJ2YWJsZV8xLm9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH07XFxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgb3BlcmF0aW9ucyA9IFtdO1xcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgICAgICBvcGVyYXRpb25zW19pXSA9IGFyZ3VtZW50c1tfaV07XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcGlwZV8xLnBpcGVGcm9tQXJyYXkob3BlcmF0aW9ucykodGhpcyk7XFxuICAgIH07XFxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnRvUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlQ3Rvcikge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIHByb21pc2VDdG9yID0gZ2V0UHJvbWlzZUN0b3IocHJvbWlzZUN0b3IpO1xcbiAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XFxuICAgICAgICAgICAgdmFyIHZhbHVlO1xcbiAgICAgICAgICAgIF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAoeCkgeyByZXR1cm4gKHZhbHVlID0geCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKHZhbHVlKTsgfSk7XFxuICAgICAgICB9KTtcXG4gICAgfTtcXG4gICAgT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlKSB7XFxuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIE9ic2VydmFibGU7XFxufSgpKTtcXG5leHBvcnRzLk9ic2VydmFibGUgPSBPYnNlcnZhYmxlO1xcbmZ1bmN0aW9uIGdldFByb21pc2VDdG9yKHByb21pc2VDdG9yKSB7XFxuICAgIHZhciBfYTtcXG4gICAgcmV0dXJuIChfYSA9IHByb21pc2VDdG9yICE9PSBudWxsICYmIHByb21pc2VDdG9yICE9PSB2b2lkIDAgPyBwcm9taXNlQ3RvciA6IGNvbmZpZ18xLmNvbmZpZy5Qcm9taXNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBQcm9taXNlO1xcbn1cXG5mdW5jdGlvbiBpc09ic2VydmVyKHZhbHVlKSB7XFxuICAgIHJldHVybiB2YWx1ZSAmJiBpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbih2YWx1ZS5uZXh0KSAmJiBpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbih2YWx1ZS5lcnJvcikgJiYgaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24odmFsdWUuY29tcGxldGUpO1xcbn1cXG5mdW5jdGlvbiBpc1N1YnNjcmliZXIodmFsdWUpIHtcXG4gICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSB8fCAoaXNPYnNlcnZlcih2YWx1ZSkgJiYgU3Vic2NyaXB0aW9uXzEuaXNTdWJzY3JpcHRpb24odmFsdWUpKTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2YWJsZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9SZXBsYXlTdWJqZWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1JlcGxheVN1YmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xcbiAgICB9O1xcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBiICE9PSBudWxsKVxcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXFxcIiArIFN0cmluZyhiKSArIFxcXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFxcXCIpO1xcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xcbiAgICB9O1xcbn0pKCk7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuUmVwbGF5U3ViamVjdCA9IHZvaWQgMDtcXG52YXIgU3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9TdWJqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YmplY3QuanNcXFwiKTtcXG52YXIgZGF0ZVRpbWVzdGFtcFByb3ZpZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NjaGVkdWxlci9kYXRlVGltZXN0YW1wUHJvdmlkZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL2RhdGVUaW1lc3RhbXBQcm92aWRlci5qc1xcXCIpO1xcbnZhciBSZXBsYXlTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcXG4gICAgX19leHRlbmRzKFJlcGxheVN1YmplY3QsIF9zdXBlcik7XFxuICAgIGZ1bmN0aW9uIFJlcGxheVN1YmplY3QoX2J1ZmZlclNpemUsIF93aW5kb3dUaW1lLCBfdGltZXN0YW1wUHJvdmlkZXIpIHtcXG4gICAgICAgIGlmIChfYnVmZmVyU2l6ZSA9PT0gdm9pZCAwKSB7IF9idWZmZXJTaXplID0gSW5maW5pdHk7IH1cXG4gICAgICAgIGlmIChfd2luZG93VGltZSA9PT0gdm9pZCAwKSB7IF93aW5kb3dUaW1lID0gSW5maW5pdHk7IH1cXG4gICAgICAgIGlmIChfdGltZXN0YW1wUHJvdmlkZXIgPT09IHZvaWQgMCkgeyBfdGltZXN0YW1wUHJvdmlkZXIgPSBkYXRlVGltZXN0YW1wUHJvdmlkZXJfMS5kYXRlVGltZXN0YW1wUHJvdmlkZXI7IH1cXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XFxuICAgICAgICBfdGhpcy5fYnVmZmVyU2l6ZSA9IF9idWZmZXJTaXplO1xcbiAgICAgICAgX3RoaXMuX3dpbmRvd1RpbWUgPSBfd2luZG93VGltZTtcXG4gICAgICAgIF90aGlzLl90aW1lc3RhbXBQcm92aWRlciA9IF90aW1lc3RhbXBQcm92aWRlcjtcXG4gICAgICAgIF90aGlzLl9idWZmZXIgPSBbXTtcXG4gICAgICAgIF90aGlzLl9pbmZpbml0ZVRpbWVXaW5kb3cgPSB0cnVlO1xcbiAgICAgICAgX3RoaXMuX2luZmluaXRlVGltZVdpbmRvdyA9IF93aW5kb3dUaW1lID09PSBJbmZpbml0eTtcXG4gICAgICAgIF90aGlzLl9idWZmZXJTaXplID0gTWF0aC5tYXgoMSwgX2J1ZmZlclNpemUpO1xcbiAgICAgICAgX3RoaXMuX3dpbmRvd1RpbWUgPSBNYXRoLm1heCgxLCBfd2luZG93VGltZSk7XFxuICAgICAgICByZXR1cm4gX3RoaXM7XFxuICAgIH1cXG4gICAgUmVwbGF5U3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgdmFyIF9hID0gdGhpcywgaXNTdG9wcGVkID0gX2EuaXNTdG9wcGVkLCBfYnVmZmVyID0gX2EuX2J1ZmZlciwgX2luZmluaXRlVGltZVdpbmRvdyA9IF9hLl9pbmZpbml0ZVRpbWVXaW5kb3csIF90aW1lc3RhbXBQcm92aWRlciA9IF9hLl90aW1lc3RhbXBQcm92aWRlciwgX3dpbmRvd1RpbWUgPSBfYS5fd2luZG93VGltZTtcXG4gICAgICAgIGlmICghaXNTdG9wcGVkKSB7XFxuICAgICAgICAgICAgX2J1ZmZlci5wdXNoKHZhbHVlKTtcXG4gICAgICAgICAgICAhX2luZmluaXRlVGltZVdpbmRvdyAmJiBfYnVmZmVyLnB1c2goX3RpbWVzdGFtcFByb3ZpZGVyLm5vdygpICsgX3dpbmRvd1RpbWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5fdHJpbUJ1ZmZlcigpO1xcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcywgdmFsdWUpO1xcbiAgICB9O1xcbiAgICBSZXBsYXlTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHRoaXMuX3Rocm93SWZDbG9zZWQoKTtcXG4gICAgICAgIHRoaXMuX3RyaW1CdWZmZXIoKTtcXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9pbm5lclN1YnNjcmliZShzdWJzY3JpYmVyKTtcXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF9pbmZpbml0ZVRpbWVXaW5kb3cgPSBfYS5faW5maW5pdGVUaW1lV2luZG93LCBfYnVmZmVyID0gX2EuX2J1ZmZlcjtcXG4gICAgICAgIHZhciBjb3B5ID0gX2J1ZmZlci5zbGljZSgpO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3B5Lmxlbmd0aCAmJiAhc3Vic2NyaWJlci5jbG9zZWQ7IGkgKz0gX2luZmluaXRlVGltZVdpbmRvdyA/IDEgOiAyKSB7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGNvcHlbaV0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5fY2hlY2tGaW5hbGl6ZWRTdGF0dXNlcyhzdWJzY3JpYmVyKTtcXG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XFxuICAgIH07XFxuICAgIFJlcGxheVN1YmplY3QucHJvdG90eXBlLl90cmltQnVmZmVyID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIF9hID0gdGhpcywgX2J1ZmZlclNpemUgPSBfYS5fYnVmZmVyU2l6ZSwgX3RpbWVzdGFtcFByb3ZpZGVyID0gX2EuX3RpbWVzdGFtcFByb3ZpZGVyLCBfYnVmZmVyID0gX2EuX2J1ZmZlciwgX2luZmluaXRlVGltZVdpbmRvdyA9IF9hLl9pbmZpbml0ZVRpbWVXaW5kb3c7XFxuICAgICAgICB2YXIgYWRqdXN0ZWRCdWZmZXJTaXplID0gKF9pbmZpbml0ZVRpbWVXaW5kb3cgPyAxIDogMikgKiBfYnVmZmVyU2l6ZTtcXG4gICAgICAgIF9idWZmZXJTaXplIDwgSW5maW5pdHkgJiYgYWRqdXN0ZWRCdWZmZXJTaXplIDwgX2J1ZmZlci5sZW5ndGggJiYgX2J1ZmZlci5zcGxpY2UoMCwgX2J1ZmZlci5sZW5ndGggLSBhZGp1c3RlZEJ1ZmZlclNpemUpO1xcbiAgICAgICAgaWYgKCFfaW5maW5pdGVUaW1lV2luZG93KSB7XFxuICAgICAgICAgICAgdmFyIG5vdyA9IF90aW1lc3RhbXBQcm92aWRlci5ub3coKTtcXG4gICAgICAgICAgICB2YXIgbGFzdCA9IDA7XFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBfYnVmZmVyLmxlbmd0aCAmJiBfYnVmZmVyW2ldIDw9IG5vdzsgaSArPSAyKSB7XFxuICAgICAgICAgICAgICAgIGxhc3QgPSBpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBsYXN0ICYmIF9idWZmZXIuc3BsaWNlKDAsIGxhc3QgKyAxKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgcmV0dXJuIFJlcGxheVN1YmplY3Q7XFxufShTdWJqZWN0XzEuU3ViamVjdCkpO1xcbmV4cG9ydHMuUmVwbGF5U3ViamVjdCA9IFJlcGxheVN1YmplY3Q7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVwbGF5U3ViamVjdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9SZXBsYXlTdWJqZWN0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TY2hlZHVsZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TY2hlZHVsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5TY2hlZHVsZXIgPSB2b2lkIDA7XFxudmFyIGRhdGVUaW1lc3RhbXBQcm92aWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zY2hlZHVsZXIvZGF0ZVRpbWVzdGFtcFByb3ZpZGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9kYXRlVGltZXN0YW1wUHJvdmlkZXIuanNcXFwiKTtcXG52YXIgU2NoZWR1bGVyID0gKGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gU2NoZWR1bGVyKHNjaGVkdWxlckFjdGlvbkN0b3IsIG5vdykge1xcbiAgICAgICAgaWYgKG5vdyA9PT0gdm9pZCAwKSB7IG5vdyA9IFNjaGVkdWxlci5ub3c7IH1cXG4gICAgICAgIHRoaXMuc2NoZWR1bGVyQWN0aW9uQ3RvciA9IHNjaGVkdWxlckFjdGlvbkN0b3I7XFxuICAgICAgICB0aGlzLm5vdyA9IG5vdztcXG4gICAgfVxcbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHdvcmssIGRlbGF5LCBzdGF0ZSkge1xcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XFxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuc2NoZWR1bGVyQWN0aW9uQ3Rvcih0aGlzLCB3b3JrKS5zY2hlZHVsZShzdGF0ZSwgZGVsYXkpO1xcbiAgICB9O1xcbiAgICBTY2hlZHVsZXIubm93ID0gZGF0ZVRpbWVzdGFtcFByb3ZpZGVyXzEuZGF0ZVRpbWVzdGFtcFByb3ZpZGVyLm5vdztcXG4gICAgcmV0dXJuIFNjaGVkdWxlcjtcXG59KCkpO1xcbmV4cG9ydHMuU2NoZWR1bGVyID0gU2NoZWR1bGVyO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjaGVkdWxlci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TY2hlZHVsZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvU3ViamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxuICAgIH07XFxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIGIgIT09IG51bGwpXFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcXFwiICsgU3RyaW5nKGIpICsgXFxcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXFxcIik7XFxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XFxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XFxuICAgIH07XFxufSkoKTtcXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XFxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcXFwibnVtYmVyXFxcIikgcmV0dXJuIHtcXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXFxcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXFxcIiA6IFxcXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXFxcIik7XFxufTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5Bbm9ueW1vdXNTdWJqZWN0ID0gZXhwb3J0cy5TdWJqZWN0ID0gdm9pZCAwO1xcbnZhciBPYnNlcnZhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbnZhciBTdWJzY3JpcHRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vU3Vic2NyaXB0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YnNjcmlwdGlvbi5qc1xcXCIpO1xcbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanNcXFwiKTtcXG52YXIgYXJyUmVtb3ZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwvYXJyUmVtb3ZlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJyUmVtb3ZlLmpzXFxcIik7XFxudmFyIGVycm9yQ29udGV4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL2Vycm9yQ29udGV4dCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2Vycm9yQ29udGV4dC5qc1xcXCIpO1xcbnZhciBTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcXG4gICAgX19leHRlbmRzKFN1YmplY3QsIF9zdXBlcik7XFxuICAgIGZ1bmN0aW9uIFN1YmplY3QoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xcbiAgICAgICAgX3RoaXMuY2xvc2VkID0gZmFsc2U7XFxuICAgICAgICBfdGhpcy5jdXJyZW50T2JzZXJ2ZXJzID0gbnVsbDtcXG4gICAgICAgIF90aGlzLm9ic2VydmVycyA9IFtdO1xcbiAgICAgICAgX3RoaXMuaXNTdG9wcGVkID0gZmFsc2U7XFxuICAgICAgICBfdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xcbiAgICAgICAgX3RoaXMudGhyb3duRXJyb3IgPSBudWxsO1xcbiAgICAgICAgcmV0dXJuIF90aGlzO1xcbiAgICB9XFxuICAgIFN1YmplY3QucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcXG4gICAgICAgIHZhciBzdWJqZWN0ID0gbmV3IEFub255bW91c1N1YmplY3QodGhpcywgdGhpcyk7XFxuICAgICAgICBzdWJqZWN0Lm9wZXJhdG9yID0gb3BlcmF0b3I7XFxuICAgICAgICByZXR1cm4gc3ViamVjdDtcXG4gICAgfTtcXG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3Rocm93SWZDbG9zZWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgZXJyb3JDb250ZXh0XzEuZXJyb3JDb250ZXh0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgZV8xLCBfYTtcXG4gICAgICAgICAgICBfdGhpcy5fdGhyb3dJZkNsb3NlZCgpO1xcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNTdG9wcGVkKSB7XFxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuY3VycmVudE9ic2VydmVycykge1xcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudE9ic2VydmVycyA9IEFycmF5LmZyb20oX3RoaXMub2JzZXJ2ZXJzKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhfdGhpcy5jdXJyZW50T2JzZXJ2ZXJzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlciA9IF9jLnZhbHVlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XFxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfTtcXG4gICAgU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgZXJyb3JDb250ZXh0XzEuZXJyb3JDb250ZXh0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBfdGhpcy5fdGhyb3dJZkNsb3NlZCgpO1xcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNTdG9wcGVkKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLmhhc0Vycm9yID0gX3RoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgX3RoaXMudGhyb3duRXJyb3IgPSBlcnI7XFxuICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlcnMgPSBfdGhpcy5vYnNlcnZlcnM7XFxuICAgICAgICAgICAgICAgIHdoaWxlIChvYnNlcnZlcnMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlcnMuc2hpZnQoKS5lcnJvcihlcnIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH07XFxuICAgIFN1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIGVycm9yQ29udGV4dF8xLmVycm9yQ29udGV4dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgX3RoaXMuX3Rocm93SWZDbG9zZWQoKTtcXG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzU3RvcHBlZCkge1xcbiAgICAgICAgICAgICAgICBfdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gX3RoaXMub2JzZXJ2ZXJzO1xcbiAgICAgICAgICAgICAgICB3aGlsZSAob2JzZXJ2ZXJzLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnNoaWZ0KCkuY29tcGxldGUoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbiAgICBTdWJqZWN0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdGhpcy5jbG9zZWQgPSB0cnVlO1xcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSB0aGlzLmN1cnJlbnRPYnNlcnZlcnMgPSBudWxsO1xcbiAgICB9O1xcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3ViamVjdC5wcm90b3R5cGUsIFxcXCJvYnNlcnZlZFxcXCIsIHtcXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBfYTtcXG4gICAgICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMub2JzZXJ2ZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSA+IDA7XFxuICAgICAgICB9LFxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcXG4gICAgfSk7XFxuICAgIFN1YmplY3QucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgdGhpcy5fdGhyb3dJZkNsb3NlZCgpO1xcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX3RyeVN1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xcbiAgICB9O1xcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHRoaXMuX3Rocm93SWZDbG9zZWQoKTtcXG4gICAgICAgIHRoaXMuX2NoZWNrRmluYWxpemVkU3RhdHVzZXMoc3Vic2NyaWJlcik7XFxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXJTdWJzY3JpYmUoc3Vic2NyaWJlcik7XFxuICAgIH07XFxuICAgIFN1YmplY3QucHJvdG90eXBlLl9pbm5lclN1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdmFyIF9hID0gdGhpcywgaGFzRXJyb3IgPSBfYS5oYXNFcnJvciwgaXNTdG9wcGVkID0gX2EuaXNTdG9wcGVkLCBvYnNlcnZlcnMgPSBfYS5vYnNlcnZlcnM7XFxuICAgICAgICBpZiAoaGFzRXJyb3IgfHwgaXNTdG9wcGVkKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLkVNUFRZX1NVQlNDUklQVElPTjtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuY3VycmVudE9ic2VydmVycyA9IG51bGw7XFxuICAgICAgICBvYnNlcnZlcnMucHVzaChzdWJzY3JpYmVyKTtcXG4gICAgICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50T2JzZXJ2ZXJzID0gbnVsbDtcXG4gICAgICAgICAgICBhcnJSZW1vdmVfMS5hcnJSZW1vdmUob2JzZXJ2ZXJzLCBzdWJzY3JpYmVyKTtcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fY2hlY2tGaW5hbGl6ZWRTdGF0dXNlcyA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBoYXNFcnJvciA9IF9hLmhhc0Vycm9yLCB0aHJvd25FcnJvciA9IF9hLnRocm93bkVycm9yLCBpc1N0b3BwZWQgPSBfYS5pc1N0b3BwZWQ7XFxuICAgICAgICBpZiAoaGFzRXJyb3IpIHtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHRocm93bkVycm9yKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGlzU3RvcHBlZCkge1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgU3ViamVjdC5wcm90b3R5cGUuYXNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoKTtcXG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xcbiAgICB9O1xcbiAgICBTdWJqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChkZXN0aW5hdGlvbiwgc291cmNlKSB7XFxuICAgICAgICByZXR1cm4gbmV3IEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSk7XFxuICAgIH07XFxuICAgIHJldHVybiBTdWJqZWN0O1xcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcXG5leHBvcnRzLlN1YmplY3QgPSBTdWJqZWN0O1xcbnZhciBBbm9ueW1vdXNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcXG4gICAgX19leHRlbmRzKEFub255bW91c1N1YmplY3QsIF9zdXBlcik7XFxuICAgIGZ1bmN0aW9uIEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSkge1xcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcXG4gICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XFxuICAgICAgICBfdGhpcy5zb3VyY2UgPSBzb3VyY2U7XFxuICAgICAgICByZXR1cm4gX3RoaXM7XFxuICAgIH1cXG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgdmFyIF9hLCBfYjtcXG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuZGVzdGluYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdmFsdWUpO1xcbiAgICB9O1xcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICAgIHZhciBfYSwgX2I7XFxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmRlc3RpbmF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBlcnIpO1xcbiAgICB9O1xcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBfYSwgX2I7XFxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmRlc3RpbmF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29tcGxldGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcXG4gICAgfTtcXG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgX2EsIF9iO1xcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuc291cmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3Vic2NyaWJlKHN1YnNjcmliZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBTdWJzY3JpcHRpb25fMS5FTVBUWV9TVUJTQ1JJUFRJT047XFxuICAgIH07XFxuICAgIHJldHVybiBBbm9ueW1vdXNTdWJqZWN0O1xcbn0oU3ViamVjdCkpO1xcbmV4cG9ydHMuQW5vbnltb3VzU3ViamVjdCA9IEFub255bW91c1N1YmplY3Q7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ViamVjdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJqZWN0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJzY3JpYmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YnNjcmliZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xcbiAgICB9O1xcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBiICE9PSBudWxsKVxcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXFxcIiArIFN0cmluZyhiKSArIFxcXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFxcXCIpO1xcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xcbiAgICB9O1xcbn0pKCk7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuRU1QVFlfT0JTRVJWRVIgPSBleHBvcnRzLlNhZmVTdWJzY3JpYmVyID0gZXhwb3J0cy5TdWJzY3JpYmVyID0gdm9pZCAwO1xcbnZhciBpc0Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwvaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG52YXIgU3Vic2NyaXB0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1N1YnNjcmlwdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJzY3JpcHRpb24uanNcXFwiKTtcXG52YXIgY29uZmlnXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbmZpZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9jb25maWcuanNcXFwiKTtcXG52YXIgcmVwb3J0VW5oYW5kbGVkRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbC9yZXBvcnRVbmhhbmRsZWRFcnJvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL3JlcG9ydFVuaGFuZGxlZEVycm9yLmpzXFxcIik7XFxudmFyIG5vb3BfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbC9ub29wICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbm9vcC5qc1xcXCIpO1xcbnZhciBOb3RpZmljYXRpb25GYWN0b3JpZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vTm90aWZpY2F0aW9uRmFjdG9yaWVzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL05vdGlmaWNhdGlvbkZhY3Rvcmllcy5qc1xcXCIpO1xcbnZhciB0aW1lb3V0UHJvdmlkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2NoZWR1bGVyL3RpbWVvdXRQcm92aWRlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvdGltZW91dFByb3ZpZGVyLmpzXFxcIik7XFxudmFyIGVycm9yQ29udGV4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL2Vycm9yQ29udGV4dCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2Vycm9yQ29udGV4dC5qc1xcXCIpO1xcbnZhciBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcXG4gICAgX19leHRlbmRzKFN1YnNjcmliZXIsIF9zdXBlcik7XFxuICAgIGZ1bmN0aW9uIFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XFxuICAgICAgICBfdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcXG4gICAgICAgIGlmIChkZXN0aW5hdGlvbikge1xcbiAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XFxuICAgICAgICAgICAgaWYgKFN1YnNjcmlwdGlvbl8xLmlzU3Vic2NyaXB0aW9uKGRlc3RpbmF0aW9uKSkge1xcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5hZGQoX3RoaXMpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZXhwb3J0cy5FTVBUWV9PQlNFUlZFUjtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBfdGhpcztcXG4gICAgfVxcbiAgICBTdWJzY3JpYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcXG4gICAgICAgIHJldHVybiBuZXcgU2FmZVN1YnNjcmliZXIobmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcXG4gICAgfTtcXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XFxuICAgICAgICAgICAgaGFuZGxlU3RvcHBlZE5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25GYWN0b3JpZXNfMS5uZXh0Tm90aWZpY2F0aW9uKHZhbHVlKSwgdGhpcyk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLl9uZXh0KHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHtcXG4gICAgICAgICAgICBoYW5kbGVTdG9wcGVkTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbkZhY3Rvcmllc18xLmVycm9yTm90aWZpY2F0aW9uKGVyciksIHRoaXMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XFxuICAgICAgICAgICAgaGFuZGxlU3RvcHBlZE5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25GYWN0b3JpZXNfMS5DT01QTEVURV9OT1RJRklDQVRJT04sIHRoaXMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NlZCkge1xcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XFxuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG51bGw7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xcbiAgICB9O1xcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZpbmFsbHkge1xcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XFxuICAgICAgICB9XFxuICAgICAgICBmaW5hbGx5IHtcXG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIHJldHVybiBTdWJzY3JpYmVyO1xcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XFxuZXhwb3J0cy5TdWJzY3JpYmVyID0gU3Vic2NyaWJlcjtcXG52YXIgX2JpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcXG5mdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XFxuICAgIHJldHVybiBfYmluZC5jYWxsKGZuLCB0aGlzQXJnKTtcXG59XFxudmFyIENvbnN1bWVyT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBDb25zdW1lck9ic2VydmVyKHBhcnRpYWxPYnNlcnZlcikge1xcbiAgICAgICAgdGhpcy5wYXJ0aWFsT2JzZXJ2ZXIgPSBwYXJ0aWFsT2JzZXJ2ZXI7XFxuICAgIH1cXG4gICAgQ29uc3VtZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgdmFyIHBhcnRpYWxPYnNlcnZlciA9IHRoaXMucGFydGlhbE9ic2VydmVyO1xcbiAgICAgICAgaWYgKHBhcnRpYWxPYnNlcnZlci5uZXh0KSB7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgcGFydGlhbE9ic2VydmVyLm5leHQodmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcXG4gICAgICAgICAgICAgICAgaGFuZGxlVW5oYW5kbGVkRXJyb3IoZXJyb3IpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgQ29uc3VtZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICB2YXIgcGFydGlhbE9ic2VydmVyID0gdGhpcy5wYXJ0aWFsT2JzZXJ2ZXI7XFxuICAgICAgICBpZiAocGFydGlhbE9ic2VydmVyLmVycm9yKSB7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgcGFydGlhbE9ic2VydmVyLmVycm9yKGVycik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xcbiAgICAgICAgICAgICAgICBoYW5kbGVVbmhhbmRsZWRFcnJvcihlcnJvcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgaGFuZGxlVW5oYW5kbGVkRXJyb3IoZXJyKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgQ29uc3VtZXJPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgcGFydGlhbE9ic2VydmVyID0gdGhpcy5wYXJ0aWFsT2JzZXJ2ZXI7XFxuICAgICAgICBpZiAocGFydGlhbE9ic2VydmVyLmNvbXBsZXRlKSB7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgcGFydGlhbE9ic2VydmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xcbiAgICAgICAgICAgICAgICBoYW5kbGVVbmhhbmRsZWRFcnJvcihlcnJvcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICByZXR1cm4gQ29uc3VtZXJPYnNlcnZlcjtcXG59KCkpO1xcbnZhciBTYWZlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XFxuICAgIF9fZXh0ZW5kcyhTYWZlU3Vic2NyaWJlciwgX3N1cGVyKTtcXG4gICAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcXG4gICAgICAgIHZhciBwYXJ0aWFsT2JzZXJ2ZXI7XFxuICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24ob2JzZXJ2ZXJPck5leHQpIHx8ICFvYnNlcnZlck9yTmV4dCkge1xcbiAgICAgICAgICAgIHBhcnRpYWxPYnNlcnZlciA9IHtcXG4gICAgICAgICAgICAgICAgbmV4dDogKG9ic2VydmVyT3JOZXh0ICE9PSBudWxsICYmIG9ic2VydmVyT3JOZXh0ICE9PSB2b2lkIDAgPyBvYnNlcnZlck9yTmV4dCA6IHVuZGVmaW5lZCksXFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciAhPT0gbnVsbCAmJiBlcnJvciAhPT0gdm9pZCAwID8gZXJyb3IgOiB1bmRlZmluZWQsXFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZSAhPT0gbnVsbCAmJiBjb21wbGV0ZSAhPT0gdm9pZCAwID8gY29tcGxldGUgOiB1bmRlZmluZWQsXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHZhciBjb250ZXh0XzE7XFxuICAgICAgICAgICAgaWYgKF90aGlzICYmIGNvbmZpZ18xLmNvbmZpZy51c2VEZXByZWNhdGVkTmV4dENvbnRleHQpIHtcXG4gICAgICAgICAgICAgICAgY29udGV4dF8xID0gT2JqZWN0LmNyZWF0ZShvYnNlcnZlck9yTmV4dCk7XFxuICAgICAgICAgICAgICAgIGNvbnRleHRfMS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVuc3Vic2NyaWJlKCk7IH07XFxuICAgICAgICAgICAgICAgIHBhcnRpYWxPYnNlcnZlciA9IHtcXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG9ic2VydmVyT3JOZXh0Lm5leHQgJiYgYmluZChvYnNlcnZlck9yTmV4dC5uZXh0LCBjb250ZXh0XzEpLFxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG9ic2VydmVyT3JOZXh0LmVycm9yICYmIGJpbmQob2JzZXJ2ZXJPck5leHQuZXJyb3IsIGNvbnRleHRfMSksXFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogb2JzZXJ2ZXJPck5leHQuY29tcGxldGUgJiYgYmluZChvYnNlcnZlck9yTmV4dC5jb21wbGV0ZSwgY29udGV4dF8xKSxcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIHBhcnRpYWxPYnNlcnZlciA9IG9ic2VydmVyT3JOZXh0O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gbmV3IENvbnN1bWVyT2JzZXJ2ZXIocGFydGlhbE9ic2VydmVyKTtcXG4gICAgICAgIHJldHVybiBfdGhpcztcXG4gICAgfVxcbiAgICByZXR1cm4gU2FmZVN1YnNjcmliZXI7XFxufShTdWJzY3JpYmVyKSk7XFxuZXhwb3J0cy5TYWZlU3Vic2NyaWJlciA9IFNhZmVTdWJzY3JpYmVyO1xcbmZ1bmN0aW9uIGhhbmRsZVVuaGFuZGxlZEVycm9yKGVycm9yKSB7XFxuICAgIGlmIChjb25maWdfMS5jb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xcbiAgICAgICAgZXJyb3JDb250ZXh0XzEuY2FwdHVyZUVycm9yKGVycm9yKTtcXG4gICAgfVxcbiAgICBlbHNlIHtcXG4gICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yXzEucmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyb3IpO1xcbiAgICB9XFxufVxcbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyKSB7XFxuICAgIHRocm93IGVycjtcXG59XFxuZnVuY3Rpb24gaGFuZGxlU3RvcHBlZE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24sIHN1YnNjcmliZXIpIHtcXG4gICAgdmFyIG9uU3RvcHBlZE5vdGlmaWNhdGlvbiA9IGNvbmZpZ18xLmNvbmZpZy5vblN0b3BwZWROb3RpZmljYXRpb247XFxuICAgIG9uU3RvcHBlZE5vdGlmaWNhdGlvbiAmJiB0aW1lb3V0UHJvdmlkZXJfMS50aW1lb3V0UHJvdmlkZXIuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBvblN0b3BwZWROb3RpZmljYXRpb24obm90aWZpY2F0aW9uLCBzdWJzY3JpYmVyKTsgfSk7XFxufVxcbmV4cG9ydHMuRU1QVFlfT0JTRVJWRVIgPSB7XFxuICAgIGNsb3NlZDogdHJ1ZSxcXG4gICAgbmV4dDogbm9vcF8xLm5vb3AsXFxuICAgIGVycm9yOiBkZWZhdWx0RXJyb3JIYW5kbGVyLFxcbiAgICBjb21wbGV0ZTogbm9vcF8xLm5vb3AsXFxufTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpYmVyLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YnNjcmliZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YnNjcmlwdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YnNjcmlwdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XFxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXFxcIm51bWJlclxcXCIpIHJldHVybiB7XFxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFxcXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlxcXCIgOiBcXFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlxcXCIpO1xcbn07XFxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xcbiAgICBpZiAoIW0pIHJldHVybiBvO1xcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xcbiAgICB9XFxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxcbiAgICBmaW5hbGx5IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXFxcInJldHVyblxcXCJdKSkgbS5jYWxsKGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFyO1xcbn07XFxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcXG4gICAgcmV0dXJuIHRvO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuaXNTdWJzY3JpcHRpb24gPSBleHBvcnRzLkVNUFRZX1NVQlNDUklQVElPTiA9IGV4cG9ydHMuU3Vic2NyaXB0aW9uID0gdm9pZCAwO1xcbnZhciBpc0Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwvaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG52YXIgVW5zdWJzY3JpcHRpb25FcnJvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yLmpzXFxcIik7XFxudmFyIGFyclJlbW92ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL2FyclJlbW92ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyclJlbW92ZS5qc1xcXCIpO1xcbnZhciBTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb24oaW5pdGlhbFRlYXJkb3duKSB7XFxuICAgICAgICB0aGlzLmluaXRpYWxUZWFyZG93biA9IGluaXRpYWxUZWFyZG93bjtcXG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XFxuICAgICAgICB0aGlzLl9wYXJlbnRhZ2UgPSBudWxsO1xcbiAgICAgICAgdGhpcy5fZmluYWxpemVycyA9IG51bGw7XFxuICAgIH1cXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xcbiAgICAgICAgdmFyIGVycm9ycztcXG4gICAgICAgIGlmICghdGhpcy5jbG9zZWQpIHtcXG4gICAgICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XFxuICAgICAgICAgICAgdmFyIF9wYXJlbnRhZ2UgPSB0aGlzLl9wYXJlbnRhZ2U7XFxuICAgICAgICAgICAgaWYgKF9wYXJlbnRhZ2UpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50YWdlID0gbnVsbDtcXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX3BhcmVudGFnZSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX3BhcmVudGFnZV8xID0gX192YWx1ZXMoX3BhcmVudGFnZSksIF9wYXJlbnRhZ2VfMV8xID0gX3BhcmVudGFnZV8xLm5leHQoKTsgIV9wYXJlbnRhZ2VfMV8xLmRvbmU7IF9wYXJlbnRhZ2VfMV8xID0gX3BhcmVudGFnZV8xLm5leHQoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBfcGFyZW50YWdlXzFfMS52YWx1ZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50XzEucmVtb3ZlKHRoaXMpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XFxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3BhcmVudGFnZV8xXzEgJiYgIV9wYXJlbnRhZ2VfMV8xLmRvbmUgJiYgKF9hID0gX3BhcmVudGFnZV8xLnJldHVybikpIF9hLmNhbGwoX3BhcmVudGFnZV8xKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgX3BhcmVudGFnZS5yZW1vdmUodGhpcyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdmFyIGluaXRpYWxGaW5hbGl6ZXIgPSB0aGlzLmluaXRpYWxUZWFyZG93bjtcXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oaW5pdGlhbEZpbmFsaXplcikpIHtcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxGaW5hbGl6ZXIoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZSBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yID8gZS5lcnJvcnMgOiBbZV07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdmFyIF9maW5hbGl6ZXJzID0gdGhpcy5fZmluYWxpemVycztcXG4gICAgICAgICAgICBpZiAoX2ZpbmFsaXplcnMpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5fZmluYWxpemVycyA9IG51bGw7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZmluYWxpemVyc18xID0gX192YWx1ZXMoX2ZpbmFsaXplcnMpLCBfZmluYWxpemVyc18xXzEgPSBfZmluYWxpemVyc18xLm5leHQoKTsgIV9maW5hbGl6ZXJzXzFfMS5kb25lOyBfZmluYWxpemVyc18xXzEgPSBfZmluYWxpemVyc18xLm5leHQoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbGl6ZXIgPSBfZmluYWxpemVyc18xXzEudmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0ZpbmFsaXplcihmaW5hbGl6ZXIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyAhPT0gbnVsbCAmJiBlcnJvcnMgIT09IHZvaWQgMCA/IGVycm9ycyA6IFtdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGVycm9ycykpLCBfX3JlYWQoZXJyLmVycm9ycykpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9maW5hbGl6ZXJzXzFfMSAmJiAhX2ZpbmFsaXplcnNfMV8xLmRvbmUgJiYgKF9iID0gX2ZpbmFsaXplcnNfMS5yZXR1cm4pKSBfYi5jYWxsKF9maW5hbGl6ZXJzXzEpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChlcnJvcnMpIHtcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0ZWFyZG93bikge1xcbiAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgaWYgKHRlYXJkb3duICYmIHRlYXJkb3duICE9PSB0aGlzKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XFxuICAgICAgICAgICAgICAgIGV4ZWNGaW5hbGl6ZXIodGVhcmRvd24pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duIGluc3RhbmNlb2YgU3Vic2NyaXB0aW9uKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodGVhcmRvd24uY2xvc2VkIHx8IHRlYXJkb3duLl9oYXNQYXJlbnQodGhpcykpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bi5fYWRkUGFyZW50KHRoaXMpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICh0aGlzLl9maW5hbGl6ZXJzID0gKF9hID0gdGhpcy5fZmluYWxpemVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLnB1c2godGVhcmRvd24pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5faGFzUGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkge1xcbiAgICAgICAgdmFyIF9wYXJlbnRhZ2UgPSB0aGlzLl9wYXJlbnRhZ2U7XFxuICAgICAgICByZXR1cm4gX3BhcmVudGFnZSA9PT0gcGFyZW50IHx8IChBcnJheS5pc0FycmF5KF9wYXJlbnRhZ2UpICYmIF9wYXJlbnRhZ2UuaW5jbHVkZXMocGFyZW50KSk7XFxuICAgIH07XFxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX2FkZFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcXG4gICAgICAgIHZhciBfcGFyZW50YWdlID0gdGhpcy5fcGFyZW50YWdlO1xcbiAgICAgICAgdGhpcy5fcGFyZW50YWdlID0gQXJyYXkuaXNBcnJheShfcGFyZW50YWdlKSA/IChfcGFyZW50YWdlLnB1c2gocGFyZW50KSwgX3BhcmVudGFnZSkgOiBfcGFyZW50YWdlID8gW19wYXJlbnRhZ2UsIHBhcmVudF0gOiBwYXJlbnQ7XFxuICAgIH07XFxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX3JlbW92ZVBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcXG4gICAgICAgIHZhciBfcGFyZW50YWdlID0gdGhpcy5fcGFyZW50YWdlO1xcbiAgICAgICAgaWYgKF9wYXJlbnRhZ2UgPT09IHBhcmVudCkge1xcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudGFnZSA9IG51bGw7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KF9wYXJlbnRhZ2UpKSB7XFxuICAgICAgICAgICAgYXJyUmVtb3ZlXzEuYXJyUmVtb3ZlKF9wYXJlbnRhZ2UsIHBhcmVudCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHRlYXJkb3duKSB7XFxuICAgICAgICB2YXIgX2ZpbmFsaXplcnMgPSB0aGlzLl9maW5hbGl6ZXJzO1xcbiAgICAgICAgX2ZpbmFsaXplcnMgJiYgYXJyUmVtb3ZlXzEuYXJyUmVtb3ZlKF9maW5hbGl6ZXJzLCB0ZWFyZG93bik7XFxuICAgICAgICBpZiAodGVhcmRvd24gaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pIHtcXG4gICAgICAgICAgICB0ZWFyZG93bi5fcmVtb3ZlUGFyZW50KHRoaXMpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBTdWJzY3JpcHRpb24uRU1QVFkgPSAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGVtcHR5ID0gbmV3IFN1YnNjcmlwdGlvbigpO1xcbiAgICAgICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcXG4gICAgICAgIHJldHVybiBlbXB0eTtcXG4gICAgfSkoKTtcXG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcXG59KCkpO1xcbmV4cG9ydHMuU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uO1xcbmV4cG9ydHMuRU1QVFlfU1VCU0NSSVBUSU9OID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xcbmZ1bmN0aW9uIGlzU3Vic2NyaXB0aW9uKHZhbHVlKSB7XFxuICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24gfHxcXG4gICAgICAgICh2YWx1ZSAmJiAnY2xvc2VkJyBpbiB2YWx1ZSAmJiBpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbih2YWx1ZS5yZW1vdmUpICYmIGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKHZhbHVlLmFkZCkgJiYgaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24odmFsdWUudW5zdWJzY3JpYmUpKSk7XFxufVxcbmV4cG9ydHMuaXNTdWJzY3JpcHRpb24gPSBpc1N1YnNjcmlwdGlvbjtcXG5mdW5jdGlvbiBleGVjRmluYWxpemVyKGZpbmFsaXplcikge1xcbiAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oZmluYWxpemVyKSkge1xcbiAgICAgICAgZmluYWxpemVyKCk7XFxuICAgIH1cXG4gICAgZWxzZSB7XFxuICAgICAgICBmaW5hbGl6ZXIudW5zdWJzY3JpYmUoKTtcXG4gICAgfVxcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpcHRpb24uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvU3Vic2NyaXB0aW9uLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9jb25maWcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9jb25maWcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5jb25maWcgPSB2b2lkIDA7XFxuZXhwb3J0cy5jb25maWcgPSB7XFxuICAgIG9uVW5oYW5kbGVkRXJyb3I6IG51bGwsXFxuICAgIG9uU3RvcHBlZE5vdGlmaWNhdGlvbjogbnVsbCxcXG4gICAgUHJvbWlzZTogdW5kZWZpbmVkLFxcbiAgICB1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nOiBmYWxzZSxcXG4gICAgdXNlRGVwcmVjYXRlZE5leHRDb250ZXh0OiBmYWxzZSxcXG59O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpZy5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9jb25maWcuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL2ZpcnN0VmFsdWVGcm9tLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9maXJzdFZhbHVlRnJvbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZmlyc3RWYWx1ZUZyb20gPSB2b2lkIDA7XFxudmFyIEVtcHR5RXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbC9FbXB0eUVycm9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvRW1wdHlFcnJvci5qc1xcXCIpO1xcbnZhciBTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1N1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIGZpcnN0VmFsdWVGcm9tKHNvdXJjZSwgY29uZmlnKSB7XFxuICAgIHZhciBoYXNDb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JztcXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcXG4gICAgICAgIHZhciBzdWJzY3JpYmVyID0gbmV3IFN1YnNjcmliZXJfMS5TYWZlU3Vic2NyaWJlcih7XFxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBlcnJvcjogcmVqZWN0LFxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGlmIChoYXNDb25maWcpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY29uZmlnLmRlZmF1bHRWYWx1ZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVtcHR5RXJyb3JfMS5FbXB0eUVycm9yKCkpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuZmlyc3RWYWx1ZUZyb20gPSBmaXJzdFZhbHVlRnJvbTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXJzdFZhbHVlRnJvbS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9maXJzdFZhbHVlRnJvbS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvbGFzdFZhbHVlRnJvbS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9sYXN0VmFsdWVGcm9tLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmxhc3RWYWx1ZUZyb20gPSB2b2lkIDA7XFxudmFyIEVtcHR5RXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbC9FbXB0eUVycm9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvRW1wdHlFcnJvci5qc1xcXCIpO1xcbmZ1bmN0aW9uIGxhc3RWYWx1ZUZyb20oc291cmNlLCBjb25maWcpIHtcXG4gICAgdmFyIGhhc0NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnO1xcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgICAgdmFyIF9oYXNWYWx1ZSA9IGZhbHNlO1xcbiAgICAgICAgdmFyIF92YWx1ZTtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoe1xcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICBfdmFsdWUgPSB2YWx1ZTtcXG4gICAgICAgICAgICAgICAgX2hhc1ZhbHVlID0gdHJ1ZTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGVycm9yOiByZWplY3QsXFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgaWYgKF9oYXNWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfdmFsdWUpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc0NvbmZpZykge1xcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjb25maWcuZGVmYXVsdFZhbHVlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRW1wdHlFcnJvcl8xLkVtcHR5RXJyb3IoKSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgfSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLmxhc3RWYWx1ZUZyb20gPSBsYXN0VmFsdWVGcm9tO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhc3RWYWx1ZUZyb20uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvbGFzdFZhbHVlRnJvbS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9Db25uZWN0YWJsZU9ic2VydmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxuICAgIH07XFxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIGIgIT09IG51bGwpXFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcXFwiICsgU3RyaW5nKGIpICsgXFxcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXFxcIik7XFxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XFxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XFxuICAgIH07XFxufSkoKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5Db25uZWN0YWJsZU9ic2VydmFibGUgPSB2b2lkIDA7XFxudmFyIE9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbnZhciBTdWJzY3JpcHRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1N1YnNjcmlwdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJzY3JpcHRpb24uanNcXFwiKTtcXG52YXIgcmVmQ291bnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29wZXJhdG9ycy9yZWZDb3VudCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmVmQ291bnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBDb25uZWN0YWJsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xcbiAgICBfX2V4dGVuZHMoQ29ubmVjdGFibGVPYnNlcnZhYmxlLCBfc3VwZXIpO1xcbiAgICBmdW5jdGlvbiBDb25uZWN0YWJsZU9ic2VydmFibGUoc291cmNlLCBzdWJqZWN0RmFjdG9yeSkge1xcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcXG4gICAgICAgIF90aGlzLnNvdXJjZSA9IHNvdXJjZTtcXG4gICAgICAgIF90aGlzLnN1YmplY3RGYWN0b3J5ID0gc3ViamVjdEZhY3Rvcnk7XFxuICAgICAgICBfdGhpcy5fc3ViamVjdCA9IG51bGw7XFxuICAgICAgICBfdGhpcy5fcmVmQ291bnQgPSAwO1xcbiAgICAgICAgX3RoaXMuX2Nvbm5lY3Rpb24gPSBudWxsO1xcbiAgICAgICAgaWYgKGxpZnRfMS5oYXNMaWZ0KHNvdXJjZSkpIHtcXG4gICAgICAgICAgICBfdGhpcy5saWZ0ID0gc291cmNlLmxpZnQ7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gX3RoaXM7XFxuICAgIH1cXG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmdldFN1YmplY3QoKS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XFxuICAgIH07XFxuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuZ2V0U3ViamVjdCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5fc3ViamVjdDtcXG4gICAgICAgIGlmICghc3ViamVjdCB8fCBzdWJqZWN0LmlzU3RvcHBlZCkge1xcbiAgICAgICAgICAgIHRoaXMuX3N1YmplY3QgPSB0aGlzLnN1YmplY3RGYWN0b3J5KCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdGhpcy5fc3ViamVjdDtcXG4gICAgfTtcXG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5fdGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB0aGlzLl9yZWZDb3VudCA9IDA7XFxuICAgICAgICB2YXIgX2Nvbm5lY3Rpb24gPSB0aGlzLl9jb25uZWN0aW9uO1xcbiAgICAgICAgdGhpcy5fc3ViamVjdCA9IHRoaXMuX2Nvbm5lY3Rpb24gPSBudWxsO1xcbiAgICAgICAgX2Nvbm5lY3Rpb24gPT09IG51bGwgfHwgX2Nvbm5lY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb25uZWN0aW9uLnVuc3Vic2NyaWJlKCk7XFxuICAgIH07XFxuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb247XFxuICAgICAgICBpZiAoIWNvbm5lY3Rpb24pIHtcXG4gICAgICAgICAgICBjb25uZWN0aW9uID0gdGhpcy5fY29ubmVjdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oKTtcXG4gICAgICAgICAgICB2YXIgc3ViamVjdF8xID0gdGhpcy5nZXRTdWJqZWN0KCk7XFxuICAgICAgICAgICAgY29ubmVjdGlvbi5hZGQodGhpcy5zb3VyY2Uuc3Vic2NyaWJlKE9wZXJhdG9yU3Vic2NyaWJlcl8xLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJqZWN0XzEsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGVhcmRvd24oKTtcXG4gICAgICAgICAgICAgICAgc3ViamVjdF8xLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGVhcmRvd24oKTtcXG4gICAgICAgICAgICAgICAgc3ViamVjdF8xLmVycm9yKGVycik7XFxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3RlYXJkb3duKCk7IH0pKSk7XFxuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uY2xvc2VkKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBudWxsO1xcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xcbiAgICB9O1xcbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLnJlZkNvdW50ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHJlZkNvdW50XzEucmVmQ291bnQoKSh0aGlzKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIENvbm5lY3RhYmxlT2JzZXJ2YWJsZTtcXG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XFxuZXhwb3J0cy5Db25uZWN0YWJsZU9ic2VydmFibGUgPSBDb25uZWN0YWJsZU9ic2VydmFibGU7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29ubmVjdGFibGVPYnNlcnZhYmxlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2JpbmRDYWxsYmFjay5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9iaW5kQ2FsbGJhY2suanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmJpbmRDYWxsYmFjayA9IHZvaWQgMDtcXG52YXIgYmluZENhbGxiYWNrSW50ZXJuYWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2JpbmRDYWxsYmFja0ludGVybmFscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2JpbmRDYWxsYmFja0ludGVybmFscy5qc1xcXCIpO1xcbmZ1bmN0aW9uIGJpbmRDYWxsYmFjayhjYWxsYmFja0Z1bmMsIHJlc3VsdFNlbGVjdG9yLCBzY2hlZHVsZXIpIHtcXG4gICAgcmV0dXJuIGJpbmRDYWxsYmFja0ludGVybmFsc18xLmJpbmRDYWxsYmFja0ludGVybmFscyhmYWxzZSwgY2FsbGJhY2tGdW5jLCByZXN1bHRTZWxlY3Rvciwgc2NoZWR1bGVyKTtcXG59XFxuZXhwb3J0cy5iaW5kQ2FsbGJhY2sgPSBiaW5kQ2FsbGJhY2s7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluZENhbGxiYWNrLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvYmluZENhbGxiYWNrLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2JpbmRDYWxsYmFja0ludGVybmFscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9iaW5kQ2FsbGJhY2tJbnRlcm5hbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xcbiAgICBpZiAoIW0pIHJldHVybiBvO1xcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xcbiAgICB9XFxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxcbiAgICBmaW5hbGx5IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXFxcInJldHVyblxcXCJdKSkgbS5jYWxsKGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFyO1xcbn07XFxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcXG4gICAgcmV0dXJuIHRvO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuYmluZENhbGxiYWNrSW50ZXJuYWxzID0gdm9pZCAwO1xcbnZhciBpc1NjaGVkdWxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc1NjaGVkdWxlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzU2NoZWR1bGVyLmpzXFxcIik7XFxudmFyIE9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbnZhciBzdWJzY3JpYmVPbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb3BlcmF0b3JzL3N1YnNjcmliZU9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zdWJzY3JpYmVPbi5qc1xcXCIpO1xcbnZhciBtYXBPbmVPck1hbnlBcmdzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL21hcE9uZU9yTWFueUFyZ3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9tYXBPbmVPck1hbnlBcmdzLmpzXFxcIik7XFxudmFyIG9ic2VydmVPbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb3BlcmF0b3JzL29ic2VydmVPbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvb2JzZXJ2ZU9uLmpzXFxcIik7XFxudmFyIEFzeW5jU3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vQXN5bmNTdWJqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL0FzeW5jU3ViamVjdC5qc1xcXCIpO1xcbmZ1bmN0aW9uIGJpbmRDYWxsYmFja0ludGVybmFscyhpc05vZGVTdHlsZSwgY2FsbGJhY2tGdW5jLCByZXN1bHRTZWxlY3Rvciwgc2NoZWR1bGVyKSB7XFxuICAgIGlmIChyZXN1bHRTZWxlY3Rvcikge1xcbiAgICAgICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIocmVzdWx0U2VsZWN0b3IpKSB7XFxuICAgICAgICAgICAgc2NoZWR1bGVyID0gcmVzdWx0U2VsZWN0b3I7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiBiaW5kQ2FsbGJhY2tJbnRlcm5hbHMoaXNOb2RlU3R5bGUsIGNhbGxiYWNrRnVuYywgc2NoZWR1bGVyKVxcbiAgICAgICAgICAgICAgICAgICAgLmFwcGx5KHRoaXMsIGFyZ3MpXFxuICAgICAgICAgICAgICAgICAgICAucGlwZShtYXBPbmVPck1hbnlBcmdzXzEubWFwT25lT3JNYW55QXJncyhyZXN1bHRTZWxlY3RvcikpO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgaWYgKHNjaGVkdWxlcikge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGJpbmRDYWxsYmFja0ludGVybmFscyhpc05vZGVTdHlsZSwgY2FsbGJhY2tGdW5jKVxcbiAgICAgICAgICAgICAgICAuYXBwbHkodGhpcywgYXJncylcXG4gICAgICAgICAgICAgICAgLnBpcGUoc3Vic2NyaWJlT25fMS5zdWJzY3JpYmVPbihzY2hlZHVsZXIpLCBvYnNlcnZlT25fMS5vYnNlcnZlT24oc2NoZWR1bGVyKSk7XFxuICAgICAgICB9O1xcbiAgICB9XFxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0XzEuQXN5bmNTdWJqZWN0KCk7XFxuICAgICAgICB2YXIgdW5pbml0aWFsaXplZCA9IHRydWU7XFxuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICAgICAgdmFyIHN1YnMgPSBzdWJqZWN0LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcXG4gICAgICAgICAgICBpZiAodW5pbml0aWFsaXplZCkge1xcbiAgICAgICAgICAgICAgICB1bmluaXRpYWxpemVkID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgIHZhciBpc0FzeW5jXzEgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgdmFyIGlzQ29tcGxldGVfMSA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICBjYWxsYmFja0Z1bmMuYXBwbHkoX3RoaXMsIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpKSwgW1xcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlU3R5bGUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IHJlc3VsdHMuc2hpZnQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0LmVycm9yKGVycik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5uZXh0KDEgPCByZXN1bHRzLmxlbmd0aCA/IHJlc3VsdHMgOiByZXN1bHRzWzBdKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBsZXRlXzEgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jXzEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIF0pKTtcXG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tcGxldGVfMSkge1xcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdC5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlzQXN5bmNfMSA9IHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBzdWJzO1xcbiAgICAgICAgfSk7XFxuICAgIH07XFxufVxcbmV4cG9ydHMuYmluZENhbGxiYWNrSW50ZXJuYWxzID0gYmluZENhbGxiYWNrSW50ZXJuYWxzO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmRDYWxsYmFja0ludGVybmFscy5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2JpbmRDYWxsYmFja0ludGVybmFscy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9iaW5kTm9kZUNhbGxiYWNrLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9iaW5kTm9kZUNhbGxiYWNrLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuYmluZE5vZGVDYWxsYmFjayA9IHZvaWQgMDtcXG52YXIgYmluZENhbGxiYWNrSW50ZXJuYWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2JpbmRDYWxsYmFja0ludGVybmFscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2JpbmRDYWxsYmFja0ludGVybmFscy5qc1xcXCIpO1xcbmZ1bmN0aW9uIGJpbmROb2RlQ2FsbGJhY2soY2FsbGJhY2tGdW5jLCByZXN1bHRTZWxlY3Rvciwgc2NoZWR1bGVyKSB7XFxuICAgIHJldHVybiBiaW5kQ2FsbGJhY2tJbnRlcm5hbHNfMS5iaW5kQ2FsbGJhY2tJbnRlcm5hbHModHJ1ZSwgY2FsbGJhY2tGdW5jLCByZXN1bHRTZWxlY3Rvciwgc2NoZWR1bGVyKTtcXG59XFxuZXhwb3J0cy5iaW5kTm9kZUNhbGxiYWNrID0gYmluZE5vZGVDYWxsYmFjaztcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kTm9kZUNhbGxiYWNrLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvYmluZE5vZGVDYWxsYmFjay5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuY29tYmluZUxhdGVzdEluaXQgPSBleHBvcnRzLmNvbWJpbmVMYXRlc3QgPSB2b2lkIDA7XFxudmFyIE9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbnZhciBhcmdzQXJnQXJyYXlPck9iamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9hcmdzQXJnQXJyYXlPck9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyZ3NBcmdBcnJheU9yT2JqZWN0LmpzXFxcIik7XFxudmFyIGZyb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb20uanNcXFwiKTtcXG52YXIgaWRlbnRpdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaWRlbnRpdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pZGVudGl0eS5qc1xcXCIpO1xcbnZhciBtYXBPbmVPck1hbnlBcmdzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL21hcE9uZU9yTWFueUFyZ3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9tYXBPbmVPck1hbnlBcmdzLmpzXFxcIik7XFxudmFyIGFyZ3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvYXJncyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyZ3MuanNcXFwiKTtcXG52YXIgY3JlYXRlT2JqZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2NyZWF0ZU9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2NyZWF0ZU9iamVjdC5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbnZhciBleGVjdXRlU2NoZWR1bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvZXhlY3V0ZVNjaGVkdWxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvZXhlY3V0ZVNjaGVkdWxlLmpzXFxcIik7XFxuZnVuY3Rpb24gY29tYmluZUxhdGVzdCgpIHtcXG4gICAgdmFyIGFyZ3MgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcXG4gICAgfVxcbiAgICB2YXIgc2NoZWR1bGVyID0gYXJnc18xLnBvcFNjaGVkdWxlcihhcmdzKTtcXG4gICAgdmFyIHJlc3VsdFNlbGVjdG9yID0gYXJnc18xLnBvcFJlc3VsdFNlbGVjdG9yKGFyZ3MpO1xcbiAgICB2YXIgX2EgPSBhcmdzQXJnQXJyYXlPck9iamVjdF8xLmFyZ3NBcmdBcnJheU9yT2JqZWN0KGFyZ3MpLCBvYnNlcnZhYmxlcyA9IF9hLmFyZ3MsIGtleXMgPSBfYS5rZXlzO1xcbiAgICBpZiAob2JzZXJ2YWJsZXMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICByZXR1cm4gZnJvbV8xLmZyb20oW10sIHNjaGVkdWxlcik7XFxuICAgIH1cXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShjb21iaW5lTGF0ZXN0SW5pdChvYnNlcnZhYmxlcywgc2NoZWR1bGVyLCBrZXlzXFxuICAgICAgICA/XFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlcykgeyByZXR1cm4gY3JlYXRlT2JqZWN0XzEuY3JlYXRlT2JqZWN0KGtleXMsIHZhbHVlcyk7IH1cXG4gICAgICAgIDpcXG4gICAgICAgICAgICBpZGVudGl0eV8xLmlkZW50aXR5KSk7XFxuICAgIHJldHVybiByZXN1bHRTZWxlY3RvciA/IHJlc3VsdC5waXBlKG1hcE9uZU9yTWFueUFyZ3NfMS5tYXBPbmVPck1hbnlBcmdzKHJlc3VsdFNlbGVjdG9yKSkgOiByZXN1bHQ7XFxufVxcbmV4cG9ydHMuY29tYmluZUxhdGVzdCA9IGNvbWJpbmVMYXRlc3Q7XFxuZnVuY3Rpb24gY29tYmluZUxhdGVzdEluaXQob2JzZXJ2YWJsZXMsIHNjaGVkdWxlciwgdmFsdWVUcmFuc2Zvcm0pIHtcXG4gICAgaWYgKHZhbHVlVHJhbnNmb3JtID09PSB2b2lkIDApIHsgdmFsdWVUcmFuc2Zvcm0gPSBpZGVudGl0eV8xLmlkZW50aXR5OyB9XFxuICAgIHJldHVybiBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgbWF5YmVTY2hlZHVsZShzY2hlZHVsZXIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gb2JzZXJ2YWJsZXMubGVuZ3RoO1xcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcXG4gICAgICAgICAgICB2YXIgYWN0aXZlID0gbGVuZ3RoO1xcbiAgICAgICAgICAgIHZhciByZW1haW5pbmdGaXJzdFZhbHVlcyA9IGxlbmd0aDtcXG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XFxuICAgICAgICAgICAgICAgIG1heWJlU2NoZWR1bGUoc2NoZWR1bGVyLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gZnJvbV8xLmZyb20ob2JzZXJ2YWJsZXNbaV0sIHNjaGVkdWxlcik7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzRmlyc3RWYWx1ZSA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2ldID0gdmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNGaXJzdFZhbHVlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0ZpcnN0VmFsdWUgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdGaXJzdFZhbHVlcy0tO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbWFpbmluZ0ZpcnN0VmFsdWVzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZVRyYW5zZm9ybSh2YWx1ZXMuc2xpY2UoKSkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIS0tYWN0aXZlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgICAgIH0sIHN1YnNjcmliZXIpO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBfbG9vcF8xKGkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIHN1YnNjcmliZXIpO1xcbiAgICB9O1xcbn1cXG5leHBvcnRzLmNvbWJpbmVMYXRlc3RJbml0ID0gY29tYmluZUxhdGVzdEluaXQ7XFxuZnVuY3Rpb24gbWF5YmVTY2hlZHVsZShzY2hlZHVsZXIsIGV4ZWN1dGUsIHN1YnNjcmlwdGlvbikge1xcbiAgICBpZiAoc2NoZWR1bGVyKSB7XFxuICAgICAgICBleGVjdXRlU2NoZWR1bGVfMS5leGVjdXRlU2NoZWR1bGUoc3Vic2NyaXB0aW9uLCBzY2hlZHVsZXIsIGV4ZWN1dGUpO1xcbiAgICB9XFxuICAgIGVsc2Uge1xcbiAgICAgICAgZXhlY3V0ZSgpO1xcbiAgICB9XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbWJpbmVMYXRlc3QuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2NvbmNhdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9jb25jYXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmNvbmNhdCA9IHZvaWQgMDtcXG52YXIgY29uY2F0QWxsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vcGVyYXRvcnMvY29uY2F0QWxsICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb25jYXRBbGwuanNcXFwiKTtcXG52YXIgYXJnc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9hcmdzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJncy5qc1xcXCIpO1xcbnZhciBmcm9tXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Zyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mcm9tLmpzXFxcIik7XFxuZnVuY3Rpb24gY29uY2F0KCkge1xcbiAgICB2YXIgYXJncyA9IFtdO1xcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHJldHVybiBjb25jYXRBbGxfMS5jb25jYXRBbGwoKShmcm9tXzEuZnJvbShhcmdzLCBhcmdzXzEucG9wU2NoZWR1bGVyKGFyZ3MpKSk7XFxufVxcbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2NvbmNhdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9jb25uZWN0YWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2Nvbm5lY3RhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmNvbm5lY3RhYmxlID0gdm9pZCAwO1xcbnZhciBTdWJqZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9TdWJqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YmplY3QuanNcXFwiKTtcXG52YXIgT2JzZXJ2YWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vT2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzXFxcIik7XFxudmFyIGRlZmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RlZmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZGVmZXIuanNcXFwiKTtcXG52YXIgREVGQVVMVF9DT05GSUcgPSB7XFxuICAgIGNvbm5lY3RvcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7IH0sXFxuICAgIHJlc2V0T25EaXNjb25uZWN0OiB0cnVlLFxcbn07XFxuZnVuY3Rpb24gY29ubmVjdGFibGUoc291cmNlLCBjb25maWcpIHtcXG4gICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IERFRkFVTFRfQ09ORklHOyB9XFxuICAgIHZhciBjb25uZWN0aW9uID0gbnVsbDtcXG4gICAgdmFyIGNvbm5lY3RvciA9IGNvbmZpZy5jb25uZWN0b3IsIF9hID0gY29uZmlnLnJlc2V0T25EaXNjb25uZWN0LCByZXNldE9uRGlzY29ubmVjdCA9IF9hID09PSB2b2lkIDAgPyB0cnVlIDogX2E7XFxuICAgIHZhciBzdWJqZWN0ID0gY29ubmVjdG9yKCk7XFxuICAgIHZhciByZXN1bHQgPSBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHJldHVybiBzdWJqZWN0LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcXG4gICAgfSk7XFxuICAgIHJlc3VsdC5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uIHx8IGNvbm5lY3Rpb24uY2xvc2VkKSB7XFxuICAgICAgICAgICAgY29ubmVjdGlvbiA9IGRlZmVyXzEuZGVmZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlOyB9KS5zdWJzY3JpYmUoc3ViamVjdCk7XFxuICAgICAgICAgICAgaWYgKHJlc2V0T25EaXNjb25uZWN0KSB7XFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uYWRkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIChzdWJqZWN0ID0gY29ubmVjdG9yKCkpOyB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcXG4gICAgfTtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG59XFxuZXhwb3J0cy5jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3RhYmxlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvY29ubmVjdGFibGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZGVmZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9kZWZlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5kZWZlciA9IHZvaWQgMDtcXG52YXIgT2JzZXJ2YWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vT2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG5mdW5jdGlvbiBkZWZlcihvYnNlcnZhYmxlRmFjdG9yeSkge1xcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICBpbm5lckZyb21fMS5pbm5lckZyb20ob2JzZXJ2YWJsZUZhY3RvcnkoKSkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5kZWZlciA9IGRlZmVyO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmVyLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZGVmZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZG9tL2FuaW1hdGlvbkZyYW1lcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZG9tL2FuaW1hdGlvbkZyYW1lcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmFuaW1hdGlvbkZyYW1lcyA9IHZvaWQgMDtcXG52YXIgT2JzZXJ2YWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vT2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzXFxcIik7XFxudmFyIHBlcmZvcm1hbmNlVGltZXN0YW1wUHJvdmlkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3NjaGVkdWxlci9wZXJmb3JtYW5jZVRpbWVzdGFtcFByb3ZpZGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9wZXJmb3JtYW5jZVRpbWVzdGFtcFByb3ZpZGVyLmpzXFxcIik7XFxudmFyIGFuaW1hdGlvbkZyYW1lUHJvdmlkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3NjaGVkdWxlci9hbmltYXRpb25GcmFtZVByb3ZpZGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9hbmltYXRpb25GcmFtZVByb3ZpZGVyLmpzXFxcIik7XFxuZnVuY3Rpb24gYW5pbWF0aW9uRnJhbWVzKHRpbWVzdGFtcFByb3ZpZGVyKSB7XFxuICAgIHJldHVybiB0aW1lc3RhbXBQcm92aWRlciA/IGFuaW1hdGlvbkZyYW1lc0ZhY3RvcnkodGltZXN0YW1wUHJvdmlkZXIpIDogREVGQVVMVF9BTklNQVRJT05fRlJBTUVTO1xcbn1cXG5leHBvcnRzLmFuaW1hdGlvbkZyYW1lcyA9IGFuaW1hdGlvbkZyYW1lcztcXG5mdW5jdGlvbiBhbmltYXRpb25GcmFtZXNGYWN0b3J5KHRpbWVzdGFtcFByb3ZpZGVyKSB7XFxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBwcm92aWRlciA9IHRpbWVzdGFtcFByb3ZpZGVyIHx8IHBlcmZvcm1hbmNlVGltZXN0YW1wUHJvdmlkZXJfMS5wZXJmb3JtYW5jZVRpbWVzdGFtcFByb3ZpZGVyO1xcbiAgICAgICAgdmFyIHN0YXJ0ID0gcHJvdmlkZXIubm93KCk7XFxuICAgICAgICB2YXIgaWQgPSAwO1xcbiAgICAgICAgdmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XFxuICAgICAgICAgICAgICAgIGlkID0gYW5pbWF0aW9uRnJhbWVQcm92aWRlcl8xLmFuaW1hdGlvbkZyYW1lUHJvdmlkZXIucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcXG4gICAgICAgICAgICAgICAgICAgIGlkID0gMDtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSBwcm92aWRlci5ub3coKTtcXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXBQcm92aWRlciA/IG5vdyA6IHRpbWVzdGFtcCxcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGFwc2VkOiBub3cgLSBzdGFydCxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgcnVuKCk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuICAgICAgICBydW4oKTtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKGlkKSB7XFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkZyYW1lUHJvdmlkZXJfMS5hbmltYXRpb25GcmFtZVByb3ZpZGVyLmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICB9KTtcXG59XFxudmFyIERFRkFVTFRfQU5JTUFUSU9OX0ZSQU1FUyA9IGFuaW1hdGlvbkZyYW1lc0ZhY3RvcnkoKTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmltYXRpb25GcmFtZXMuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9kb20vYW5pbWF0aW9uRnJhbWVzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2VtcHR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZW1wdHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZW1wdHkgPSBleHBvcnRzLkVNUFRZID0gdm9pZCAwO1xcbnZhciBPYnNlcnZhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9PYnNlcnZhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL09ic2VydmFibGUuanNcXFwiKTtcXG5leHBvcnRzLkVNUFRZID0gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7IHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7IH0pO1xcbmZ1bmN0aW9uIGVtcHR5KHNjaGVkdWxlcikge1xcbiAgICByZXR1cm4gc2NoZWR1bGVyID8gZW1wdHlTY2hlZHVsZWQoc2NoZWR1bGVyKSA6IGV4cG9ydHMuRU1QVFk7XFxufVxcbmV4cG9ydHMuZW1wdHkgPSBlbXB0eTtcXG5mdW5jdGlvbiBlbXB0eVNjaGVkdWxlZChzY2hlZHVsZXIpIHtcXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikgeyByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTsgfSk7IH0pO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbXB0eS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2VtcHR5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2ZvcmtKb2luLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZm9ya0pvaW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZm9ya0pvaW4gPSB2b2lkIDA7XFxudmFyIE9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbnZhciBhcmdzQXJnQXJyYXlPck9iamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9hcmdzQXJnQXJyYXlPck9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyZ3NBcmdBcnJheU9yT2JqZWN0LmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG52YXIgYXJnc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9hcmdzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJncy5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbnZhciBtYXBPbmVPck1hbnlBcmdzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL21hcE9uZU9yTWFueUFyZ3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9tYXBPbmVPck1hbnlBcmdzLmpzXFxcIik7XFxudmFyIGNyZWF0ZU9iamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9jcmVhdGVPYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9jcmVhdGVPYmplY3QuanNcXFwiKTtcXG5mdW5jdGlvbiBmb3JrSm9pbigpIHtcXG4gICAgdmFyIGFyZ3MgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcXG4gICAgfVxcbiAgICB2YXIgcmVzdWx0U2VsZWN0b3IgPSBhcmdzXzEucG9wUmVzdWx0U2VsZWN0b3IoYXJncyk7XFxuICAgIHZhciBfYSA9IGFyZ3NBcmdBcnJheU9yT2JqZWN0XzEuYXJnc0FyZ0FycmF5T3JPYmplY3QoYXJncyksIHNvdXJjZXMgPSBfYS5hcmdzLCBrZXlzID0gX2Eua2V5cztcXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xcbiAgICAgICAgdmFyIHJlbWFpbmluZ0NvbXBsZXRpb25zID0gbGVuZ3RoO1xcbiAgICAgICAgdmFyIHJlbWFpbmluZ0VtaXNzaW9ucyA9IGxlbmd0aDtcXG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHNvdXJjZUluZGV4KSB7XFxuICAgICAgICAgICAgdmFyIGhhc1ZhbHVlID0gZmFsc2U7XFxuICAgICAgICAgICAgaW5uZXJGcm9tXzEuaW5uZXJGcm9tKHNvdXJjZXNbc291cmNlSW5kZXhdKS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1ZhbHVlKSB7XFxuICAgICAgICAgICAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdFbWlzc2lvbnMtLTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB2YWx1ZXNbc291cmNlSW5kZXhdID0gdmFsdWU7XFxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtYWluaW5nQ29tcGxldGlvbnMtLTsgfSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGlmICghcmVtYWluaW5nQ29tcGxldGlvbnMgfHwgIWhhc1ZhbHVlKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbWFpbmluZ0VtaXNzaW9ucykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChrZXlzID8gY3JlYXRlT2JqZWN0XzEuY3JlYXRlT2JqZWN0KGtleXMsIHZhbHVlcykgOiB2YWx1ZXMpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgfTtcXG4gICAgICAgIGZvciAodmFyIHNvdXJjZUluZGV4ID0gMDsgc291cmNlSW5kZXggPCBsZW5ndGg7IHNvdXJjZUluZGV4KyspIHtcXG4gICAgICAgICAgICBfbG9vcF8xKHNvdXJjZUluZGV4KTtcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIHJldHVybiByZXN1bHRTZWxlY3RvciA/IHJlc3VsdC5waXBlKG1hcE9uZU9yTWFueUFyZ3NfMS5tYXBPbmVPck1hbnlBcmdzKHJlc3VsdFNlbGVjdG9yKSkgOiByZXN1bHQ7XFxufVxcbmV4cG9ydHMuZm9ya0pvaW4gPSBmb3JrSm9pbjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JrSm9pbi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2ZvcmtKb2luLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb20uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb20uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5mcm9tID0gdm9pZCAwO1xcbnZhciBzY2hlZHVsZWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3NjaGVkdWxlZC9zY2hlZHVsZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlZC5qc1xcXCIpO1xcbnZhciBpbm5lckZyb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW5uZXJGcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvaW5uZXJGcm9tLmpzXFxcIik7XFxuZnVuY3Rpb24gZnJvbShpbnB1dCwgc2NoZWR1bGVyKSB7XFxuICAgIHJldHVybiBzY2hlZHVsZXIgPyBzY2hlZHVsZWRfMS5zY2hlZHVsZWQoaW5wdXQsIHNjaGVkdWxlcikgOiBpbm5lckZyb21fMS5pbm5lckZyb20oaW5wdXQpO1xcbn1cXG5leHBvcnRzLmZyb20gPSBmcm9tO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb20uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mcm9tLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb21FdmVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mcm9tRXZlbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xcbiAgICBpZiAoIW0pIHJldHVybiBvO1xcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xcbiAgICB9XFxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxcbiAgICBmaW5hbGx5IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXFxcInJldHVyblxcXCJdKSkgbS5jYWxsKGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFyO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZnJvbUV2ZW50ID0gdm9pZCAwO1xcbnZhciBpbm5lckZyb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvaW5uZXJGcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvaW5uZXJGcm9tLmpzXFxcIik7XFxudmFyIE9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbnZhciBtZXJnZU1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb3BlcmF0b3JzL21lcmdlTWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZU1hcC5qc1xcXCIpO1xcbnZhciBpc0FycmF5TGlrZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc0FycmF5TGlrZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzQXJyYXlMaWtlLmpzXFxcIik7XFxudmFyIGlzRnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG52YXIgbWFwT25lT3JNYW55QXJnc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9tYXBPbmVPck1hbnlBcmdzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbWFwT25lT3JNYW55QXJncy5qc1xcXCIpO1xcbnZhciBub2RlRXZlbnRFbWl0dGVyTWV0aG9kcyA9IFsnYWRkTGlzdGVuZXInLCAncmVtb3ZlTGlzdGVuZXInXTtcXG52YXIgZXZlbnRUYXJnZXRNZXRob2RzID0gWydhZGRFdmVudExpc3RlbmVyJywgJ3JlbW92ZUV2ZW50TGlzdGVuZXInXTtcXG52YXIganF1ZXJ5TWV0aG9kcyA9IFsnb24nLCAnb2ZmJ107XFxuZnVuY3Rpb24gZnJvbUV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBvcHRpb25zLCByZXN1bHRTZWxlY3Rvcikge1xcbiAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24ob3B0aW9ucykpIHtcXG4gICAgICAgIHJlc3VsdFNlbGVjdG9yID0gb3B0aW9ucztcXG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XFxuICAgIH1cXG4gICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XFxuICAgICAgICByZXR1cm4gZnJvbUV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBvcHRpb25zKS5waXBlKG1hcE9uZU9yTWFueUFyZ3NfMS5tYXBPbmVPck1hbnlBcmdzKHJlc3VsdFNlbGVjdG9yKSk7XFxuICAgIH1cXG4gICAgdmFyIF9hID0gX19yZWFkKGlzRXZlbnRUYXJnZXQodGFyZ2V0KVxcbiAgICAgICAgPyBldmVudFRhcmdldE1ldGhvZHMubWFwKGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7IHJldHVybiBmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gdGFyZ2V0W21ldGhvZE5hbWVdKGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7IH07IH0pXFxuICAgICAgICA6XFxuICAgICAgICAgICAgaXNOb2RlU3R5bGVFdmVudEVtaXR0ZXIodGFyZ2V0KVxcbiAgICAgICAgICAgICAgICA/IG5vZGVFdmVudEVtaXR0ZXJNZXRob2RzLm1hcCh0b0NvbW1vbkhhbmRsZXJSZWdpc3RyeSh0YXJnZXQsIGV2ZW50TmFtZSkpXFxuICAgICAgICAgICAgICAgIDogaXNKUXVlcnlTdHlsZUV2ZW50RW1pdHRlcih0YXJnZXQpXFxuICAgICAgICAgICAgICAgICAgICA/IGpxdWVyeU1ldGhvZHMubWFwKHRvQ29tbW9uSGFuZGxlclJlZ2lzdHJ5KHRhcmdldCwgZXZlbnROYW1lKSlcXG4gICAgICAgICAgICAgICAgICAgIDogW10sIDIpLCBhZGQgPSBfYVswXSwgcmVtb3ZlID0gX2FbMV07XFxuICAgIGlmICghYWRkKSB7XFxuICAgICAgICBpZiAoaXNBcnJheUxpa2VfMS5pc0FycmF5TGlrZSh0YXJnZXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlTWFwXzEubWVyZ2VNYXAoZnVuY3Rpb24gKHN1YlRhcmdldCkgeyByZXR1cm4gZnJvbUV2ZW50KHN1YlRhcmdldCwgZXZlbnROYW1lLCBvcHRpb25zKTsgfSkoaW5uZXJGcm9tXzEuaW5uZXJGcm9tKHRhcmdldCkpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGlmICghYWRkKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGV2ZW50IHRhcmdldCcpO1xcbiAgICB9XFxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XFxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlci5uZXh0KDEgPCBhcmdzLmxlbmd0aCA/IGFyZ3MgOiBhcmdzWzBdKTtcXG4gICAgICAgIH07XFxuICAgICAgICBhZGQoaGFuZGxlcik7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVtb3ZlKGhhbmRsZXIpOyB9O1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5mcm9tRXZlbnQgPSBmcm9tRXZlbnQ7XFxuZnVuY3Rpb24gdG9Db21tb25IYW5kbGVyUmVnaXN0cnkodGFyZ2V0LCBldmVudE5hbWUpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7IHJldHVybiBmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gdGFyZ2V0W21ldGhvZE5hbWVdKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07IH07XFxufVxcbmZ1bmN0aW9uIGlzTm9kZVN0eWxlRXZlbnRFbWl0dGVyKHRhcmdldCkge1xcbiAgICByZXR1cm4gaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24odGFyZ2V0LmFkZExpc3RlbmVyKSAmJiBpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbih0YXJnZXQucmVtb3ZlTGlzdGVuZXIpO1xcbn1cXG5mdW5jdGlvbiBpc0pRdWVyeVN0eWxlRXZlbnRFbWl0dGVyKHRhcmdldCkge1xcbiAgICByZXR1cm4gaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24odGFyZ2V0Lm9uKSAmJiBpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbih0YXJnZXQub2ZmKTtcXG59XFxuZnVuY3Rpb24gaXNFdmVudFRhcmdldCh0YXJnZXQpIHtcXG4gICAgcmV0dXJuIGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSAmJiBpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbih0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcik7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb21FdmVudC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb21FdmVudC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mcm9tRXZlbnRQYXR0ZXJuLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mcm9tRXZlbnRQYXR0ZXJuLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZnJvbUV2ZW50UGF0dGVybiA9IHZvaWQgMDtcXG52YXIgT2JzZXJ2YWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vT2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzXFxcIik7XFxudmFyIGlzRnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG52YXIgbWFwT25lT3JNYW55QXJnc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9tYXBPbmVPck1hbnlBcmdzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbWFwT25lT3JNYW55QXJncy5qc1xcXCIpO1xcbmZ1bmN0aW9uIGZyb21FdmVudFBhdHRlcm4oYWRkSGFuZGxlciwgcmVtb3ZlSGFuZGxlciwgcmVzdWx0U2VsZWN0b3IpIHtcXG4gICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XFxuICAgICAgICByZXR1cm4gZnJvbUV2ZW50UGF0dGVybihhZGRIYW5kbGVyLCByZW1vdmVIYW5kbGVyKS5waXBlKG1hcE9uZU9yTWFueUFyZ3NfMS5tYXBPbmVPck1hbnlBcmdzKHJlc3VsdFNlbGVjdG9yKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIGUgPSBbXTtcXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgICAgICAgICBlW19pXSA9IGFyZ3VtZW50c1tfaV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyLm5leHQoZS5sZW5ndGggPT09IDEgPyBlWzBdIDogZSk7XFxuICAgICAgICB9O1xcbiAgICAgICAgdmFyIHJldFZhbHVlID0gYWRkSGFuZGxlcihoYW5kbGVyKTtcXG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihyZW1vdmVIYW5kbGVyKSA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZUhhbmRsZXIoaGFuZGxlciwgcmV0VmFsdWUpOyB9IDogdW5kZWZpbmVkO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5mcm9tRXZlbnRQYXR0ZXJuID0gZnJvbUV2ZW50UGF0dGVybjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tRXZlbnRQYXR0ZXJuLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZnJvbUV2ZW50UGF0dGVybi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mcm9tU3Vic2NyaWJhYmxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9mcm9tU3Vic2NyaWJhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZnJvbVN1YnNjcmliYWJsZSA9IHZvaWQgMDtcXG52YXIgT2JzZXJ2YWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vT2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzXFxcIik7XFxuZnVuY3Rpb24gZnJvbVN1YnNjcmliYWJsZShzdWJzY3JpYmFibGUpIHtcXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikgeyByZXR1cm4gc3Vic2NyaWJhYmxlLnN1YnNjcmliZShzdWJzY3JpYmVyKTsgfSk7XFxufVxcbmV4cG9ydHMuZnJvbVN1YnNjcmliYWJsZSA9IGZyb21TdWJzY3JpYmFibGU7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbVN1YnNjcmliYWJsZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb21TdWJzY3JpYmFibGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZ2VuZXJhdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9nZW5lcmF0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XFxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XFxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcXFwidGhyb3dcXFwiOiB2ZXJiKDEpLCBcXFwicmV0dXJuXFxcIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cXFwiKTtcXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXFxcInJldHVyblxcXCJdIDogb3BbMF0gPyB5W1xcXCJ0aHJvd1xcXCJdIHx8ICgodCA9IHlbXFxcInJldHVyblxcXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XFxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XFxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XFxuICAgIH1cXG59O1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmdlbmVyYXRlID0gdm9pZCAwO1xcbnZhciBpZGVudGl0eV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pZGVudGl0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lkZW50aXR5LmpzXFxcIik7XFxudmFyIGlzU2NoZWR1bGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzU2NoZWR1bGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNTY2hlZHVsZXIuanNcXFwiKTtcXG52YXIgZGVmZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGVmZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9kZWZlci5qc1xcXCIpO1xcbnZhciBzY2hlZHVsZUl0ZXJhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9zY2hlZHVsZWQvc2NoZWR1bGVJdGVyYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVJdGVyYWJsZS5qc1xcXCIpO1xcbmZ1bmN0aW9uIGdlbmVyYXRlKGluaXRpYWxTdGF0ZU9yT3B0aW9ucywgY29uZGl0aW9uLCBpdGVyYXRlLCByZXN1bHRTZWxlY3Rvck9yU2NoZWR1bGVyLCBzY2hlZHVsZXIpIHtcXG4gICAgdmFyIF9hLCBfYjtcXG4gICAgdmFyIHJlc3VsdFNlbGVjdG9yO1xcbiAgICB2YXIgaW5pdGlhbFN0YXRlO1xcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xcbiAgICAgICAgKF9hID0gaW5pdGlhbFN0YXRlT3JPcHRpb25zLCBpbml0aWFsU3RhdGUgPSBfYS5pbml0aWFsU3RhdGUsIGNvbmRpdGlvbiA9IF9hLmNvbmRpdGlvbiwgaXRlcmF0ZSA9IF9hLml0ZXJhdGUsIF9iID0gX2EucmVzdWx0U2VsZWN0b3IsIHJlc3VsdFNlbGVjdG9yID0gX2IgPT09IHZvaWQgMCA/IGlkZW50aXR5XzEuaWRlbnRpdHkgOiBfYiwgc2NoZWR1bGVyID0gX2Euc2NoZWR1bGVyKTtcXG4gICAgfVxcbiAgICBlbHNlIHtcXG4gICAgICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxTdGF0ZU9yT3B0aW9ucztcXG4gICAgICAgIGlmICghcmVzdWx0U2VsZWN0b3JPclNjaGVkdWxlciB8fCBpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKHJlc3VsdFNlbGVjdG9yT3JTY2hlZHVsZXIpKSB7XFxuICAgICAgICAgICAgcmVzdWx0U2VsZWN0b3IgPSBpZGVudGl0eV8xLmlkZW50aXR5O1xcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IHJlc3VsdFNlbGVjdG9yT3JTY2hlZHVsZXI7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICByZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yT3JTY2hlZHVsZXI7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gZ2VuKCkge1xcbiAgICAgICAgdmFyIHN0YXRlO1xcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBpbml0aWFsU3RhdGU7XFxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XFxuICAgICAgICAgICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgICAgICAgICAgIGlmICghKCFjb25kaXRpb24gfHwgY29uZGl0aW9uKHN0YXRlKSkpIHJldHVybiBbMywgNF07XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHJlc3VsdFNlbGVjdG9yKHN0YXRlKV07XFxuICAgICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcXG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBpdGVyYXRlKHN0YXRlKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XFxuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICByZXR1cm4gZGVmZXJfMS5kZWZlcigoc2NoZWR1bGVyXFxuICAgICAgICA/XFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NoZWR1bGVJdGVyYWJsZV8xLnNjaGVkdWxlSXRlcmFibGUoZ2VuKCksIHNjaGVkdWxlcik7IH1cXG4gICAgICAgIDpcXG4gICAgICAgICAgICBnZW4pKTtcXG59XFxuZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZ2VuZXJhdGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvaWlmLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2lpZi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuaWlmID0gdm9pZCAwO1xcbnZhciBkZWZlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kZWZlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2RlZmVyLmpzXFxcIik7XFxuZnVuY3Rpb24gaWlmKGNvbmRpdGlvbiwgdHJ1ZVJlc3VsdCwgZmFsc2VSZXN1bHQpIHtcXG4gICAgcmV0dXJuIGRlZmVyXzEuZGVmZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gKGNvbmRpdGlvbigpID8gdHJ1ZVJlc3VsdCA6IGZhbHNlUmVzdWx0KTsgfSk7XFxufVxcbmV4cG9ydHMuaWlmID0gaWlmO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlpZi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2lpZi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvaW5uZXJGcm9tLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XFxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XFxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcXFwidGhyb3dcXFwiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XFxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xcbiAgICB9KTtcXG59O1xcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XFxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XFxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcXFwidGhyb3dcXFwiOiB2ZXJiKDEpLCBcXFwicmV0dXJuXFxcIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cXFwiKTtcXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXFxcInJldHVyblxcXCJdIDogb3BbMF0gPyB5W1xcXCJ0aHJvd1xcXCJdIHx8ICgodCA9IHlbXFxcInJldHVyblxcXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XFxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XFxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XFxuICAgIH1cXG59O1xcbnZhciBfX2FzeW5jVmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jVmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cXFwiKTtcXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXFxcImZ1bmN0aW9uXFxcIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcXFwibmV4dFxcXCIpLCB2ZXJiKFxcXCJ0aHJvd1xcXCIpLCB2ZXJiKFxcXCJyZXR1cm5cXFwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XFxufTtcXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XFxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcXFwibnVtYmVyXFxcIikgcmV0dXJuIHtcXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXFxcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXFxcIiA6IFxcXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXFxcIik7XFxufTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5mcm9tUmVhZGFibGVTdHJlYW1MaWtlID0gZXhwb3J0cy5mcm9tQXN5bmNJdGVyYWJsZSA9IGV4cG9ydHMuZnJvbUl0ZXJhYmxlID0gZXhwb3J0cy5mcm9tUHJvbWlzZSA9IGV4cG9ydHMuZnJvbUFycmF5TGlrZSA9IGV4cG9ydHMuZnJvbUludGVyb3BPYnNlcnZhYmxlID0gZXhwb3J0cy5pbm5lckZyb20gPSB2b2lkIDA7XFxudmFyIGlzQXJyYXlMaWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzQXJyYXlMaWtlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNBcnJheUxpa2UuanNcXFwiKTtcXG52YXIgaXNQcm9taXNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzUHJvbWlzZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzUHJvbWlzZS5qc1xcXCIpO1xcbnZhciBPYnNlcnZhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9PYnNlcnZhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL09ic2VydmFibGUuanNcXFwiKTtcXG52YXIgaXNJbnRlcm9wT2JzZXJ2YWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc0ludGVyb3BPYnNlcnZhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNJbnRlcm9wT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbnZhciBpc0FzeW5jSXRlcmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNBc3luY0l0ZXJhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNBc3luY0l0ZXJhYmxlLmpzXFxcIik7XFxudmFyIHRocm93VW5vYnNlcnZhYmxlRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvdGhyb3dVbm9ic2VydmFibGVFcnJvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL3Rocm93VW5vYnNlcnZhYmxlRXJyb3IuanNcXFwiKTtcXG52YXIgaXNJdGVyYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc0l0ZXJhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNJdGVyYWJsZS5qc1xcXCIpO1xcbnZhciBpc1JlYWRhYmxlU3RyZWFtTGlrZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc1JlYWRhYmxlU3RyZWFtTGlrZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzUmVhZGFibGVTdHJlYW1MaWtlLmpzXFxcIik7XFxudmFyIGlzRnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG52YXIgcmVwb3J0VW5oYW5kbGVkRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvcmVwb3J0VW5oYW5kbGVkRXJyb3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9yZXBvcnRVbmhhbmRsZWRFcnJvci5qc1xcXCIpO1xcbnZhciBvYnNlcnZhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9zeW1ib2wvb2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zeW1ib2wvb2JzZXJ2YWJsZS5qc1xcXCIpO1xcbmZ1bmN0aW9uIGlubmVyRnJvbShpbnB1dCkge1xcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkge1xcbiAgICAgICAgcmV0dXJuIGlucHV0O1xcbiAgICB9XFxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XFxuICAgICAgICBpZiAoaXNJbnRlcm9wT2JzZXJ2YWJsZV8xLmlzSW50ZXJvcE9ic2VydmFibGUoaW5wdXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZyb21JbnRlcm9wT2JzZXJ2YWJsZShpbnB1dCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaXNBcnJheUxpa2VfMS5pc0FycmF5TGlrZShpbnB1dCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShpbnB1dCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaXNQcm9taXNlXzEuaXNQcm9taXNlKGlucHV0KSkge1xcbiAgICAgICAgICAgIHJldHVybiBmcm9tUHJvbWlzZShpbnB1dCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaXNBc3luY0l0ZXJhYmxlXzEuaXNBc3luY0l0ZXJhYmxlKGlucHV0KSkge1xcbiAgICAgICAgICAgIHJldHVybiBmcm9tQXN5bmNJdGVyYWJsZShpbnB1dCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaXNJdGVyYWJsZV8xLmlzSXRlcmFibGUoaW5wdXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZyb21JdGVyYWJsZShpbnB1dCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaXNSZWFkYWJsZVN0cmVhbUxpa2VfMS5pc1JlYWRhYmxlU3RyZWFtTGlrZShpbnB1dCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gZnJvbVJlYWRhYmxlU3RyZWFtTGlrZShpbnB1dCk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgdGhyb3cgdGhyb3dVbm9ic2VydmFibGVFcnJvcl8xLmNyZWF0ZUludmFsaWRPYnNlcnZhYmxlVHlwZUVycm9yKGlucHV0KTtcXG59XFxuZXhwb3J0cy5pbm5lckZyb20gPSBpbm5lckZyb207XFxuZnVuY3Rpb24gZnJvbUludGVyb3BPYnNlcnZhYmxlKG9iaikge1xcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgb2JzID0gb2JqW29ic2VydmFibGVfMS5vYnNlcnZhYmxlXSgpO1xcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9icy5zdWJzY3JpYmUpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG9icy5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XFxuICAgICAgICB9XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm92aWRlZCBvYmplY3QgZG9lcyBub3QgY29ycmVjdGx5IGltcGxlbWVudCBTeW1ib2wub2JzZXJ2YWJsZScpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5mcm9tSW50ZXJvcE9ic2VydmFibGUgPSBmcm9tSW50ZXJvcE9ic2VydmFibGU7XFxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZShhcnJheSkge1xcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aCAmJiAhc3Vic2NyaWJlci5jbG9zZWQ7IGkrKykge1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheVtpXSk7XFxuICAgICAgICB9XFxuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLmZyb21BcnJheUxpa2UgPSBmcm9tQXJyYXlMaWtlO1xcbmZ1bmN0aW9uIGZyb21Qcm9taXNlKHByb21pc2UpIHtcXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgcHJvbWlzZVxcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHN1YnNjcmliZXIuZXJyb3IoZXJyKTsgfSlcXG4gICAgICAgICAgICAudGhlbihudWxsLCByZXBvcnRVbmhhbmRsZWRFcnJvcl8xLnJlcG9ydFVuaGFuZGxlZEVycm9yKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuZnJvbVByb21pc2UgPSBmcm9tUHJvbWlzZTtcXG5mdW5jdGlvbiBmcm9tSXRlcmFibGUoaXRlcmFibGUpIHtcXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGVfMSwgX2E7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGZvciAodmFyIGl0ZXJhYmxlXzEgPSBfX3ZhbHVlcyhpdGVyYWJsZSksIGl0ZXJhYmxlXzFfMSA9IGl0ZXJhYmxlXzEubmV4dCgpOyAhaXRlcmFibGVfMV8xLmRvbmU7IGl0ZXJhYmxlXzFfMSA9IGl0ZXJhYmxlXzEubmV4dCgpKSB7XFxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGl0ZXJhYmxlXzFfMS52YWx1ZTtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxcbiAgICAgICAgZmluYWxseSB7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhYmxlXzFfMSAmJiAhaXRlcmFibGVfMV8xLmRvbmUgJiYgKF9hID0gaXRlcmFibGVfMS5yZXR1cm4pKSBfYS5jYWxsKGl0ZXJhYmxlXzEpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XFxuICAgICAgICB9XFxuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLmZyb21JdGVyYWJsZSA9IGZyb21JdGVyYWJsZTtcXG5mdW5jdGlvbiBmcm9tQXN5bmNJdGVyYWJsZShhc3luY0l0ZXJhYmxlKSB7XFxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHByb2Nlc3MoYXN5bmNJdGVyYWJsZSwgc3Vic2NyaWJlcikuY2F0Y2goZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3Vic2NyaWJlci5lcnJvcihlcnIpOyB9KTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuZnJvbUFzeW5jSXRlcmFibGUgPSBmcm9tQXN5bmNJdGVyYWJsZTtcXG5mdW5jdGlvbiBmcm9tUmVhZGFibGVTdHJlYW1MaWtlKHJlYWRhYmxlU3RyZWFtKSB7XFxuICAgIHJldHVybiBmcm9tQXN5bmNJdGVyYWJsZShpc1JlYWRhYmxlU3RyZWFtTGlrZV8xLnJlYWRhYmxlU3RyZWFtTGlrZVRvQXN5bmNHZW5lcmF0b3IocmVhZGFibGVTdHJlYW0pKTtcXG59XFxuZXhwb3J0cy5mcm9tUmVhZGFibGVTdHJlYW1MaWtlID0gZnJvbVJlYWRhYmxlU3RyZWFtTGlrZTtcXG5mdW5jdGlvbiBwcm9jZXNzKGFzeW5jSXRlcmFibGUsIHN1YnNjcmliZXIpIHtcXG4gICAgdmFyIGFzeW5jSXRlcmFibGVfMSwgYXN5bmNJdGVyYWJsZV8xXzE7XFxuICAgIHZhciBlXzIsIF9hO1xcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgdmFsdWUsIGVfMl8xO1xcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFswLCA1LCA2LCAxMV0pO1xcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNJdGVyYWJsZV8xID0gX19hc3luY1ZhbHVlcyhhc3luY0l0ZXJhYmxlKTtcXG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQsIGFzeW5jSXRlcmFibGVfMS5uZXh0KCldO1xcbiAgICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIShhc3luY0l0ZXJhYmxlXzFfMSA9IF9iLnNlbnQoKSwgIWFzeW5jSXRlcmFibGVfMV8xLmRvbmUpKSByZXR1cm4gWzMsIDRdO1xcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhc3luY0l0ZXJhYmxlXzFfMS52YWx1ZTtcXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMywgMV07XFxuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFszLCAxMV07XFxuICAgICAgICAgICAgICAgIGNhc2UgNTpcXG4gICAgICAgICAgICAgICAgICAgIGVfMl8xID0gX2Iuc2VudCgpO1xcbiAgICAgICAgICAgICAgICAgICAgZV8yID0geyBlcnJvcjogZV8yXzEgfTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMTFdO1xcbiAgICAgICAgICAgICAgICBjYXNlIDY6XFxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzYsICwgOSwgMTBdKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGFzeW5jSXRlcmFibGVfMV8xICYmICFhc3luY0l0ZXJhYmxlXzFfMS5kb25lICYmIChfYSA9IGFzeW5jSXRlcmFibGVfMS5yZXR1cm4pKSkgcmV0dXJuIFszLCA4XTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgX2EuY2FsbChhc3luY0l0ZXJhYmxlXzEpXTtcXG4gICAgICAgICAgICAgICAgY2FzZSA3OlxcbiAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA4O1xcbiAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMywgMTBdO1xcbiAgICAgICAgICAgICAgICBjYXNlIDk6XFxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzddO1xcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzddO1xcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfSk7XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlubmVyRnJvbS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2lubmVyRnJvbS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbnRlcnZhbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2ludGVydmFsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmludGVydmFsID0gdm9pZCAwO1xcbnZhciBhc3luY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc2NoZWR1bGVyL2FzeW5jICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9hc3luYy5qc1xcXCIpO1xcbnZhciB0aW1lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90aW1lciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3RpbWVyLmpzXFxcIik7XFxuZnVuY3Rpb24gaW50ZXJ2YWwocGVyaW9kLCBzY2hlZHVsZXIpIHtcXG4gICAgaWYgKHBlcmlvZCA9PT0gdm9pZCAwKSB7IHBlcmlvZCA9IDA7IH1cXG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmNTY2hlZHVsZXI7IH1cXG4gICAgaWYgKHBlcmlvZCA8IDApIHtcXG4gICAgICAgIHBlcmlvZCA9IDA7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRpbWVyXzEudGltZXIocGVyaW9kLCBwZXJpb2QsIHNjaGVkdWxlcik7XFxufVxcbmV4cG9ydHMuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcnZhbC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2ludGVydmFsLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL21lcmdlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvbWVyZ2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMubWVyZ2UgPSB2b2lkIDA7XFxudmFyIG1lcmdlQWxsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vcGVyYXRvcnMvbWVyZ2VBbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlQWxsLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG52YXIgZW1wdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZW1wdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9lbXB0eS5qc1xcXCIpO1xcbnZhciBhcmdzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyZ3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9hcmdzLmpzXFxcIik7XFxudmFyIGZyb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb20uanNcXFwiKTtcXG5mdW5jdGlvbiBtZXJnZSgpIHtcXG4gICAgdmFyIGFyZ3MgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcXG4gICAgfVxcbiAgICB2YXIgc2NoZWR1bGVyID0gYXJnc18xLnBvcFNjaGVkdWxlcihhcmdzKTtcXG4gICAgdmFyIGNvbmN1cnJlbnQgPSBhcmdzXzEucG9wTnVtYmVyKGFyZ3MsIEluZmluaXR5KTtcXG4gICAgdmFyIHNvdXJjZXMgPSBhcmdzO1xcbiAgICByZXR1cm4gIXNvdXJjZXMubGVuZ3RoXFxuICAgICAgICA/XFxuICAgICAgICAgICAgZW1wdHlfMS5FTVBUWVxcbiAgICAgICAgOiBzb3VyY2VzLmxlbmd0aCA9PT0gMVxcbiAgICAgICAgICAgID9cXG4gICAgICAgICAgICAgICAgaW5uZXJGcm9tXzEuaW5uZXJGcm9tKHNvdXJjZXNbMF0pXFxuICAgICAgICAgICAgOlxcbiAgICAgICAgICAgICAgICBtZXJnZUFsbF8xLm1lcmdlQWxsKGNvbmN1cnJlbnQpKGZyb21fMS5mcm9tKHNvdXJjZXMsIHNjaGVkdWxlcikpO1xcbn1cXG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2UuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9tZXJnZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9uZXZlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL25ldmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLm5ldmVyID0gZXhwb3J0cy5ORVZFUiA9IHZvaWQgMDtcXG52YXIgT2JzZXJ2YWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vT2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzXFxcIik7XFxudmFyIG5vb3BfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbm9vcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL25vb3AuanNcXFwiKTtcXG5leHBvcnRzLk5FVkVSID0gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKG5vb3BfMS5ub29wKTtcXG5mdW5jdGlvbiBuZXZlcigpIHtcXG4gICAgcmV0dXJuIGV4cG9ydHMuTkVWRVI7XFxufVxcbmV4cG9ydHMubmV2ZXIgPSBuZXZlcjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXZlci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL25ldmVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL29mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvb2YuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMub2YgPSB2b2lkIDA7XFxudmFyIGFyZ3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvYXJncyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyZ3MuanNcXFwiKTtcXG52YXIgZnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZnJvbS5qc1xcXCIpO1xcbmZ1bmN0aW9uIG9mKCkge1xcbiAgICB2YXIgYXJncyA9IFtdO1xcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHZhciBzY2hlZHVsZXIgPSBhcmdzXzEucG9wU2NoZWR1bGVyKGFyZ3MpO1xcbiAgICByZXR1cm4gZnJvbV8xLmZyb20oYXJncywgc2NoZWR1bGVyKTtcXG59XFxuZXhwb3J0cy5vZiA9IG9mO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9mLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvb2YuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvb25FcnJvclJlc3VtZU5leHQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9vbkVycm9yUmVzdW1lTmV4dC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5vbkVycm9yUmVzdW1lTmV4dCA9IHZvaWQgMDtcXG52YXIgT2JzZXJ2YWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vT2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzXFxcIik7XFxudmFyIGFyZ3NPckFyZ0FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyZ3NPckFyZ0FycmF5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJnc09yQXJnQXJyYXkuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG52YXIgbm9vcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9ub29wICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbm9vcC5qc1xcXCIpO1xcbnZhciBpbm5lckZyb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW5uZXJGcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvaW5uZXJGcm9tLmpzXFxcIik7XFxuZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHQoKSB7XFxuICAgIHZhciBzb3VyY2VzID0gW107XFxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICBzb3VyY2VzW19pXSA9IGFyZ3VtZW50c1tfaV07XFxuICAgIH1cXG4gICAgdmFyIG5leHRTb3VyY2VzID0gYXJnc09yQXJnQXJyYXlfMS5hcmdzT3JBcmdBcnJheShzb3VyY2VzKTtcXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gMDtcXG4gICAgICAgIHZhciBzdWJzY3JpYmVOZXh0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmIChzb3VyY2VJbmRleCA8IG5leHRTb3VyY2VzLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFNvdXJjZSA9IHZvaWQgMDtcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIG5leHRTb3VyY2UgPSBpbm5lckZyb21fMS5pbm5lckZyb20obmV4dFNvdXJjZXNbc291cmNlSW5kZXgrK10pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZU5leHQoKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJTdWJzY3JpYmVyID0gbmV3IE9wZXJhdG9yU3Vic2NyaWJlcl8xLk9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB1bmRlZmluZWQsIG5vb3BfMS5ub29wLCBub29wXzEubm9vcCk7XFxuICAgICAgICAgICAgICAgIG5leHRTb3VyY2Uuc3Vic2NyaWJlKGlubmVyU3Vic2NyaWJlcik7XFxuICAgICAgICAgICAgICAgIGlubmVyU3Vic2NyaWJlci5hZGQoc3Vic2NyaWJlTmV4dCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfTtcXG4gICAgICAgIHN1YnNjcmliZU5leHQoKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMub25FcnJvclJlc3VtZU5leHQgPSBvbkVycm9yUmVzdW1lTmV4dDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbkVycm9yUmVzdW1lTmV4dC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL29uRXJyb3JSZXN1bWVOZXh0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3BhaXJzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvcGFpcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMucGFpcnMgPSB2b2lkIDA7XFxudmFyIGZyb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb20uanNcXFwiKTtcXG5mdW5jdGlvbiBwYWlycyhvYmosIHNjaGVkdWxlcikge1xcbiAgICByZXR1cm4gZnJvbV8xLmZyb20oT2JqZWN0LmVudHJpZXMob2JqKSwgc2NoZWR1bGVyKTtcXG59XFxuZXhwb3J0cy5wYWlycyA9IHBhaXJzO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhaXJzLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvcGFpcnMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvcGFydGl0aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3BhcnRpdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMucGFydGl0aW9uID0gdm9pZCAwO1xcbnZhciBub3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbm90ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbm90LmpzXFxcIik7XFxudmFyIGZpbHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb3BlcmF0b3JzL2ZpbHRlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZmlsdGVyLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG5mdW5jdGlvbiBwYXJ0aXRpb24oc291cmNlLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcXG4gICAgcmV0dXJuIFtmaWx0ZXJfMS5maWx0ZXIocHJlZGljYXRlLCB0aGlzQXJnKShpbm5lckZyb21fMS5pbm5lckZyb20oc291cmNlKSksIGZpbHRlcl8xLmZpbHRlcihub3RfMS5ub3QocHJlZGljYXRlLCB0aGlzQXJnKSkoaW5uZXJGcm9tXzEuaW5uZXJGcm9tKHNvdXJjZSkpXTtcXG59XFxuZXhwb3J0cy5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFydGl0aW9uLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvcGFydGl0aW9uLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3JhY2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3JhY2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5yYWNlSW5pdCA9IGV4cG9ydHMucmFjZSA9IHZvaWQgMDtcXG52YXIgT2JzZXJ2YWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vT2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG52YXIgYXJnc09yQXJnQXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvYXJnc09yQXJnQXJyYXkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9hcmdzT3JBcmdBcnJheS5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIHJhY2UoKSB7XFxuICAgIHZhciBzb3VyY2VzID0gW107XFxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICBzb3VyY2VzW19pXSA9IGFyZ3VtZW50c1tfaV07XFxuICAgIH1cXG4gICAgc291cmNlcyA9IGFyZ3NPckFyZ0FycmF5XzEuYXJnc09yQXJnQXJyYXkoc291cmNlcyk7XFxuICAgIHJldHVybiBzb3VyY2VzLmxlbmd0aCA9PT0gMSA/IGlubmVyRnJvbV8xLmlubmVyRnJvbShzb3VyY2VzWzBdKSA6IG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShyYWNlSW5pdChzb3VyY2VzKSk7XFxufVxcbmV4cG9ydHMucmFjZSA9IHJhY2U7XFxuZnVuY3Rpb24gcmFjZUluaXQoc291cmNlcykge1xcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gW107XFxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKGlubmVyRnJvbV8xLmlubmVyRnJvbShzb3VyY2VzW2ldKS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9ucykge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdWJzY3JpcHRpb25zLmxlbmd0aDsgcysrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcyAhPT0gaSAmJiBzdWJzY3JpcHRpb25zW3NdLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zID0gbnVsbDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xcbiAgICAgICAgICAgIH0pKSk7XFxuICAgICAgICB9O1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IHN1YnNjcmlwdGlvbnMgJiYgIXN1YnNjcmliZXIuY2xvc2VkICYmIGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgX2xvb3BfMShpKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG59XFxuZXhwb3J0cy5yYWNlSW5pdCA9IHJhY2VJbml0O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhY2UuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9yYWNlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3JhbmdlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvcmFuZ2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMucmFuZ2UgPSB2b2lkIDA7XFxudmFyIE9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbnZhciBlbXB0eV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lbXB0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2VtcHR5LmpzXFxcIik7XFxuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGNvdW50LCBzY2hlZHVsZXIpIHtcXG4gICAgaWYgKGNvdW50ID09IG51bGwpIHtcXG4gICAgICAgIGNvdW50ID0gc3RhcnQ7XFxuICAgICAgICBzdGFydCA9IDA7XFxuICAgIH1cXG4gICAgaWYgKGNvdW50IDw9IDApIHtcXG4gICAgICAgIHJldHVybiBlbXB0eV8xLkVNUFRZO1xcbiAgICB9XFxuICAgIHZhciBlbmQgPSBjb3VudCArIHN0YXJ0O1xcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKHNjaGVkdWxlclxcbiAgICAgICAgP1xcbiAgICAgICAgICAgIGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICAgICAgICAgIHZhciBuID0gc3RhcnQ7XFxuICAgICAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPCBlbmQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQobisrKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIDpcXG4gICAgICAgICAgICBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHN0YXJ0O1xcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IGVuZCAmJiAhc3Vic2NyaWJlci5jbG9zZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChuKyspO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgICAgICB9KTtcXG59XFxuZXhwb3J0cy5yYW5nZSA9IHJhbmdlO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbmdlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvcmFuZ2UuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvdGhyb3dFcnJvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvdGhyb3dFcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnRocm93RXJyb3IgPSB2b2lkIDA7XFxudmFyIE9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbnZhciBpc0Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzRnVuY3Rpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxuZnVuY3Rpb24gdGhyb3dFcnJvcihlcnJvck9yRXJyb3JGYWN0b3J5LCBzY2hlZHVsZXIpIHtcXG4gICAgdmFyIGVycm9yRmFjdG9yeSA9IGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKGVycm9yT3JFcnJvckZhY3RvcnkpID8gZXJyb3JPckVycm9yRmFjdG9yeSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yT3JFcnJvckZhY3Rvcnk7IH07XFxuICAgIHZhciBpbml0ID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHsgcmV0dXJuIHN1YnNjcmliZXIuZXJyb3IoZXJyb3JGYWN0b3J5KCkpOyB9O1xcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKHNjaGVkdWxlciA/IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7IHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoaW5pdCwgMCwgc3Vic2NyaWJlcik7IH0gOiBpbml0KTtcXG59XFxuZXhwb3J0cy50aHJvd0Vycm9yID0gdGhyb3dFcnJvcjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvd0Vycm9yLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvdGhyb3dFcnJvci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS90aW1lci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3RpbWVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnRpbWVyID0gdm9pZCAwO1xcbnZhciBPYnNlcnZhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9PYnNlcnZhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL09ic2VydmFibGUuanNcXFwiKTtcXG52YXIgYXN5bmNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3NjaGVkdWxlci9hc3luYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvYXN5bmMuanNcXFwiKTtcXG52YXIgaXNTY2hlZHVsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNTY2hlZHVsZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc1NjaGVkdWxlci5qc1xcXCIpO1xcbnZhciBpc0RhdGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNEYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNEYXRlLmpzXFxcIik7XFxuZnVuY3Rpb24gdGltZXIoZHVlVGltZSwgaW50ZXJ2YWxPclNjaGVkdWxlciwgc2NoZWR1bGVyKSB7XFxuICAgIGlmIChkdWVUaW1lID09PSB2b2lkIDApIHsgZHVlVGltZSA9IDA7IH1cXG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cXG4gICAgdmFyIGludGVydmFsRHVyYXRpb24gPSAtMTtcXG4gICAgaWYgKGludGVydmFsT3JTY2hlZHVsZXIgIT0gbnVsbCkge1xcbiAgICAgICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoaW50ZXJ2YWxPclNjaGVkdWxlcikpIHtcXG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBpbnRlcnZhbE9yU2NoZWR1bGVyO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgaW50ZXJ2YWxEdXJhdGlvbiA9IGludGVydmFsT3JTY2hlZHVsZXI7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGR1ZSA9IGlzRGF0ZV8xLmlzVmFsaWREYXRlKGR1ZVRpbWUpID8gK2R1ZVRpbWUgLSBzY2hlZHVsZXIubm93KCkgOiBkdWVUaW1lO1xcbiAgICAgICAgaWYgKGR1ZSA8IDApIHtcXG4gICAgICAgICAgICBkdWUgPSAwO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIG4gPSAwO1xcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQobisrKTtcXG4gICAgICAgICAgICAgICAgaWYgKDAgPD0gaW50ZXJ2YWxEdXJhdGlvbikge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZSh1bmRlZmluZWQsIGludGVydmFsRHVyYXRpb24pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSwgZHVlKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMudGltZXIgPSB0aW1lcjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3RpbWVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3VzaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvdXNpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMudXNpbmcgPSB2b2lkIDA7XFxudmFyIE9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbnZhciBpbm5lckZyb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW5uZXJGcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvaW5uZXJGcm9tLmpzXFxcIik7XFxudmFyIGVtcHR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VtcHR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZW1wdHkuanNcXFwiKTtcXG5mdW5jdGlvbiB1c2luZyhyZXNvdXJjZUZhY3RvcnksIG9ic2VydmFibGVGYWN0b3J5KSB7XFxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciByZXNvdXJjZSA9IHJlc291cmNlRmFjdG9yeSgpO1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9ic2VydmFibGVGYWN0b3J5KHJlc291cmNlKTtcXG4gICAgICAgIHZhciBzb3VyY2UgPSByZXN1bHQgPyBpbm5lckZyb21fMS5pbm5lckZyb20ocmVzdWx0KSA6IGVtcHR5XzEuRU1QVFk7XFxuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAocmVzb3VyY2UpIHtcXG4gICAgICAgICAgICAgICAgcmVzb3VyY2UudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy51c2luZyA9IHVzaW5nO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzaW5nLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvdXNpbmcuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvemlwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3ppcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XFxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XFxuICAgIGlmICghbSkgcmV0dXJuIG87XFxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xcbiAgICB0cnkge1xcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XFxuICAgIH1cXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XFxuICAgIGZpbmFsbHkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcXFwicmV0dXJuXFxcIl0pKSBtLmNhbGwoaSk7XFxuICAgICAgICB9XFxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cXG4gICAgfVxcbiAgICByZXR1cm4gYXI7XFxufTtcXG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XFxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xcbiAgICByZXR1cm4gdG87XFxufTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy56aXAgPSB2b2lkIDA7XFxudmFyIE9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbnZhciBpbm5lckZyb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW5uZXJGcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvaW5uZXJGcm9tLmpzXFxcIik7XFxudmFyIGFyZ3NPckFyZ0FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyZ3NPckFyZ0FycmF5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJnc09yQXJnQXJyYXkuanNcXFwiKTtcXG52YXIgZW1wdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZW1wdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9lbXB0eS5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbnZhciBhcmdzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyZ3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9hcmdzLmpzXFxcIik7XFxuZnVuY3Rpb24gemlwKCkge1xcbiAgICB2YXIgYXJncyA9IFtdO1xcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHZhciByZXN1bHRTZWxlY3RvciA9IGFyZ3NfMS5wb3BSZXN1bHRTZWxlY3RvcihhcmdzKTtcXG4gICAgdmFyIHNvdXJjZXMgPSBhcmdzT3JBcmdBcnJheV8xLmFyZ3NPckFyZ0FycmF5KGFyZ3MpO1xcbiAgICByZXR1cm4gc291cmNlcy5sZW5ndGhcXG4gICAgICAgID8gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICAgICAgdmFyIGJ1ZmZlcnMgPSBzb3VyY2VzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSk7XFxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZCA9IHNvdXJjZXMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9KTtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmFkZChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGJ1ZmZlcnMgPSBjb21wbGV0ZWQgPSBudWxsO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHNvdXJjZUluZGV4KSB7XFxuICAgICAgICAgICAgICAgIGlubmVyRnJvbV8xLmlubmVyRnJvbShzb3VyY2VzW3NvdXJjZUluZGV4XSkuc3Vic2NyaWJlKE9wZXJhdG9yU3Vic2NyaWJlcl8xLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnNbc291cmNlSW5kZXhdLnB1c2godmFsdWUpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcnMuZXZlcnkoZnVuY3Rpb24gKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyLmxlbmd0aDsgfSkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gYnVmZmVycy5tYXAoZnVuY3Rpb24gKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyLnNoaWZ0KCk7IH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHRTZWxlY3RvciA/IHJlc3VsdFNlbGVjdG9yLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHJlc3VsdCkpKSA6IHJlc3VsdCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcnMuc29tZShmdW5jdGlvbiAoYnVmZmVyLCBpKSB7IHJldHVybiAhYnVmZmVyLmxlbmd0aCAmJiBjb21wbGV0ZWRbaV07IH0pKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZFtzb3VyY2VJbmRleF0gPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgIWJ1ZmZlcnNbc291cmNlSW5kZXhdLmxlbmd0aCAmJiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIGZvciAodmFyIHNvdXJjZUluZGV4ID0gMDsgIXN1YnNjcmliZXIuY2xvc2VkICYmIHNvdXJjZUluZGV4IDwgc291cmNlcy5sZW5ndGg7IHNvdXJjZUluZGV4KyspIHtcXG4gICAgICAgICAgICAgICAgX2xvb3BfMShzb3VyY2VJbmRleCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGJ1ZmZlcnMgPSBjb21wbGV0ZWQgPSBudWxsO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICB9KVxcbiAgICAgICAgOiBlbXB0eV8xLkVNUFRZO1xcbn1cXG5leHBvcnRzLnppcCA9IHppcDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD16aXAuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS96aXAuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxuICAgIH07XFxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIGIgIT09IG51bGwpXFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcXFwiICsgU3RyaW5nKGIpICsgXFxcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXFxcIik7XFxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XFxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XFxuICAgIH07XFxufSkoKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5PcGVyYXRvclN1YnNjcmliZXIgPSBleHBvcnRzLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciA9IHZvaWQgMDtcXG52YXIgU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJzY3JpYmVyLmpzXFxcIik7XFxuZnVuY3Rpb24gY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBvbk5leHQsIG9uQ29tcGxldGUsIG9uRXJyb3IsIG9uRmluYWxpemUpIHtcXG4gICAgcmV0dXJuIG5ldyBPcGVyYXRvclN1YnNjcmliZXIoZGVzdGluYXRpb24sIG9uTmV4dCwgb25Db21wbGV0ZSwgb25FcnJvciwgb25GaW5hbGl6ZSk7XFxufVxcbmV4cG9ydHMuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyID0gY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xcbiAgICBfX2V4dGVuZHMoT3BlcmF0b3JTdWJzY3JpYmVyLCBfc3VwZXIpO1xcbiAgICBmdW5jdGlvbiBPcGVyYXRvclN1YnNjcmliZXIoZGVzdGluYXRpb24sIG9uTmV4dCwgb25Db21wbGV0ZSwgb25FcnJvciwgb25GaW5hbGl6ZSwgc2hvdWxkVW5zdWJzY3JpYmUpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xcbiAgICAgICAgX3RoaXMub25GaW5hbGl6ZSA9IG9uRmluYWxpemU7XFxuICAgICAgICBfdGhpcy5zaG91bGRVbnN1YnNjcmliZSA9IHNob3VsZFVuc3Vic2NyaWJlO1xcbiAgICAgICAgX3RoaXMuX25leHQgPSBvbk5leHRcXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgb25OZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIDogX3N1cGVyLnByb3RvdHlwZS5fbmV4dDtcXG4gICAgICAgIF90aGlzLl9lcnJvciA9IG9uRXJyb3JcXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIDogX3N1cGVyLnByb3RvdHlwZS5fZXJyb3I7XFxuICAgICAgICBfdGhpcy5fY29tcGxldGUgPSBvbkNvbXBsZXRlXFxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICA6IF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlO1xcbiAgICAgICAgcmV0dXJuIF90aGlzO1xcbiAgICB9XFxuICAgIE9wZXJhdG9yU3Vic2NyaWJlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgX2E7XFxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkVW5zdWJzY3JpYmUgfHwgdGhpcy5zaG91bGRVbnN1YnNjcmliZSgpKSB7XFxuICAgICAgICAgICAgdmFyIGNsb3NlZF8xID0gdGhpcy5jbG9zZWQ7XFxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xcbiAgICAgICAgICAgICFjbG9zZWRfMSAmJiAoKF9hID0gdGhpcy5vbkZpbmFsaXplKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKSk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIHJldHVybiBPcGVyYXRvclN1YnNjcmliZXI7XFxufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xcbmV4cG9ydHMuT3BlcmF0b3JTdWJzY3JpYmVyID0gT3BlcmF0b3JTdWJzY3JpYmVyO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9wZXJhdG9yU3Vic2NyaWJlci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvYXVkaXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvYXVkaXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5hdWRpdCA9IHZvaWQgMDtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBpbm5lckZyb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvaW5uZXJGcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvaW5uZXJGcm9tLmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIGF1ZGl0KGR1cmF0aW9uU2VsZWN0b3IpIHtcXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBoYXNWYWx1ZSA9IGZhbHNlO1xcbiAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IG51bGw7XFxuICAgICAgICB2YXIgZHVyYXRpb25TdWJzY3JpYmVyID0gbnVsbDtcXG4gICAgICAgIHZhciBpc0NvbXBsZXRlID0gZmFsc2U7XFxuICAgICAgICB2YXIgZW5kRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgZHVyYXRpb25TdWJzY3JpYmVyID09PSBudWxsIHx8IGR1cmF0aW9uU3Vic2NyaWJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHVyYXRpb25TdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgZHVyYXRpb25TdWJzY3JpYmVyID0gbnVsbDtcXG4gICAgICAgICAgICBpZiAoaGFzVmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgaGFzVmFsdWUgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbGFzdFZhbHVlO1xcbiAgICAgICAgICAgICAgICBsYXN0VmFsdWUgPSBudWxsO1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpc0NvbXBsZXRlICYmIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgIH07XFxuICAgICAgICB2YXIgY2xlYW51cER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGR1cmF0aW9uU3Vic2NyaWJlciA9IG51bGw7XFxuICAgICAgICAgICAgaXNDb21wbGV0ZSAmJiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9O1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xcbiAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHZhbHVlO1xcbiAgICAgICAgICAgIGlmICghZHVyYXRpb25TdWJzY3JpYmVyKSB7XFxuICAgICAgICAgICAgICAgIGlubmVyRnJvbV8xLmlubmVyRnJvbShkdXJhdGlvblNlbGVjdG9yKHZhbHVlKSkuc3Vic2NyaWJlKChkdXJhdGlvblN1YnNjcmliZXIgPSBPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZW5kRHVyYXRpb24sIGNsZWFudXBEdXJhdGlvbikpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaXNDb21wbGV0ZSA9IHRydWU7XFxuICAgICAgICAgICAgKCFoYXNWYWx1ZSB8fCAhZHVyYXRpb25TdWJzY3JpYmVyIHx8IGR1cmF0aW9uU3Vic2NyaWJlci5jbG9zZWQpICYmIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgIH0pKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuYXVkaXQgPSBhdWRpdDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdWRpdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvYXVkaXQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9hdWRpdFRpbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2F1ZGl0VGltZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5hdWRpdFRpbWUgPSB2b2lkIDA7XFxudmFyIGFzeW5jXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9zY2hlZHVsZXIvYXN5bmMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL2FzeW5jLmpzXFxcIik7XFxudmFyIGF1ZGl0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2F1ZGl0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9hdWRpdC5qc1xcXCIpO1xcbnZhciB0aW1lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS90aW1lciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3RpbWVyLmpzXFxcIik7XFxuZnVuY3Rpb24gYXVkaXRUaW1lKGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcXG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmNTY2hlZHVsZXI7IH1cXG4gICAgcmV0dXJuIGF1ZGl0XzEuYXVkaXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGltZXJfMS50aW1lcihkdXJhdGlvbiwgc2NoZWR1bGVyKTsgfSk7XFxufVxcbmV4cG9ydHMuYXVkaXRUaW1lID0gYXVkaXRUaW1lO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1ZGl0VGltZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvYXVkaXRUaW1lLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuYnVmZmVyID0gdm9pZCAwO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIG5vb3BfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbm9vcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL25vb3AuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG5mdW5jdGlvbiBidWZmZXIoY2xvc2luZ05vdGlmaWVyKSB7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgY3VycmVudEJ1ZmZlciA9IFtdO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBjdXJyZW50QnVmZmVyLnB1c2godmFsdWUpOyB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGN1cnJlbnRCdWZmZXIpO1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgIH0pKTtcXG4gICAgICAgIGlubmVyRnJvbV8xLmlubmVyRnJvbShjbG9zaW5nTm90aWZpZXIpLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBiID0gY3VycmVudEJ1ZmZlcjtcXG4gICAgICAgICAgICBjdXJyZW50QnVmZmVyID0gW107XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGIpO1xcbiAgICAgICAgfSwgbm9vcF8xLm5vb3ApKTtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgY3VycmVudEJ1ZmZlciA9IG51bGw7XFxuICAgICAgICB9O1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5idWZmZXIgPSBidWZmZXI7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJDb3VudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJDb3VudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XFxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXFxcIm51bWJlclxcXCIpIHJldHVybiB7XFxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFxcXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlxcXCIgOiBcXFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlxcXCIpO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuYnVmZmVyQ291bnQgPSB2b2lkIDA7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxudmFyIGFyclJlbW92ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9hcnJSZW1vdmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9hcnJSZW1vdmUuanNcXFwiKTtcXG5mdW5jdGlvbiBidWZmZXJDb3VudChidWZmZXJTaXplLCBzdGFydEJ1ZmZlckV2ZXJ5KSB7XFxuICAgIGlmIChzdGFydEJ1ZmZlckV2ZXJ5ID09PSB2b2lkIDApIHsgc3RhcnRCdWZmZXJFdmVyeSA9IG51bGw7IH1cXG4gICAgc3RhcnRCdWZmZXJFdmVyeSA9IHN0YXJ0QnVmZmVyRXZlcnkgIT09IG51bGwgJiYgc3RhcnRCdWZmZXJFdmVyeSAhPT0gdm9pZCAwID8gc3RhcnRCdWZmZXJFdmVyeSA6IGJ1ZmZlclNpemU7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgYnVmZmVycyA9IFtdO1xcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xcbiAgICAgICAgICAgIHZhciB0b0VtaXQgPSBudWxsO1xcbiAgICAgICAgICAgIGlmIChjb3VudCsrICUgc3RhcnRCdWZmZXJFdmVyeSA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goW10pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBidWZmZXJzXzEgPSBfX3ZhbHVlcyhidWZmZXJzKSwgYnVmZmVyc18xXzEgPSBidWZmZXJzXzEubmV4dCgpOyAhYnVmZmVyc18xXzEuZG9uZTsgYnVmZmVyc18xXzEgPSBidWZmZXJzXzEubmV4dCgpKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyc18xXzEudmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaCh2YWx1ZSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyU2l6ZSA8PSBidWZmZXIubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9FbWl0ID0gdG9FbWl0ICE9PSBudWxsICYmIHRvRW1pdCAhPT0gdm9pZCAwID8gdG9FbWl0IDogW107XFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9FbWl0LnB1c2goYnVmZmVyKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxcbiAgICAgICAgICAgIGZpbmFsbHkge1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcnNfMV8xICYmICFidWZmZXJzXzFfMS5kb25lICYmIChfYSA9IGJ1ZmZlcnNfMS5yZXR1cm4pKSBfYS5jYWxsKGJ1ZmZlcnNfMSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAodG9FbWl0KSB7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0b0VtaXRfMSA9IF9fdmFsdWVzKHRvRW1pdCksIHRvRW1pdF8xXzEgPSB0b0VtaXRfMS5uZXh0KCk7ICF0b0VtaXRfMV8xLmRvbmU7IHRvRW1pdF8xXzEgPSB0b0VtaXRfMS5uZXh0KCkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gdG9FbWl0XzFfMS52YWx1ZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJSZW1vdmVfMS5hcnJSZW1vdmUoYnVmZmVycywgYnVmZmVyKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoYnVmZmVyKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvRW1pdF8xXzEgJiYgIXRvRW1pdF8xXzEuZG9uZSAmJiAoX2IgPSB0b0VtaXRfMS5yZXR1cm4pKSBfYi5jYWxsKHRvRW1pdF8xKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgZV8zLCBfYTtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBidWZmZXJzXzIgPSBfX3ZhbHVlcyhidWZmZXJzKSwgYnVmZmVyc18yXzEgPSBidWZmZXJzXzIubmV4dCgpOyAhYnVmZmVyc18yXzEuZG9uZTsgYnVmZmVyc18yXzEgPSBidWZmZXJzXzIubmV4dCgpKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyc18yXzEudmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoYnVmZmVyKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxcbiAgICAgICAgICAgIGZpbmFsbHkge1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcnNfMl8xICYmICFidWZmZXJzXzJfMS5kb25lICYmIChfYSA9IGJ1ZmZlcnNfMi5yZXR1cm4pKSBfYS5jYWxsKGJ1ZmZlcnNfMik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9LCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBidWZmZXJzID0gbnVsbDtcXG4gICAgICAgIH0pKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuYnVmZmVyQ291bnQgPSBidWZmZXJDb3VudDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXJDb3VudC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyQ291bnQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJUaW1lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyVGltZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XFxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcXFwibnVtYmVyXFxcIikgcmV0dXJuIHtcXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXFxcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXFxcIiA6IFxcXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXFxcIik7XFxufTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5idWZmZXJUaW1lID0gdm9pZCAwO1xcbnZhciBTdWJzY3JpcHRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1N1YnNjcmlwdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJzY3JpcHRpb24uanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG52YXIgYXJyUmVtb3ZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyclJlbW92ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyclJlbW92ZS5qc1xcXCIpO1xcbnZhciBhc3luY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc2NoZWR1bGVyL2FzeW5jICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9hc3luYy5qc1xcXCIpO1xcbnZhciBhcmdzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyZ3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9hcmdzLmpzXFxcIik7XFxudmFyIGV4ZWN1dGVTY2hlZHVsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9leGVjdXRlU2NoZWR1bGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9leGVjdXRlU2NoZWR1bGUuanNcXFwiKTtcXG5mdW5jdGlvbiBidWZmZXJUaW1lKGJ1ZmZlclRpbWVTcGFuKSB7XFxuICAgIHZhciBfYSwgX2I7XFxuICAgIHZhciBvdGhlckFyZ3MgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIG90aGVyQXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcXG4gICAgfVxcbiAgICB2YXIgc2NoZWR1bGVyID0gKF9hID0gYXJnc18xLnBvcFNjaGVkdWxlcihvdGhlckFyZ3MpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBhc3luY18xLmFzeW5jU2NoZWR1bGVyO1xcbiAgICB2YXIgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCA9IChfYiA9IG90aGVyQXJnc1swXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcXG4gICAgdmFyIG1heEJ1ZmZlclNpemUgPSBvdGhlckFyZ3NbMV0gfHwgSW5maW5pdHk7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgYnVmZmVyUmVjb3JkcyA9IFtdO1xcbiAgICAgICAgdmFyIHJlc3RhcnRPbkVtaXQgPSBmYWxzZTtcXG4gICAgICAgIHZhciBlbWl0ID0gZnVuY3Rpb24gKHJlY29yZCkge1xcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSByZWNvcmQuYnVmZmVyLCBzdWJzID0gcmVjb3JkLnN1YnM7XFxuICAgICAgICAgICAgc3Vicy51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgIGFyclJlbW92ZV8xLmFyclJlbW92ZShidWZmZXJSZWNvcmRzLCByZWNvcmQpO1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChidWZmZXIpO1xcbiAgICAgICAgICAgIHJlc3RhcnRPbkVtaXQgJiYgc3RhcnRCdWZmZXIoKTtcXG4gICAgICAgIH07XFxuICAgICAgICB2YXIgc3RhcnRCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKGJ1ZmZlclJlY29yZHMpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHN1YnMgPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKCk7XFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuYWRkKHN1YnMpO1xcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gW107XFxuICAgICAgICAgICAgICAgIHZhciByZWNvcmRfMSA9IHtcXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogYnVmZmVyLFxcbiAgICAgICAgICAgICAgICAgICAgc3Viczogc3VicyxcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgYnVmZmVyUmVjb3Jkcy5wdXNoKHJlY29yZF8xKTtcXG4gICAgICAgICAgICAgICAgZXhlY3V0ZVNjaGVkdWxlXzEuZXhlY3V0ZVNjaGVkdWxlKHN1YnMsIHNjaGVkdWxlciwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZW1pdChyZWNvcmRfMSk7IH0sIGJ1ZmZlclRpbWVTcGFuKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgICAgaWYgKGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgIT09IG51bGwgJiYgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCA+PSAwKSB7XFxuICAgICAgICAgICAgZXhlY3V0ZVNjaGVkdWxlXzEuZXhlY3V0ZVNjaGVkdWxlKHN1YnNjcmliZXIsIHNjaGVkdWxlciwgc3RhcnRCdWZmZXIsIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwsIHRydWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgcmVzdGFydE9uRW1pdCA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgICBzdGFydEJ1ZmZlcigpO1xcbiAgICAgICAgdmFyIGJ1ZmZlclRpbWVTdWJzY3JpYmVyID0gT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xcbiAgICAgICAgICAgIHZhciByZWNvcmRzQ29weSA9IGJ1ZmZlclJlY29yZHMuc2xpY2UoKTtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByZWNvcmRzQ29weV8xID0gX192YWx1ZXMocmVjb3Jkc0NvcHkpLCByZWNvcmRzQ29weV8xXzEgPSByZWNvcmRzQ29weV8xLm5leHQoKTsgIXJlY29yZHNDb3B5XzFfMS5kb25lOyByZWNvcmRzQ29weV8xXzEgPSByZWNvcmRzQ29weV8xLm5leHQoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHJlY29yZHNDb3B5XzFfMS52YWx1ZTtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSByZWNvcmQuYnVmZmVyO1xcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnB1c2godmFsdWUpO1xcbiAgICAgICAgICAgICAgICAgICAgbWF4QnVmZmVyU2l6ZSA8PSBidWZmZXIubGVuZ3RoICYmIGVtaXQocmVjb3JkKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxcbiAgICAgICAgICAgIGZpbmFsbHkge1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZHNDb3B5XzFfMSAmJiAhcmVjb3Jkc0NvcHlfMV8xLmRvbmUgJiYgKF9hID0gcmVjb3Jkc0NvcHlfMS5yZXR1cm4pKSBfYS5jYWxsKHJlY29yZHNDb3B5XzEpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlclJlY29yZHMgPT09IG51bGwgfHwgYnVmZmVyUmVjb3JkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnVmZmVyUmVjb3Jkcy5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGJ1ZmZlclJlY29yZHMuc2hpZnQoKS5idWZmZXIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBidWZmZXJUaW1lU3Vic2NyaWJlciA9PT0gbnVsbCB8fCBidWZmZXJUaW1lU3Vic2NyaWJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnVmZmVyVGltZVN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgfSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoYnVmZmVyUmVjb3JkcyA9IG51bGwpOyB9KTtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoYnVmZmVyVGltZVN1YnNjcmliZXIpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5idWZmZXJUaW1lID0gYnVmZmVyVGltZTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXJUaW1lLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJUaW1lLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyVG9nZ2xlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJUb2dnbGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XFxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcXFwibnVtYmVyXFxcIikgcmV0dXJuIHtcXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXFxcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXFxcIiA6IFxcXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXFxcIik7XFxufTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5idWZmZXJUb2dnbGUgPSB2b2lkIDA7XFxudmFyIFN1YnNjcmlwdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vU3Vic2NyaXB0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YnNjcmlwdGlvbi5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxudmFyIG5vb3BfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbm9vcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL25vb3AuanNcXFwiKTtcXG52YXIgYXJyUmVtb3ZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyclJlbW92ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyclJlbW92ZS5qc1xcXCIpO1xcbmZ1bmN0aW9uIGJ1ZmZlclRvZ2dsZShvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSB7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgYnVmZmVycyA9IFtdO1xcbiAgICAgICAgaW5uZXJGcm9tXzEuaW5uZXJGcm9tKG9wZW5pbmdzKS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uIChvcGVuVmFsdWUpIHtcXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gW107XFxuICAgICAgICAgICAgYnVmZmVycy5wdXNoKGJ1ZmZlcik7XFxuICAgICAgICAgICAgdmFyIGNsb3NpbmdTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKCk7XFxuICAgICAgICAgICAgdmFyIGVtaXRCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGFyclJlbW92ZV8xLmFyclJlbW92ZShidWZmZXJzLCBidWZmZXIpO1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoYnVmZmVyKTtcXG4gICAgICAgICAgICAgICAgY2xvc2luZ1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgY2xvc2luZ1N1YnNjcmlwdGlvbi5hZGQoaW5uZXJGcm9tXzEuaW5uZXJGcm9tKGNsb3NpbmdTZWxlY3RvcihvcGVuVmFsdWUpKS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGVtaXRCdWZmZXIsIG5vb3BfMS5ub29wKSkpO1xcbiAgICAgICAgfSwgbm9vcF8xLm5vb3ApKTtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGJ1ZmZlcnNfMSA9IF9fdmFsdWVzKGJ1ZmZlcnMpLCBidWZmZXJzXzFfMSA9IGJ1ZmZlcnNfMS5uZXh0KCk7ICFidWZmZXJzXzFfMS5kb25lOyBidWZmZXJzXzFfMSA9IGJ1ZmZlcnNfMS5uZXh0KCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzXzFfMS52YWx1ZTtcXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxcbiAgICAgICAgICAgIGZpbmFsbHkge1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcnNfMV8xICYmICFidWZmZXJzXzFfMS5kb25lICYmIChfYSA9IGJ1ZmZlcnNfMS5yZXR1cm4pKSBfYS5jYWxsKGJ1ZmZlcnNfMSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB3aGlsZSAoYnVmZmVycy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChidWZmZXJzLnNoaWZ0KCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9KSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLmJ1ZmZlclRvZ2dsZSA9IGJ1ZmZlclRvZ2dsZTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXJUb2dnbGUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2J1ZmZlclRvZ2dsZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2J1ZmZlcldoZW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJXaGVuLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5idWZmZXJXaGVuID0gdm9pZCAwO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIG5vb3BfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbm9vcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL25vb3AuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG5mdW5jdGlvbiBidWZmZXJXaGVuKGNsb3NpbmdTZWxlY3Rvcikge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG51bGw7XFxuICAgICAgICB2YXIgY2xvc2luZ1N1YnNjcmliZXIgPSBudWxsO1xcbiAgICAgICAgdmFyIG9wZW5CdWZmZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgY2xvc2luZ1N1YnNjcmliZXIgPT09IG51bGwgfHwgY2xvc2luZ1N1YnNjcmliZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3NpbmdTdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgdmFyIGIgPSBidWZmZXI7XFxuICAgICAgICAgICAgYnVmZmVyID0gW107XFxuICAgICAgICAgICAgYiAmJiBzdWJzY3JpYmVyLm5leHQoYik7XFxuICAgICAgICAgICAgaW5uZXJGcm9tXzEuaW5uZXJGcm9tKGNsb3NpbmdTZWxlY3RvcigpKS5zdWJzY3JpYmUoKGNsb3NpbmdTdWJzY3JpYmVyID0gT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIG9wZW5CdWZmZXIsIG5vb3BfMS5ub29wKSkpO1xcbiAgICAgICAgfTtcXG4gICAgICAgIG9wZW5CdWZmZXIoKTtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gYnVmZmVyID09PSBudWxsIHx8IGJ1ZmZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnVmZmVyLnB1c2godmFsdWUpOyB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgYnVmZmVyICYmIHN1YnNjcmliZXIubmV4dChidWZmZXIpO1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgIH0sIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKGJ1ZmZlciA9IGNsb3NpbmdTdWJzY3JpYmVyID0gbnVsbCk7IH0pKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuYnVmZmVyV2hlbiA9IGJ1ZmZlcldoZW47XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyV2hlbi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyV2hlbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NhdGNoRXJyb3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jYXRjaEVycm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5jYXRjaEVycm9yID0gdm9pZCAwO1xcbnZhciBpbm5lckZyb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvaW5uZXJGcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvaW5uZXJGcm9tLmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxuZnVuY3Rpb24gY2F0Y2hFcnJvcihzZWxlY3Rvcikge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGlubmVyU3ViID0gbnVsbDtcXG4gICAgICAgIHZhciBzeW5jVW5zdWIgPSBmYWxzZTtcXG4gICAgICAgIHZhciBoYW5kbGVkUmVzdWx0O1xcbiAgICAgICAgaW5uZXJTdWIgPSBzb3VyY2Uuc3Vic2NyaWJlKE9wZXJhdG9yU3Vic2NyaWJlcl8xLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKGVycikge1xcbiAgICAgICAgICAgIGhhbmRsZWRSZXN1bHQgPSBpbm5lckZyb21fMS5pbm5lckZyb20oc2VsZWN0b3IoZXJyLCBjYXRjaEVycm9yKHNlbGVjdG9yKShzb3VyY2UpKSk7XFxuICAgICAgICAgICAgaWYgKGlubmVyU3ViKSB7XFxuICAgICAgICAgICAgICAgIGlubmVyU3ViLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgICAgIGlubmVyU3ViID0gbnVsbDtcXG4gICAgICAgICAgICAgICAgaGFuZGxlZFJlc3VsdC5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBzeW5jVW5zdWIgPSB0cnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pKTtcXG4gICAgICAgIGlmIChzeW5jVW5zdWIpIHtcXG4gICAgICAgICAgICBpbm5lclN1Yi51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgIGlubmVyU3ViID0gbnVsbDtcXG4gICAgICAgICAgICBoYW5kbGVkUmVzdWx0LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcXG4gICAgICAgIH1cXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuY2F0Y2hFcnJvciA9IGNhdGNoRXJyb3I7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2F0Y2hFcnJvci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY2F0Y2hFcnJvci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbWJpbmVBbGwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb21iaW5lQWxsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5jb21iaW5lQWxsID0gdm9pZCAwO1xcbnZhciBjb21iaW5lTGF0ZXN0QWxsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbWJpbmVMYXRlc3RBbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbWJpbmVMYXRlc3RBbGwuanNcXFwiKTtcXG5leHBvcnRzLmNvbWJpbmVBbGwgPSBjb21iaW5lTGF0ZXN0QWxsXzEuY29tYmluZUxhdGVzdEFsbDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21iaW5lQWxsLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb21iaW5lQWxsLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29tYmluZUxhdGVzdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbWJpbmVMYXRlc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xcbiAgICBpZiAoIW0pIHJldHVybiBvO1xcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xcbiAgICB9XFxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxcbiAgICBmaW5hbGx5IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXFxcInJldHVyblxcXCJdKSkgbS5jYWxsKGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFyO1xcbn07XFxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcXG4gICAgcmV0dXJuIHRvO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuY29tYmluZUxhdGVzdCA9IHZvaWQgMDtcXG52YXIgY29tYmluZUxhdGVzdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvY29tYmluZUxhdGVzdC5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIGFyZ3NPckFyZ0FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyZ3NPckFyZ0FycmF5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJnc09yQXJnQXJyYXkuanNcXFwiKTtcXG52YXIgbWFwT25lT3JNYW55QXJnc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9tYXBPbmVPck1hbnlBcmdzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbWFwT25lT3JNYW55QXJncy5qc1xcXCIpO1xcbnZhciBwaXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL3BpcGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9waXBlLmpzXFxcIik7XFxudmFyIGFyZ3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvYXJncyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyZ3MuanNcXFwiKTtcXG5mdW5jdGlvbiBjb21iaW5lTGF0ZXN0KCkge1xcbiAgICB2YXIgYXJncyA9IFtdO1xcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHZhciByZXN1bHRTZWxlY3RvciA9IGFyZ3NfMS5wb3BSZXN1bHRTZWxlY3RvcihhcmdzKTtcXG4gICAgcmV0dXJuIHJlc3VsdFNlbGVjdG9yXFxuICAgICAgICA/IHBpcGVfMS5waXBlKGNvbWJpbmVMYXRlc3QuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncykpKSwgbWFwT25lT3JNYW55QXJnc18xLm1hcE9uZU9yTWFueUFyZ3MocmVzdWx0U2VsZWN0b3IpKVxcbiAgICAgICAgOiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICAgICAgY29tYmluZUxhdGVzdF8xLmNvbWJpbmVMYXRlc3RJbml0KF9fc3ByZWFkQXJyYXkoW3NvdXJjZV0sIF9fcmVhZChhcmdzT3JBcmdBcnJheV8xLmFyZ3NPckFyZ0FycmF5KGFyZ3MpKSkpKHN1YnNjcmliZXIpO1xcbiAgICAgICAgfSk7XFxufVxcbmV4cG9ydHMuY29tYmluZUxhdGVzdCA9IGNvbWJpbmVMYXRlc3Q7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tYmluZUxhdGVzdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29tYmluZUxhdGVzdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbWJpbmVMYXRlc3RBbGwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb21iaW5lTGF0ZXN0QWxsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5jb21iaW5lTGF0ZXN0QWxsID0gdm9pZCAwO1xcbnZhciBjb21iaW5lTGF0ZXN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vYnNlcnZhYmxlL2NvbWJpbmVMYXRlc3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0LmpzXFxcIik7XFxudmFyIGpvaW5BbGxJbnRlcm5hbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vam9pbkFsbEludGVybmFscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvam9pbkFsbEludGVybmFscy5qc1xcXCIpO1xcbmZ1bmN0aW9uIGNvbWJpbmVMYXRlc3RBbGwocHJvamVjdCkge1xcbiAgICByZXR1cm4gam9pbkFsbEludGVybmFsc18xLmpvaW5BbGxJbnRlcm5hbHMoY29tYmluZUxhdGVzdF8xLmNvbWJpbmVMYXRlc3QsIHByb2plY3QpO1xcbn1cXG5leHBvcnRzLmNvbWJpbmVMYXRlc3RBbGwgPSBjb21iaW5lTGF0ZXN0QWxsO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbWJpbmVMYXRlc3RBbGwuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbWJpbmVMYXRlc3RBbGwuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb21iaW5lTGF0ZXN0V2l0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb21iaW5lTGF0ZXN0V2l0aC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xcbiAgICBpZiAoIW0pIHJldHVybiBvO1xcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xcbiAgICB9XFxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxcbiAgICBmaW5hbGx5IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXFxcInJldHVyblxcXCJdKSkgbS5jYWxsKGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFyO1xcbn07XFxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcXG4gICAgcmV0dXJuIHRvO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuY29tYmluZUxhdGVzdFdpdGggPSB2b2lkIDA7XFxudmFyIGNvbWJpbmVMYXRlc3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29tYmluZUxhdGVzdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29tYmluZUxhdGVzdC5qc1xcXCIpO1xcbmZ1bmN0aW9uIGNvbWJpbmVMYXRlc3RXaXRoKCkge1xcbiAgICB2YXIgb3RoZXJTb3VyY2VzID0gW107XFxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICBvdGhlclNvdXJjZXNbX2ldID0gYXJndW1lbnRzW19pXTtcXG4gICAgfVxcbiAgICByZXR1cm4gY29tYmluZUxhdGVzdF8xLmNvbWJpbmVMYXRlc3QuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQob3RoZXJTb3VyY2VzKSkpO1xcbn1cXG5leHBvcnRzLmNvbWJpbmVMYXRlc3RXaXRoID0gY29tYmluZUxhdGVzdFdpdGg7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tYmluZUxhdGVzdFdpdGguanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbWJpbmVMYXRlc3RXaXRoLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb25jYXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XFxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XFxuICAgIGlmICghbSkgcmV0dXJuIG87XFxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xcbiAgICB0cnkge1xcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XFxuICAgIH1cXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XFxuICAgIGZpbmFsbHkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcXFwicmV0dXJuXFxcIl0pKSBtLmNhbGwoaSk7XFxuICAgICAgICB9XFxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cXG4gICAgfVxcbiAgICByZXR1cm4gYXI7XFxufTtcXG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XFxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xcbiAgICByZXR1cm4gdG87XFxufTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5jb25jYXQgPSB2b2lkIDA7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgY29uY2F0QWxsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbmNhdEFsbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0QWxsLmpzXFxcIik7XFxudmFyIGFyZ3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvYXJncyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyZ3MuanNcXFwiKTtcXG52YXIgZnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9mcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZnJvbS5qc1xcXCIpO1xcbmZ1bmN0aW9uIGNvbmNhdCgpIHtcXG4gICAgdmFyIGFyZ3MgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcXG4gICAgfVxcbiAgICB2YXIgc2NoZWR1bGVyID0gYXJnc18xLnBvcFNjaGVkdWxlcihhcmdzKTtcXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIGNvbmNhdEFsbF8xLmNvbmNhdEFsbCgpKGZyb21fMS5mcm9tKF9fc3ByZWFkQXJyYXkoW3NvdXJjZV0sIF9fcmVhZChhcmdzKSksIHNjaGVkdWxlcikpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0QWxsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb25jYXRBbGwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuY29uY2F0QWxsID0gdm9pZCAwO1xcbnZhciBtZXJnZUFsbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZXJnZUFsbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VBbGwuanNcXFwiKTtcXG5mdW5jdGlvbiBjb25jYXRBbGwoKSB7XFxuICAgIHJldHVybiBtZXJnZUFsbF8xLm1lcmdlQWxsKDEpO1xcbn1cXG5leHBvcnRzLmNvbmNhdEFsbCA9IGNvbmNhdEFsbDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXRBbGwuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbmNhdEFsbC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbmNhdE1hcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0TWFwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmNvbmNhdE1hcCA9IHZvaWQgMDtcXG52YXIgbWVyZ2VNYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWVyZ2VNYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlTWFwLmpzXFxcIik7XFxudmFyIGlzRnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG5mdW5jdGlvbiBjb25jYXRNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcXG4gICAgcmV0dXJuIGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKHJlc3VsdFNlbGVjdG9yKSA/IG1lcmdlTWFwXzEubWVyZ2VNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIDEpIDogbWVyZ2VNYXBfMS5tZXJnZU1hcChwcm9qZWN0LCAxKTtcXG59XFxuZXhwb3J0cy5jb25jYXRNYXAgPSBjb25jYXRNYXA7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0TWFwLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb25jYXRNYXAuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb25jYXRNYXBUby5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb25jYXRNYXBUby5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmNvbmNhdE1hcFRvID0gdm9pZCAwO1xcbnZhciBjb25jYXRNYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uY2F0TWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb25jYXRNYXAuanNcXFwiKTtcXG52YXIgaXNGdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc0Z1bmN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNGdW5jdGlvbi5qc1xcXCIpO1xcbmZ1bmN0aW9uIGNvbmNhdE1hcFRvKGlubmVyT2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IpIHtcXG4gICAgcmV0dXJuIGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKHJlc3VsdFNlbGVjdG9yKSA/IGNvbmNhdE1hcF8xLmNvbmNhdE1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBpbm5lck9ic2VydmFibGU7IH0sIHJlc3VsdFNlbGVjdG9yKSA6IGNvbmNhdE1hcF8xLmNvbmNhdE1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBpbm5lck9ic2VydmFibGU7IH0pO1xcbn1cXG5leHBvcnRzLmNvbmNhdE1hcFRvID0gY29uY2F0TWFwVG87XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0TWFwVG8uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbmNhdE1hcFRvLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0V2l0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbmNhdFdpdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xcbiAgICBpZiAoIW0pIHJldHVybiBvO1xcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xcbiAgICB9XFxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxcbiAgICBmaW5hbGx5IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXFxcInJldHVyblxcXCJdKSkgbS5jYWxsKGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFyO1xcbn07XFxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcXG4gICAgcmV0dXJuIHRvO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuY29uY2F0V2l0aCA9IHZvaWQgMDtcXG52YXIgY29uY2F0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbmNhdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0LmpzXFxcIik7XFxuZnVuY3Rpb24gY29uY2F0V2l0aCgpIHtcXG4gICAgdmFyIG90aGVyU291cmNlcyA9IFtdO1xcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgb3RoZXJTb3VyY2VzW19pXSA9IGFyZ3VtZW50c1tfaV07XFxuICAgIH1cXG4gICAgcmV0dXJuIGNvbmNhdF8xLmNvbmNhdC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChvdGhlclNvdXJjZXMpKSk7XFxufVxcbmV4cG9ydHMuY29uY2F0V2l0aCA9IGNvbmNhdFdpdGg7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0V2l0aC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0V2l0aC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2Nvbm5lY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb25uZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5jb25uZWN0ID0gdm9pZCAwO1xcbnZhciBTdWJqZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9TdWJqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YmplY3QuanNcXFwiKTtcXG52YXIgaW5uZXJGcm9tXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vYnNlcnZhYmxlL2lubmVyRnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2lubmVyRnJvbS5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIGZyb21TdWJzY3JpYmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvZnJvbVN1YnNjcmliYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb21TdWJzY3JpYmFibGUuanNcXFwiKTtcXG52YXIgREVGQVVMVF9DT05GSUcgPSB7XFxuICAgIGNvbm5lY3RvcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7IH0sXFxufTtcXG5mdW5jdGlvbiBjb25uZWN0KHNlbGVjdG9yLCBjb25maWcpIHtcXG4gICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IERFRkFVTFRfQ09ORklHOyB9XFxuICAgIHZhciBjb25uZWN0b3IgPSBjb25maWcuY29ubmVjdG9yO1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIHN1YmplY3QgPSBjb25uZWN0b3IoKTtcXG4gICAgICAgIGlubmVyRnJvbV8xLmlubmVyRnJvbShzZWxlY3Rvcihmcm9tU3Vic2NyaWJhYmxlXzEuZnJvbVN1YnNjcmliYWJsZShzdWJqZWN0KSkpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcXG4gICAgICAgIHN1YnNjcmliZXIuYWRkKHNvdXJjZS5zdWJzY3JpYmUoc3ViamVjdCkpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5jb25uZWN0ID0gY29ubmVjdDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb25uZWN0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY291bnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY291bnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5jb3VudCA9IHZvaWQgMDtcXG52YXIgcmVkdWNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JlZHVjZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmVkdWNlLmpzXFxcIik7XFxuZnVuY3Rpb24gY291bnQocHJlZGljYXRlKSB7XFxuICAgIHJldHVybiByZWR1Y2VfMS5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsLCB2YWx1ZSwgaSkgeyByZXR1cm4gKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKHZhbHVlLCBpKSA/IHRvdGFsICsgMSA6IHRvdGFsKTsgfSwgMCk7XFxufVxcbmV4cG9ydHMuY291bnQgPSBjb3VudDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3VudC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY291bnQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kZWJvdW5jZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kZWJvdW5jZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmRlYm91bmNlID0gdm9pZCAwO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIG5vb3BfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbm9vcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL25vb3AuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG5mdW5jdGlvbiBkZWJvdW5jZShkdXJhdGlvblNlbGVjdG9yKSB7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgaGFzVmFsdWUgPSBmYWxzZTtcXG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBudWxsO1xcbiAgICAgICAgdmFyIGR1cmF0aW9uU3Vic2NyaWJlciA9IG51bGw7XFxuICAgICAgICB2YXIgZW1pdCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBkdXJhdGlvblN1YnNjcmliZXIgPT09IG51bGwgfHwgZHVyYXRpb25TdWJzY3JpYmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkdXJhdGlvblN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICBkdXJhdGlvblN1YnNjcmliZXIgPSBudWxsO1xcbiAgICAgICAgICAgIGlmIChoYXNWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBsYXN0VmFsdWU7XFxuICAgICAgICAgICAgICAgIGxhc3RWYWx1ZSA9IG51bGw7XFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfTtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIGR1cmF0aW9uU3Vic2NyaWJlciA9PT0gbnVsbCB8fCBkdXJhdGlvblN1YnNjcmliZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGR1cmF0aW9uU3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcXG4gICAgICAgICAgICBsYXN0VmFsdWUgPSB2YWx1ZTtcXG4gICAgICAgICAgICBkdXJhdGlvblN1YnNjcmliZXIgPSBPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZW1pdCwgbm9vcF8xLm5vb3ApO1xcbiAgICAgICAgICAgIGlubmVyRnJvbV8xLmlubmVyRnJvbShkdXJhdGlvblNlbGVjdG9yKHZhbHVlKSkuc3Vic2NyaWJlKGR1cmF0aW9uU3Vic2NyaWJlcik7XFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgZW1pdCgpO1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgIH0sIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGxhc3RWYWx1ZSA9IGR1cmF0aW9uU3Vic2NyaWJlciA9IG51bGw7XFxuICAgICAgICB9KSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLmRlYm91bmNlID0gZGVib3VuY2U7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2UuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlYm91bmNlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVib3VuY2VUaW1lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kZWJvdW5jZVRpbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZGVib3VuY2VUaW1lID0gdm9pZCAwO1xcbnZhciBhc3luY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc2NoZWR1bGVyL2FzeW5jICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9hc3luYy5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIGRlYm91bmNlVGltZShkdWVUaW1lLCBzY2hlZHVsZXIpIHtcXG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmNTY2hlZHVsZXI7IH1cXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBhY3RpdmVUYXNrID0gbnVsbDtcXG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBudWxsO1xcbiAgICAgICAgdmFyIGxhc3RUaW1lID0gbnVsbDtcXG4gICAgICAgIHZhciBlbWl0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmIChhY3RpdmVUYXNrKSB7XFxuICAgICAgICAgICAgICAgIGFjdGl2ZVRhc2sudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICAgICAgYWN0aXZlVGFzayA9IG51bGw7XFxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxhc3RWYWx1ZTtcXG4gICAgICAgICAgICAgICAgbGFzdFZhbHVlID0gbnVsbDtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgICAgZnVuY3Rpb24gZW1pdFdoZW5JZGxlKCkge1xcbiAgICAgICAgICAgIHZhciB0YXJnZXRUaW1lID0gbGFzdFRpbWUgKyBkdWVUaW1lO1xcbiAgICAgICAgICAgIHZhciBub3cgPSBzY2hlZHVsZXIubm93KCk7XFxuICAgICAgICAgICAgaWYgKG5vdyA8IHRhcmdldFRpbWUpIHtcXG4gICAgICAgICAgICAgICAgYWN0aXZlVGFzayA9IHRoaXMuc2NoZWR1bGUodW5kZWZpbmVkLCB0YXJnZXRUaW1lIC0gbm93KTtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQoYWN0aXZlVGFzayk7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZW1pdCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgbGFzdFZhbHVlID0gdmFsdWU7XFxuICAgICAgICAgICAgbGFzdFRpbWUgPSBzY2hlZHVsZXIubm93KCk7XFxuICAgICAgICAgICAgaWYgKCFhY3RpdmVUYXNrKSB7XFxuICAgICAgICAgICAgICAgIGFjdGl2ZVRhc2sgPSBzY2hlZHVsZXIuc2NoZWR1bGUoZW1pdFdoZW5JZGxlLCBkdWVUaW1lKTtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQoYWN0aXZlVGFzayk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGVtaXQoKTtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9LCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBsYXN0VmFsdWUgPSBhY3RpdmVUYXNrID0gbnVsbDtcXG4gICAgICAgIH0pKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuZGVib3VuY2VUaW1lID0gZGVib3VuY2VUaW1lO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlVGltZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVib3VuY2VUaW1lLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVmYXVsdElmRW1wdHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVmYXVsdElmRW1wdHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5kZWZhdWx0SWZFbXB0eSA9IHZvaWQgMDtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG5mdW5jdGlvbiBkZWZhdWx0SWZFbXB0eShkZWZhdWx0VmFsdWUpIHtcXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBoYXNWYWx1ZSA9IGZhbHNlO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKCFoYXNWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoZGVmYXVsdFZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgfSkpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5kZWZhdWx0SWZFbXB0eSA9IGRlZmF1bHRJZkVtcHR5O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRJZkVtcHR5LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kZWZhdWx0SWZFbXB0eS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlbGF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlbGF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZGVsYXkgPSB2b2lkIDA7XFxudmFyIGFzeW5jXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9zY2hlZHVsZXIvYXN5bmMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL2FzeW5jLmpzXFxcIik7XFxudmFyIGRlbGF5V2hlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kZWxheVdoZW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlbGF5V2hlbi5qc1xcXCIpO1xcbnZhciB0aW1lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS90aW1lciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3RpbWVyLmpzXFxcIik7XFxuZnVuY3Rpb24gZGVsYXkoZHVlLCBzY2hlZHVsZXIpIHtcXG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmNTY2hlZHVsZXI7IH1cXG4gICAgdmFyIGR1cmF0aW9uID0gdGltZXJfMS50aW1lcihkdWUsIHNjaGVkdWxlcik7XFxuICAgIHJldHVybiBkZWxheVdoZW5fMS5kZWxheVdoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZHVyYXRpb247IH0pO1xcbn1cXG5leHBvcnRzLmRlbGF5ID0gZGVsYXk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsYXkuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlbGF5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVsYXlXaGVuLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kZWxheVdoZW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZGVsYXlXaGVuID0gdm9pZCAwO1xcbnZhciBjb25jYXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvY29uY2F0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvY29uY2F0LmpzXFxcIik7XFxudmFyIHRha2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGFrZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZS5qc1xcXCIpO1xcbnZhciBpZ25vcmVFbGVtZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pZ25vcmVFbGVtZW50cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvaWdub3JlRWxlbWVudHMuanNcXFwiKTtcXG52YXIgbWFwVG9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWFwVG8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21hcFRvLmpzXFxcIik7XFxudmFyIG1lcmdlTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21lcmdlTWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZU1hcC5qc1xcXCIpO1xcbnZhciBpbm5lckZyb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvaW5uZXJGcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvaW5uZXJGcm9tLmpzXFxcIik7XFxuZnVuY3Rpb24gZGVsYXlXaGVuKGRlbGF5RHVyYXRpb25TZWxlY3Rvciwgc3Vic2NyaXB0aW9uRGVsYXkpIHtcXG4gICAgaWYgKHN1YnNjcmlwdGlvbkRlbGF5KSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xcbiAgICAgICAgICAgIHJldHVybiBjb25jYXRfMS5jb25jYXQoc3Vic2NyaXB0aW9uRGVsYXkucGlwZSh0YWtlXzEudGFrZSgxKSwgaWdub3JlRWxlbWVudHNfMS5pZ25vcmVFbGVtZW50cygpKSwgc291cmNlLnBpcGUoZGVsYXlXaGVuKGRlbGF5RHVyYXRpb25TZWxlY3RvcikpKTtcXG4gICAgICAgIH07XFxuICAgIH1cXG4gICAgcmV0dXJuIG1lcmdlTWFwXzEubWVyZ2VNYXAoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkgeyByZXR1cm4gaW5uZXJGcm9tXzEuaW5uZXJGcm9tKGRlbGF5RHVyYXRpb25TZWxlY3Rvcih2YWx1ZSwgaW5kZXgpKS5waXBlKHRha2VfMS50YWtlKDEpLCBtYXBUb18xLm1hcFRvKHZhbHVlKSk7IH0pO1xcbn1cXG5leHBvcnRzLmRlbGF5V2hlbiA9IGRlbGF5V2hlbjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWxheVdoZW4uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlbGF5V2hlbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlbWF0ZXJpYWxpemUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kZW1hdGVyaWFsaXplLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5kZW1hdGVyaWFsaXplID0gdm9pZCAwO1xcbnZhciBOb3RpZmljYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL05vdGlmaWNhdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9Ob3RpZmljYXRpb24uanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG5mdW5jdGlvbiBkZW1hdGVyaWFsaXplKCkge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKG5vdGlmaWNhdGlvbikgeyByZXR1cm4gTm90aWZpY2F0aW9uXzEub2JzZXJ2ZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb24sIHN1YnNjcmliZXIpOyB9KSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLmRlbWF0ZXJpYWxpemUgPSBkZW1hdGVyaWFsaXplO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbWF0ZXJpYWxpemUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlbWF0ZXJpYWxpemUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kaXN0aW5jdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kaXN0aW5jdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmRpc3RpbmN0ID0gdm9pZCAwO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbnZhciBub29wXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL25vb3AgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9ub29wLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG5mdW5jdGlvbiBkaXN0aW5jdChrZXlTZWxlY3RvciwgZmx1c2hlcykge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGRpc3RpbmN0S2V5cyA9IG5ldyBTZXQoKTtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlTZWxlY3RvciA/IGtleVNlbGVjdG9yKHZhbHVlKSA6IHZhbHVlO1xcbiAgICAgICAgICAgIGlmICghZGlzdGluY3RLZXlzLmhhcyhrZXkpKSB7XFxuICAgICAgICAgICAgICAgIGRpc3RpbmN0S2V5cy5hZGQoa2V5KTtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KSk7XFxuICAgICAgICBmbHVzaGVzICYmIGlubmVyRnJvbV8xLmlubmVyRnJvbShmbHVzaGVzKS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3RpbmN0S2V5cy5jbGVhcigpOyB9LCBub29wXzEubm9vcCkpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5kaXN0aW5jdCA9IGRpc3RpbmN0O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3RpbmN0LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kaXN0aW5jdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2Rpc3RpbmN0VW50aWxDaGFuZ2VkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2Rpc3RpbmN0VW50aWxDaGFuZ2VkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZGlzdGluY3RVbnRpbENoYW5nZWQgPSB2b2lkIDA7XFxudmFyIGlkZW50aXR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lkZW50aXR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaWRlbnRpdHkuanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG5mdW5jdGlvbiBkaXN0aW5jdFVudGlsQ2hhbmdlZChjb21wYXJhdG9yLCBrZXlTZWxlY3Rvcikge1xcbiAgICBpZiAoa2V5U2VsZWN0b3IgPT09IHZvaWQgMCkgeyBrZXlTZWxlY3RvciA9IGlkZW50aXR5XzEuaWRlbnRpdHk7IH1cXG4gICAgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IgIT09IG51bGwgJiYgY29tcGFyYXRvciAhPT0gdm9pZCAwID8gY29tcGFyYXRvciA6IGRlZmF1bHRDb21wYXJlO1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIHByZXZpb3VzS2V5O1xcbiAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZTtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5U2VsZWN0b3IodmFsdWUpO1xcbiAgICAgICAgICAgIGlmIChmaXJzdCB8fCAhY29tcGFyYXRvcihwcmV2aW91c0tleSwgY3VycmVudEtleSkpIHtcXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgcHJldmlvdXNLZXkgPSBjdXJyZW50S2V5O1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuZGlzdGluY3RVbnRpbENoYW5nZWQgPSBkaXN0aW5jdFVudGlsQ2hhbmdlZDtcXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XFxuICAgIHJldHVybiBhID09PSBiO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXN0aW5jdFVudGlsQ2hhbmdlZC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZGlzdGluY3RVbnRpbENoYW5nZWQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkID0gdm9pZCAwO1xcbnZhciBkaXN0aW5jdFVudGlsQ2hhbmdlZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kaXN0aW5jdFVudGlsQ2hhbmdlZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZGlzdGluY3RVbnRpbENoYW5nZWQuanNcXFwiKTtcXG5mdW5jdGlvbiBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZChrZXksIGNvbXBhcmUpIHtcXG4gICAgcmV0dXJuIGRpc3RpbmN0VW50aWxDaGFuZ2VkXzEuZGlzdGluY3RVbnRpbENoYW5nZWQoZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIGNvbXBhcmUgPyBjb21wYXJlKHhba2V5XSwgeVtrZXldKSA6IHhba2V5XSA9PT0geVtrZXldOyB9KTtcXG59XFxuZXhwb3J0cy5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCA9IGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2VsZW1lbnRBdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZWxlbWVudEF0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmVsZW1lbnRBdCA9IHZvaWQgMDtcXG52YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvci5qc1xcXCIpO1xcbnZhciBmaWx0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmlsdGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9maWx0ZXIuanNcXFwiKTtcXG52YXIgdGhyb3dJZkVtcHR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Rocm93SWZFbXB0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGhyb3dJZkVtcHR5LmpzXFxcIik7XFxudmFyIGRlZmF1bHRJZkVtcHR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RlZmF1bHRJZkVtcHR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kZWZhdWx0SWZFbXB0eS5qc1xcXCIpO1xcbnZhciB0YWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Rha2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2UuanNcXFwiKTtcXG5mdW5jdGlvbiBlbGVtZW50QXQoaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xcbiAgICBpZiAoaW5kZXggPCAwKSB7XFxuICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JfMS5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpO1xcbiAgICB9XFxuICAgIHZhciBoYXNEZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID49IDI7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XFxuICAgICAgICByZXR1cm4gc291cmNlLnBpcGUoZmlsdGVyXzEuZmlsdGVyKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiBpID09PSBpbmRleDsgfSksIHRha2VfMS50YWtlKDEpLCBoYXNEZWZhdWx0VmFsdWUgPyBkZWZhdWx0SWZFbXB0eV8xLmRlZmF1bHRJZkVtcHR5KGRlZmF1bHRWYWx1ZSkgOiB0aHJvd0lmRW1wdHlfMS50aHJvd0lmRW1wdHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKTsgfSkpO1xcbiAgICB9O1xcbn1cXG5leHBvcnRzLmVsZW1lbnRBdCA9IGVsZW1lbnRBdDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVtZW50QXQuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2VsZW1lbnRBdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2VuZFdpdGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9lbmRXaXRoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcXG4gICAgaWYgKCFtKSByZXR1cm4gbztcXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XFxuICAgIHRyeSB7XFxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcXG4gICAgfVxcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cXG4gICAgZmluYWxseSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1xcXCJyZXR1cm5cXFwiXSkpIG0uY2FsbChpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxcbiAgICB9XFxuICAgIHJldHVybiBhcjtcXG59O1xcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXFxuICAgICAgICB0b1tqXSA9IGZyb21baV07XFxuICAgIHJldHVybiB0bztcXG59O1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmVuZFdpdGggPSB2b2lkIDA7XFxudmFyIGNvbmNhdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9jb25jYXQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9jb25jYXQuanNcXFwiKTtcXG52YXIgb2ZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9vZi5qc1xcXCIpO1xcbmZ1bmN0aW9uIGVuZFdpdGgoKSB7XFxuICAgIHZhciB2YWx1ZXMgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIHZhbHVlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBjb25jYXRfMS5jb25jYXQoc291cmNlLCBvZl8xLm9mLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHZhbHVlcykpKSk7IH07XFxufVxcbmV4cG9ydHMuZW5kV2l0aCA9IGVuZFdpdGg7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5kV2l0aC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZW5kV2l0aC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2V2ZXJ5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2V2ZXJ5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZXZlcnkgPSB2b2lkIDA7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxuZnVuY3Rpb24gZXZlcnkocHJlZGljYXRlLCB0aGlzQXJnKSB7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgaW5kZXggPSAwO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgaWYgKCFwcmVkaWNhdGUuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgrKywgc291cmNlKSkge1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh0cnVlKTtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9KSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLmV2ZXJ5ID0gZXZlcnk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlcnkuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2V2ZXJ5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZXhoYXVzdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2V4aGF1c3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmV4aGF1c3QgPSB2b2lkIDA7XFxudmFyIGV4aGF1c3RBbGxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXhoYXVzdEFsbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZXhoYXVzdEFsbC5qc1xcXCIpO1xcbmV4cG9ydHMuZXhoYXVzdCA9IGV4aGF1c3RBbGxfMS5leGhhdXN0QWxsO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4aGF1c3QuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2V4aGF1c3QuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9leGhhdXN0QWxsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZXhoYXVzdEFsbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZXhoYXVzdEFsbCA9IHZvaWQgMDtcXG52YXIgZXhoYXVzdE1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9leGhhdXN0TWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9leGhhdXN0TWFwLmpzXFxcIik7XFxudmFyIGlkZW50aXR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lkZW50aXR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaWRlbnRpdHkuanNcXFwiKTtcXG5mdW5jdGlvbiBleGhhdXN0QWxsKCkge1xcbiAgICByZXR1cm4gZXhoYXVzdE1hcF8xLmV4aGF1c3RNYXAoaWRlbnRpdHlfMS5pZGVudGl0eSk7XFxufVxcbmV4cG9ydHMuZXhoYXVzdEFsbCA9IGV4aGF1c3RBbGw7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhoYXVzdEFsbC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZXhoYXVzdEFsbC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2V4aGF1c3RNYXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9leGhhdXN0TWFwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5leGhhdXN0TWFwID0gdm9pZCAwO1xcbnZhciBtYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tYXAuanNcXFwiKTtcXG52YXIgaW5uZXJGcm9tXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vYnNlcnZhYmxlL2lubmVyRnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2lubmVyRnJvbS5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIGV4aGF1c3RNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcXG4gICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UucGlwZShleGhhdXN0TWFwKGZ1bmN0aW9uIChhLCBpKSB7IHJldHVybiBpbm5lckZyb21fMS5pbm5lckZyb20ocHJvamVjdChhLCBpKSkucGlwZShtYXBfMS5tYXAoZnVuY3Rpb24gKGIsIGlpKSB7IHJldHVybiByZXN1bHRTZWxlY3RvcihhLCBiLCBpLCBpaSk7IH0pKTsgfSkpO1xcbiAgICAgICAgfTtcXG4gICAgfVxcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcXG4gICAgICAgIHZhciBpbm5lclN1YiA9IG51bGw7XFxuICAgICAgICB2YXIgaXNDb21wbGV0ZSA9IGZhbHNlO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKG91dGVyVmFsdWUpIHtcXG4gICAgICAgICAgICBpZiAoIWlubmVyU3ViKSB7XFxuICAgICAgICAgICAgICAgIGlubmVyU3ViID0gT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJTdWIgPSBudWxsO1xcbiAgICAgICAgICAgICAgICAgICAgaXNDb21wbGV0ZSAmJiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBpbm5lckZyb21fMS5pbm5lckZyb20ocHJvamVjdChvdXRlclZhbHVlLCBpbmRleCsrKSkuc3Vic2NyaWJlKGlubmVyU3ViKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaXNDb21wbGV0ZSA9IHRydWU7XFxuICAgICAgICAgICAgIWlubmVyU3ViICYmIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgIH0pKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuZXhoYXVzdE1hcCA9IGV4aGF1c3RNYXA7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhoYXVzdE1hcC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZXhoYXVzdE1hcC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2V4cGFuZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZXhwYW5kLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmV4cGFuZCA9IHZvaWQgMDtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBtZXJnZUludGVybmFsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZXJnZUludGVybmFscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VJbnRlcm5hbHMuanNcXFwiKTtcXG5mdW5jdGlvbiBleHBhbmQocHJvamVjdCwgY29uY3VycmVudCwgc2NoZWR1bGVyKSB7XFxuICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IEluZmluaXR5OyB9XFxuICAgIGNvbmN1cnJlbnQgPSAoY29uY3VycmVudCB8fCAwKSA8IDEgPyBJbmZpbml0eSA6IGNvbmN1cnJlbnQ7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICByZXR1cm4gbWVyZ2VJbnRlcm5hbHNfMS5tZXJnZUludGVybmFscyhzb3VyY2UsIHN1YnNjcmliZXIsIHByb2plY3QsIGNvbmN1cnJlbnQsIHVuZGVmaW5lZCwgdHJ1ZSwgc2NoZWR1bGVyKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuZXhwYW5kID0gZXhwYW5kO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cGFuZC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZXhwYW5kLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZmlsdGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9maWx0ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZmlsdGVyID0gdm9pZCAwO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBpbmRleCA9IDA7XFxuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKE9wZXJhdG9yU3Vic2NyaWJlcl8xLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCsrKSAmJiBzdWJzY3JpYmVyLm5leHQodmFsdWUpOyB9KSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbHRlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbmFsaXplLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbmFsaXplLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZmluYWxpemUgPSB2b2lkIDA7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG5mdW5jdGlvbiBmaW5hbGl6ZShjYWxsYmFjaykge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmluYWxseSB7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQoY2FsbGJhY2spO1xcbiAgICAgICAgfVxcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5maW5hbGl6ZSA9IGZpbmFsaXplO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmFsaXplLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9maW5hbGl6ZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbmQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9maW5kLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5jcmVhdGVGaW5kID0gZXhwb3J0cy5maW5kID0gdm9pZCAwO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIGZpbmQocHJlZGljYXRlLCB0aGlzQXJnKSB7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShjcmVhdGVGaW5kKHByZWRpY2F0ZSwgdGhpc0FyZywgJ3ZhbHVlJykpO1xcbn1cXG5leHBvcnRzLmZpbmQgPSBmaW5kO1xcbmZ1bmN0aW9uIGNyZWF0ZUZpbmQocHJlZGljYXRlLCB0aGlzQXJnLCBlbWl0KSB7XFxuICAgIHZhciBmaW5kSW5kZXggPSBlbWl0ID09PSAnaW5kZXgnO1xcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIHZhciBpID0gaW5kZXgrKztcXG4gICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywgdmFsdWUsIGksIHNvdXJjZSkpIHtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGZpbmRJbmRleCA/IGkgOiB2YWx1ZSk7XFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGZpbmRJbmRleCA/IC0xIDogdW5kZWZpbmVkKTtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9KSk7XFxuICAgIH07XFxufVxcbmV4cG9ydHMuY3JlYXRlRmluZCA9IGNyZWF0ZUZpbmQ7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZmluZC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbmRJbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZmluZEluZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmZpbmRJbmRleCA9IHZvaWQgMDtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBmaW5kXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZpbmQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbmQuanNcXFwiKTtcXG5mdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnKSB7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmaW5kXzEuY3JlYXRlRmluZChwcmVkaWNhdGUsIHRoaXNBcmcsICdpbmRleCcpKTtcXG59XFxuZXhwb3J0cy5maW5kSW5kZXggPSBmaW5kSW5kZXg7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZEluZGV4LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9maW5kSW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9maXJzdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9maXJzdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmZpcnN0ID0gdm9pZCAwO1xcbnZhciBFbXB0eUVycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL0VtcHR5RXJyb3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9FbXB0eUVycm9yLmpzXFxcIik7XFxudmFyIGZpbHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9maWx0ZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbHRlci5qc1xcXCIpO1xcbnZhciB0YWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Rha2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2UuanNcXFwiKTtcXG52YXIgZGVmYXVsdElmRW1wdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGVmYXVsdElmRW1wdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlZmF1bHRJZkVtcHR5LmpzXFxcIik7XFxudmFyIHRocm93SWZFbXB0eV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90aHJvd0lmRW1wdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm93SWZFbXB0eS5qc1xcXCIpO1xcbnZhciBpZGVudGl0eV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pZGVudGl0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lkZW50aXR5LmpzXFxcIik7XFxuZnVuY3Rpb24gZmlyc3QocHJlZGljYXRlLCBkZWZhdWx0VmFsdWUpIHtcXG4gICAgdmFyIGhhc0RlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMjtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcXG4gICAgICAgIHJldHVybiBzb3VyY2UucGlwZShwcmVkaWNhdGUgPyBmaWx0ZXJfMS5maWx0ZXIoZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIHByZWRpY2F0ZSh2LCBpLCBzb3VyY2UpOyB9KSA6IGlkZW50aXR5XzEuaWRlbnRpdHksIHRha2VfMS50YWtlKDEpLCBoYXNEZWZhdWx0VmFsdWUgPyBkZWZhdWx0SWZFbXB0eV8xLmRlZmF1bHRJZkVtcHR5KGRlZmF1bHRWYWx1ZSkgOiB0aHJvd0lmRW1wdHlfMS50aHJvd0lmRW1wdHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEVtcHR5RXJyb3JfMS5FbXB0eUVycm9yKCk7IH0pKTtcXG4gICAgfTtcXG59XFxuZXhwb3J0cy5maXJzdCA9IGZpcnN0O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpcnN0LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9maXJzdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZsYXRNYXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9mbGF0TWFwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5mbGF0TWFwID0gdm9pZCAwO1xcbnZhciBtZXJnZU1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZXJnZU1hcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VNYXAuanNcXFwiKTtcXG5leHBvcnRzLmZsYXRNYXAgPSBtZXJnZU1hcF8xLm1lcmdlTWFwO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZsYXRNYXAuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZsYXRNYXAuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9ncm91cEJ5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZ3JvdXBCeS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZ3JvdXBCeSA9IHZvaWQgMDtcXG52YXIgT2JzZXJ2YWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vT2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG52YXIgU3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vU3ViamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJqZWN0LmpzXFxcIik7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxuZnVuY3Rpb24gZ3JvdXBCeShrZXlTZWxlY3RvciwgZWxlbWVudE9yT3B0aW9ucywgZHVyYXRpb24sIGNvbm5lY3Rvcikge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGVsZW1lbnQ7XFxuICAgICAgICBpZiAoIWVsZW1lbnRPck9wdGlvbnMgfHwgdHlwZW9mIGVsZW1lbnRPck9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudE9yT3B0aW9ucztcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIChkdXJhdGlvbiA9IGVsZW1lbnRPck9wdGlvbnMuZHVyYXRpb24sIGVsZW1lbnQgPSBlbGVtZW50T3JPcHRpb25zLmVsZW1lbnQsIGNvbm5lY3RvciA9IGVsZW1lbnRPck9wdGlvbnMuY29ubmVjdG9yKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBncm91cHMgPSBuZXcgTWFwKCk7XFxuICAgICAgICB2YXIgbm90aWZ5ID0gZnVuY3Rpb24gKGNiKSB7XFxuICAgICAgICAgICAgZ3JvdXBzLmZvckVhY2goY2IpO1xcbiAgICAgICAgICAgIGNiKHN1YnNjcmliZXIpO1xcbiAgICAgICAgfTtcXG4gICAgICAgIHZhciBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIG5vdGlmeShmdW5jdGlvbiAoY29uc3VtZXIpIHsgcmV0dXJuIGNvbnN1bWVyLmVycm9yKGVycik7IH0pOyB9O1xcbiAgICAgICAgdmFyIGFjdGl2ZUdyb3VwcyA9IDA7XFxuICAgICAgICB2YXIgdGVhcmRvd25BdHRlbXB0ZWQgPSBmYWxzZTtcXG4gICAgICAgIHZhciBncm91cEJ5U291cmNlU3Vic2NyaWJlciA9IG5ldyBPcGVyYXRvclN1YnNjcmliZXJfMS5PcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgdmFyIGtleV8xID0ga2V5U2VsZWN0b3IodmFsdWUpO1xcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBfMSA9IGdyb3Vwcy5nZXQoa2V5XzEpO1xcbiAgICAgICAgICAgICAgICBpZiAoIWdyb3VwXzEpIHtcXG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwcy5zZXQoa2V5XzEsIChncm91cF8xID0gY29ubmVjdG9yID8gY29ubmVjdG9yKCkgOiBuZXcgU3ViamVjdF8xLlN1YmplY3QoKSkpO1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwZWQgPSBjcmVhdGVHcm91cGVkT2JzZXJ2YWJsZShrZXlfMSwgZ3JvdXBfMSk7XFxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoZ3JvdXBlZCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb25TdWJzY3JpYmVyXzEgPSBPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoZ3JvdXBfMSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cF8xLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uU3Vic2NyaWJlcl8xID09PSBudWxsIHx8IGR1cmF0aW9uU3Vic2NyaWJlcl8xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkdXJhdGlvblN1YnNjcmliZXJfMS51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7IHJldHVybiBncm91cHMuZGVsZXRlKGtleV8xKTsgfSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBCeVNvdXJjZVN1YnNjcmliZXIuYWRkKGlubmVyRnJvbV8xLmlubmVyRnJvbShkdXJhdGlvbihncm91cGVkKSkuc3Vic2NyaWJlKGR1cmF0aW9uU3Vic2NyaWJlcl8xKSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZ3JvdXBfMS5uZXh0KGVsZW1lbnQgPyBlbGVtZW50KHZhbHVlKSA6IHZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5vdGlmeShmdW5jdGlvbiAoY29uc3VtZXIpIHsgcmV0dXJuIGNvbnN1bWVyLmNvbXBsZXRlKCk7IH0pOyB9LCBoYW5kbGVFcnJvciwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3JvdXBzLmNsZWFyKCk7IH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0ZWFyZG93bkF0dGVtcHRlZCA9IHRydWU7XFxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZUdyb3VwcyA9PT0gMDtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShncm91cEJ5U291cmNlU3Vic2NyaWJlcik7XFxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVHcm91cGVkT2JzZXJ2YWJsZShrZXksIGdyb3VwU3ViamVjdCkge1xcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUoZnVuY3Rpb24gKGdyb3VwU3Vic2NyaWJlcikge1xcbiAgICAgICAgICAgICAgICBhY3RpdmVHcm91cHMrKztcXG4gICAgICAgICAgICAgICAgdmFyIGlubmVyU3ViID0gZ3JvdXBTdWJqZWN0LnN1YnNjcmliZShncm91cFN1YnNjcmliZXIpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJTdWIudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICAgICAgICAgIC0tYWN0aXZlR3JvdXBzID09PSAwICYmIHRlYXJkb3duQXR0ZW1wdGVkICYmIGdyb3VwQnlTb3VyY2VTdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgcmVzdWx0LmtleSA9IGtleTtcXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgICAgfVxcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5ncm91cEJ5ID0gZ3JvdXBCeTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm91cEJ5LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9ncm91cEJ5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvaWdub3JlRWxlbWVudHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvaWdub3JlRWxlbWVudHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5pZ25vcmVFbGVtZW50cyA9IHZvaWQgMDtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG52YXIgbm9vcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9ub29wICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbm9vcC5qc1xcXCIpO1xcbmZ1bmN0aW9uIGlnbm9yZUVsZW1lbnRzKCkge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgbm9vcF8xLm5vb3ApKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuaWdub3JlRWxlbWVudHMgPSBpZ25vcmVFbGVtZW50cztcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZ25vcmVFbGVtZW50cy5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvaWdub3JlRWxlbWVudHMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9pc0VtcHR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvaXNFbXB0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuaXNFbXB0eSA9IHZvaWQgMDtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG5mdW5jdGlvbiBpc0VtcHR5KCkge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChmYWxzZSk7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh0cnVlKTtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9KSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzRW1wdHkuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2lzRW1wdHkuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9qb2luQWxsSW50ZXJuYWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvam9pbkFsbEludGVybmFscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuam9pbkFsbEludGVybmFscyA9IHZvaWQgMDtcXG52YXIgaWRlbnRpdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaWRlbnRpdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pZGVudGl0eS5qc1xcXCIpO1xcbnZhciBtYXBPbmVPck1hbnlBcmdzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL21hcE9uZU9yTWFueUFyZ3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9tYXBPbmVPck1hbnlBcmdzLmpzXFxcIik7XFxudmFyIHBpcGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvcGlwZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL3BpcGUuanNcXFwiKTtcXG52YXIgbWVyZ2VNYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWVyZ2VNYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlTWFwLmpzXFxcIik7XFxudmFyIHRvQXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG9BcnJheSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdG9BcnJheS5qc1xcXCIpO1xcbmZ1bmN0aW9uIGpvaW5BbGxJbnRlcm5hbHMoam9pbkZuLCBwcm9qZWN0KSB7XFxuICAgIHJldHVybiBwaXBlXzEucGlwZSh0b0FycmF5XzEudG9BcnJheSgpLCBtZXJnZU1hcF8xLm1lcmdlTWFwKGZ1bmN0aW9uIChzb3VyY2VzKSB7IHJldHVybiBqb2luRm4oc291cmNlcyk7IH0pLCBwcm9qZWN0ID8gbWFwT25lT3JNYW55QXJnc18xLm1hcE9uZU9yTWFueUFyZ3MocHJvamVjdCkgOiBpZGVudGl0eV8xLmlkZW50aXR5KTtcXG59XFxuZXhwb3J0cy5qb2luQWxsSW50ZXJuYWxzID0gam9pbkFsbEludGVybmFscztcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1qb2luQWxsSW50ZXJuYWxzLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9qb2luQWxsSW50ZXJuYWxzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbGFzdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2xhc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmxhc3QgPSB2b2lkIDA7XFxudmFyIEVtcHR5RXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvRW1wdHlFcnJvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL0VtcHR5RXJyb3IuanNcXFwiKTtcXG52YXIgZmlsdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZpbHRlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZmlsdGVyLmpzXFxcIik7XFxudmFyIHRha2VMYXN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Rha2VMYXN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90YWtlTGFzdC5qc1xcXCIpO1xcbnZhciB0aHJvd0lmRW1wdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGhyb3dJZkVtcHR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90aHJvd0lmRW1wdHkuanNcXFwiKTtcXG52YXIgZGVmYXVsdElmRW1wdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGVmYXVsdElmRW1wdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlZmF1bHRJZkVtcHR5LmpzXFxcIik7XFxudmFyIGlkZW50aXR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lkZW50aXR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaWRlbnRpdHkuanNcXFwiKTtcXG5mdW5jdGlvbiBsYXN0KHByZWRpY2F0ZSwgZGVmYXVsdFZhbHVlKSB7XFxuICAgIHZhciBoYXNEZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID49IDI7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XFxuICAgICAgICByZXR1cm4gc291cmNlLnBpcGUocHJlZGljYXRlID8gZmlsdGVyXzEuZmlsdGVyKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiBwcmVkaWNhdGUodiwgaSwgc291cmNlKTsgfSkgOiBpZGVudGl0eV8xLmlkZW50aXR5LCB0YWtlTGFzdF8xLnRha2VMYXN0KDEpLCBoYXNEZWZhdWx0VmFsdWUgPyBkZWZhdWx0SWZFbXB0eV8xLmRlZmF1bHRJZkVtcHR5KGRlZmF1bHRWYWx1ZSkgOiB0aHJvd0lmRW1wdHlfMS50aHJvd0lmRW1wdHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEVtcHR5RXJyb3JfMS5FbXB0eUVycm9yKCk7IH0pKTtcXG4gICAgfTtcXG59XFxuZXhwb3J0cy5sYXN0ID0gbGFzdDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXN0LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9sYXN0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tYXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMubWFwID0gdm9pZCAwO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIG1hcChwcm9qZWN0LCB0aGlzQXJnKSB7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgaW5kZXggPSAwO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHByb2plY3QuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgrKykpO1xcbiAgICAgICAgfSkpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5tYXAgPSBtYXA7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tYXAuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tYXBUby5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tYXBUby5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLm1hcFRvID0gdm9pZCAwO1xcbnZhciBtYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tYXAuanNcXFwiKTtcXG5mdW5jdGlvbiBtYXBUbyh2YWx1ZSkge1xcbiAgICByZXR1cm4gbWFwXzEubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcXG59XFxuZXhwb3J0cy5tYXBUbyA9IG1hcFRvO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcFRvLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tYXBUby5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21hdGVyaWFsaXplLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21hdGVyaWFsaXplLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMubWF0ZXJpYWxpemUgPSB2b2lkIDA7XFxudmFyIE5vdGlmaWNhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vTm90aWZpY2F0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL05vdGlmaWNhdGlvbi5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIG1hdGVyaWFsaXplKCkge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0KHZhbHVlKSk7XFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSgpKTtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVFcnJvcihlcnIpKTtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9KSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLm1hdGVyaWFsaXplID0gbWF0ZXJpYWxpemU7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0ZXJpYWxpemUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21hdGVyaWFsaXplLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWF4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tYXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMubWF4ID0gdm9pZCAwO1xcbnZhciByZWR1Y2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVkdWNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yZWR1Y2UuanNcXFwiKTtcXG52YXIgaXNGdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc0Z1bmN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNGdW5jdGlvbi5qc1xcXCIpO1xcbmZ1bmN0aW9uIG1heChjb21wYXJlcikge1xcbiAgICByZXR1cm4gcmVkdWNlXzEucmVkdWNlKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKGNvbXBhcmVyKSA/IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiAoY29tcGFyZXIoeCwgeSkgPiAwID8geCA6IHkpOyB9IDogZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuICh4ID4geSA/IHggOiB5KTsgfSk7XFxufVxcbmV4cG9ydHMubWF4ID0gbWF4O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWF4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcXG4gICAgaWYgKCFtKSByZXR1cm4gbztcXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XFxuICAgIHRyeSB7XFxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcXG4gICAgfVxcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cXG4gICAgZmluYWxseSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1xcXCJyZXR1cm5cXFwiXSkpIG0uY2FsbChpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxcbiAgICB9XFxuICAgIHJldHVybiBhcjtcXG59O1xcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXFxuICAgICAgICB0b1tqXSA9IGZyb21baV07XFxuICAgIHJldHVybiB0bztcXG59O1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLm1lcmdlID0gdm9pZCAwO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIGFyZ3NPckFyZ0FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyZ3NPckFyZ0FycmF5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJnc09yQXJnQXJyYXkuanNcXFwiKTtcXG52YXIgbWVyZ2VBbGxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWVyZ2VBbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlQWxsLmpzXFxcIik7XFxudmFyIGFyZ3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvYXJncyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyZ3MuanNcXFwiKTtcXG52YXIgZnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9mcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvZnJvbS5qc1xcXCIpO1xcbmZ1bmN0aW9uIG1lcmdlKCkge1xcbiAgICB2YXIgYXJncyA9IFtdO1xcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHZhciBzY2hlZHVsZXIgPSBhcmdzXzEucG9wU2NoZWR1bGVyKGFyZ3MpO1xcbiAgICB2YXIgY29uY3VycmVudCA9IGFyZ3NfMS5wb3BOdW1iZXIoYXJncywgSW5maW5pdHkpO1xcbiAgICBhcmdzID0gYXJnc09yQXJnQXJyYXlfMS5hcmdzT3JBcmdBcnJheShhcmdzKTtcXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIG1lcmdlQWxsXzEubWVyZ2VBbGwoY29uY3VycmVudCkoZnJvbV8xLmZyb20oX19zcHJlYWRBcnJheShbc291cmNlXSwgX19yZWFkKGFyZ3MpKSwgc2NoZWR1bGVyKSkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlQWxsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlQWxsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMubWVyZ2VBbGwgPSB2b2lkIDA7XFxudmFyIG1lcmdlTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21lcmdlTWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZU1hcC5qc1xcXCIpO1xcbnZhciBpZGVudGl0eV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pZGVudGl0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lkZW50aXR5LmpzXFxcIik7XFxuZnVuY3Rpb24gbWVyZ2VBbGwoY29uY3VycmVudCkge1xcbiAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBJbmZpbml0eTsgfVxcbiAgICByZXR1cm4gbWVyZ2VNYXBfMS5tZXJnZU1hcChpZGVudGl0eV8xLmlkZW50aXR5LCBjb25jdXJyZW50KTtcXG59XFxuZXhwb3J0cy5tZXJnZUFsbCA9IG1lcmdlQWxsO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlQWxsLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZUFsbC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlSW50ZXJuYWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlSW50ZXJuYWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMubWVyZ2VJbnRlcm5hbHMgPSB2b2lkIDA7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG52YXIgZXhlY3V0ZVNjaGVkdWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2V4ZWN1dGVTY2hlZHVsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2V4ZWN1dGVTY2hlZHVsZS5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG5mdW5jdGlvbiBtZXJnZUludGVybmFscyhzb3VyY2UsIHN1YnNjcmliZXIsIHByb2plY3QsIGNvbmN1cnJlbnQsIG9uQmVmb3JlTmV4dCwgZXhwYW5kLCBpbm5lclN1YlNjaGVkdWxlciwgYWRkaXRpb25hbEZpbmFsaXplcikge1xcbiAgICB2YXIgYnVmZmVyID0gW107XFxuICAgIHZhciBhY3RpdmUgPSAwO1xcbiAgICB2YXIgaW5kZXggPSAwO1xcbiAgICB2YXIgaXNDb21wbGV0ZSA9IGZhbHNlO1xcbiAgICB2YXIgY2hlY2tDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChpc0NvbXBsZXRlICYmICFidWZmZXIubGVuZ3RoICYmICFhY3RpdmUpIHtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIHZhciBvdXRlck5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIChhY3RpdmUgPCBjb25jdXJyZW50ID8gZG9Jbm5lclN1Yih2YWx1ZSkgOiBidWZmZXIucHVzaCh2YWx1ZSkpOyB9O1xcbiAgICB2YXIgZG9Jbm5lclN1YiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgZXhwYW5kICYmIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XFxuICAgICAgICBhY3RpdmUrKztcXG4gICAgICAgIHZhciBpbm5lckNvbXBsZXRlID0gZmFsc2U7XFxuICAgICAgICBpbm5lckZyb21fMS5pbm5lckZyb20ocHJvamVjdCh2YWx1ZSwgaW5kZXgrKykpLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKGlubmVyVmFsdWUpIHtcXG4gICAgICAgICAgICBvbkJlZm9yZU5leHQgPT09IG51bGwgfHwgb25CZWZvcmVOZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkJlZm9yZU5leHQoaW5uZXJWYWx1ZSk7XFxuICAgICAgICAgICAgaWYgKGV4cGFuZCkge1xcbiAgICAgICAgICAgICAgICBvdXRlck5leHQoaW5uZXJWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoaW5uZXJWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlubmVyQ29tcGxldGUgPSB0cnVlO1xcbiAgICAgICAgfSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKGlubmVyQ29tcGxldGUpIHtcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZS0tO1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlcmVkVmFsdWUgPSBidWZmZXIuc2hpZnQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXJTdWJTY2hlZHVsZXIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZVNjaGVkdWxlXzEuZXhlY3V0ZVNjaGVkdWxlKHN1YnNjcmliZXIsIGlubmVyU3ViU2NoZWR1bGVyLCBmdW5jdGlvbiAoKSB7IHJldHVybiBkb0lubmVyU3ViKGJ1ZmZlcmVkVmFsdWUpOyB9KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvSW5uZXJTdWIoYnVmZmVyZWRWYWx1ZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChidWZmZXIubGVuZ3RoICYmIGFjdGl2ZSA8IGNvbmN1cnJlbnQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBjaGVja0NvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSkpO1xcbiAgICB9O1xcbiAgICBzb3VyY2Uuc3Vic2NyaWJlKE9wZXJhdG9yU3Vic2NyaWJlcl8xLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBvdXRlck5leHQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlzQ29tcGxldGUgPSB0cnVlO1xcbiAgICAgICAgY2hlY2tDb21wbGV0ZSgpO1xcbiAgICB9KSk7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBhZGRpdGlvbmFsRmluYWxpemVyID09PSBudWxsIHx8IGFkZGl0aW9uYWxGaW5hbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxGaW5hbGl6ZXIoKTtcXG4gICAgfTtcXG59XFxuZXhwb3J0cy5tZXJnZUludGVybmFscyA9IG1lcmdlSW50ZXJuYWxzO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlSW50ZXJuYWxzLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZUludGVybmFscy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlTWFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlTWFwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMubWVyZ2VNYXAgPSB2b2lkIDA7XFxudmFyIG1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21hcC5qc1xcXCIpO1xcbnZhciBpbm5lckZyb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvaW5uZXJGcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvaW5uZXJGcm9tLmpzXFxcIik7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgbWVyZ2VJbnRlcm5hbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWVyZ2VJbnRlcm5hbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlSW50ZXJuYWxzLmpzXFxcIik7XFxudmFyIGlzRnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG5mdW5jdGlvbiBtZXJnZU1hcChwcm9qZWN0LCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkge1xcbiAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBJbmZpbml0eTsgfVxcbiAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24ocmVzdWx0U2VsZWN0b3IpKSB7XFxuICAgICAgICByZXR1cm4gbWVyZ2VNYXAoZnVuY3Rpb24gKGEsIGkpIHsgcmV0dXJuIG1hcF8xLm1hcChmdW5jdGlvbiAoYiwgaWkpIHsgcmV0dXJuIHJlc3VsdFNlbGVjdG9yKGEsIGIsIGksIGlpKTsgfSkoaW5uZXJGcm9tXzEuaW5uZXJGcm9tKHByb2plY3QoYSwgaSkpKTsgfSwgY29uY3VycmVudCk7XFxuICAgIH1cXG4gICAgZWxzZSBpZiAodHlwZW9mIHJlc3VsdFNlbGVjdG9yID09PSAnbnVtYmVyJykge1xcbiAgICAgICAgY29uY3VycmVudCA9IHJlc3VsdFNlbGVjdG9yO1xcbiAgICB9XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7IHJldHVybiBtZXJnZUludGVybmFsc18xLm1lcmdlSW50ZXJuYWxzKHNvdXJjZSwgc3Vic2NyaWJlciwgcHJvamVjdCwgY29uY3VycmVudCk7IH0pO1xcbn1cXG5leHBvcnRzLm1lcmdlTWFwID0gbWVyZ2VNYXA7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VNYXAuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlTWFwLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VNYXBUby5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlTWFwVG8uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLm1lcmdlTWFwVG8gPSB2b2lkIDA7XFxudmFyIG1lcmdlTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21lcmdlTWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZU1hcC5qc1xcXCIpO1xcbnZhciBpc0Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzRnVuY3Rpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxuZnVuY3Rpb24gbWVyZ2VNYXBUbyhpbm5lck9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XFxuICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IEluZmluaXR5OyB9XFxuICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihyZXN1bHRTZWxlY3RvcikpIHtcXG4gICAgICAgIHJldHVybiBtZXJnZU1hcF8xLm1lcmdlTWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlubmVyT2JzZXJ2YWJsZTsgfSwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpO1xcbiAgICB9XFxuICAgIGlmICh0eXBlb2YgcmVzdWx0U2VsZWN0b3IgPT09ICdudW1iZXInKSB7XFxuICAgICAgICBjb25jdXJyZW50ID0gcmVzdWx0U2VsZWN0b3I7XFxuICAgIH1cXG4gICAgcmV0dXJuIG1lcmdlTWFwXzEubWVyZ2VNYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5uZXJPYnNlcnZhYmxlOyB9LCBjb25jdXJyZW50KTtcXG59XFxuZXhwb3J0cy5tZXJnZU1hcFRvID0gbWVyZ2VNYXBUbztcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZU1hcFRvLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZU1hcFRvLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VTY2FuLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZVNjYW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMubWVyZ2VTY2FuID0gdm9pZCAwO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIG1lcmdlSW50ZXJuYWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21lcmdlSW50ZXJuYWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZUludGVybmFscy5qc1xcXCIpO1xcbmZ1bmN0aW9uIG1lcmdlU2NhbihhY2N1bXVsYXRvciwgc2VlZCwgY29uY3VycmVudCkge1xcbiAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBJbmZpbml0eTsgfVxcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIHN0YXRlID0gc2VlZDtcXG4gICAgICAgIHJldHVybiBtZXJnZUludGVybmFsc18xLm1lcmdlSW50ZXJuYWxzKHNvdXJjZSwgc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkgeyByZXR1cm4gYWNjdW11bGF0b3Ioc3RhdGUsIHZhbHVlLCBpbmRleCk7IH0sIGNvbmN1cnJlbnQsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIHN0YXRlID0gdmFsdWU7XFxuICAgICAgICB9LCBmYWxzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoc3RhdGUgPSBudWxsKTsgfSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLm1lcmdlU2NhbiA9IG1lcmdlU2NhbjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZVNjYW4uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlU2Nhbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlV2l0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VXaXRoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xcbiAgICBpZiAoIW0pIHJldHVybiBvO1xcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xcbiAgICB9XFxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxcbiAgICBmaW5hbGx5IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXFxcInJldHVyblxcXCJdKSkgbS5jYWxsKGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFyO1xcbn07XFxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcXG4gICAgcmV0dXJuIHRvO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMubWVyZ2VXaXRoID0gdm9pZCAwO1xcbnZhciBtZXJnZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZXJnZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2UuanNcXFwiKTtcXG5mdW5jdGlvbiBtZXJnZVdpdGgoKSB7XFxuICAgIHZhciBvdGhlclNvdXJjZXMgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIG90aGVyU291cmNlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHJldHVybiBtZXJnZV8xLm1lcmdlLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKG90aGVyU291cmNlcykpKTtcXG59XFxuZXhwb3J0cy5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VXaXRoLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZVdpdGguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9taW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21pbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5taW4gPSB2b2lkIDA7XFxudmFyIHJlZHVjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZWR1Y2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3JlZHVjZS5qc1xcXCIpO1xcbnZhciBpc0Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzRnVuY3Rpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxuZnVuY3Rpb24gbWluKGNvbXBhcmVyKSB7XFxuICAgIHJldHVybiByZWR1Y2VfMS5yZWR1Y2UoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oY29tcGFyZXIpID8gZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIChjb21wYXJlcih4LCB5KSA8IDAgPyB4IDogeSk7IH0gOiBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4gKHggPCB5ID8geCA6IHkpOyB9KTtcXG59XFxuZXhwb3J0cy5taW4gPSBtaW47XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWluLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9taW4uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tdWx0aWNhc3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL211bHRpY2FzdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5tdWx0aWNhc3QgPSB2b2lkIDA7XFxudmFyIENvbm5lY3RhYmxlT2JzZXJ2YWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9Db25uZWN0YWJsZU9ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9Db25uZWN0YWJsZU9ic2VydmFibGUuanNcXFwiKTtcXG52YXIgaXNGdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc0Z1bmN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNGdW5jdGlvbi5qc1xcXCIpO1xcbnZhciBjb25uZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Nvbm5lY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2Nvbm5lY3QuanNcXFwiKTtcXG5mdW5jdGlvbiBtdWx0aWNhc3Qoc3ViamVjdE9yU3ViamVjdEZhY3RvcnksIHNlbGVjdG9yKSB7XFxuICAgIHZhciBzdWJqZWN0RmFjdG9yeSA9IGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKHN1YmplY3RPclN1YmplY3RGYWN0b3J5KSA/IHN1YmplY3RPclN1YmplY3RGYWN0b3J5IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViamVjdE9yU3ViamVjdEZhY3Rvcnk7IH07XFxuICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihzZWxlY3RvcikpIHtcXG4gICAgICAgIHJldHVybiBjb25uZWN0XzEuY29ubmVjdChzZWxlY3Rvciwge1xcbiAgICAgICAgICAgIGNvbm5lY3Rvcjogc3ViamVjdEZhY3RvcnksXFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gbmV3IENvbm5lY3RhYmxlT2JzZXJ2YWJsZV8xLkNvbm5lY3RhYmxlT2JzZXJ2YWJsZShzb3VyY2UsIHN1YmplY3RGYWN0b3J5KTsgfTtcXG59XFxuZXhwb3J0cy5tdWx0aWNhc3QgPSBtdWx0aWNhc3Q7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGljYXN0LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tdWx0aWNhc3QuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9vYnNlcnZlT24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmVPbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5vYnNlcnZlT24gPSB2b2lkIDA7XFxudmFyIGV4ZWN1dGVTY2hlZHVsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9leGVjdXRlU2NoZWR1bGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9leGVjdXRlU2NoZWR1bGUuanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG5mdW5jdGlvbiBvYnNlcnZlT24oc2NoZWR1bGVyLCBkZWxheSkge1xcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZXhlY3V0ZVNjaGVkdWxlXzEuZXhlY3V0ZVNjaGVkdWxlKHN1YnNjcmliZXIsIHNjaGVkdWxlciwgZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaWJlci5uZXh0KHZhbHVlKTsgfSwgZGVsYXkpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBleGVjdXRlU2NoZWR1bGVfMS5leGVjdXRlU2NoZWR1bGUoc3Vic2NyaWJlciwgc2NoZWR1bGVyLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7IH0sIGRlbGF5KTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gZXhlY3V0ZVNjaGVkdWxlXzEuZXhlY3V0ZVNjaGVkdWxlKHN1YnNjcmliZXIsIHNjaGVkdWxlciwgZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaWJlci5lcnJvcihlcnIpOyB9LCBkZWxheSk7IH0pKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMub2JzZXJ2ZU9uID0gb2JzZXJ2ZU9uO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmVPbi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvb2JzZXJ2ZU9uLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvb25FcnJvclJlc3VtZU5leHRXaXRoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9vbkVycm9yUmVzdW1lTmV4dFdpdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XFxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XFxuICAgIGlmICghbSkgcmV0dXJuIG87XFxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xcbiAgICB0cnkge1xcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XFxuICAgIH1cXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XFxuICAgIGZpbmFsbHkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcXFwicmV0dXJuXFxcIl0pKSBtLmNhbGwoaSk7XFxuICAgICAgICB9XFxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cXG4gICAgfVxcbiAgICByZXR1cm4gYXI7XFxufTtcXG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XFxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xcbiAgICByZXR1cm4gdG87XFxufTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5vbkVycm9yUmVzdW1lTmV4dCA9IGV4cG9ydHMub25FcnJvclJlc3VtZU5leHRXaXRoID0gdm9pZCAwO1xcbnZhciBhcmdzT3JBcmdBcnJheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9hcmdzT3JBcmdBcnJheSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyZ3NPckFyZ0FycmF5LmpzXFxcIik7XFxudmFyIG9uRXJyb3JSZXN1bWVOZXh0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vYnNlcnZhYmxlL29uRXJyb3JSZXN1bWVOZXh0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvb25FcnJvclJlc3VtZU5leHQuanNcXFwiKTtcXG5mdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dFdpdGgoKSB7XFxuICAgIHZhciBzb3VyY2VzID0gW107XFxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICBzb3VyY2VzW19pXSA9IGFyZ3VtZW50c1tfaV07XFxuICAgIH1cXG4gICAgdmFyIG5leHRTb3VyY2VzID0gYXJnc09yQXJnQXJyYXlfMS5hcmdzT3JBcmdBcnJheShzb3VyY2VzKTtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIG9uRXJyb3JSZXN1bWVOZXh0XzEub25FcnJvclJlc3VtZU5leHQuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtzb3VyY2VdLCBfX3JlYWQobmV4dFNvdXJjZXMpKSk7IH07XFxufVxcbmV4cG9ydHMub25FcnJvclJlc3VtZU5leHRXaXRoID0gb25FcnJvclJlc3VtZU5leHRXaXRoO1xcbmV4cG9ydHMub25FcnJvclJlc3VtZU5leHQgPSBvbkVycm9yUmVzdW1lTmV4dFdpdGg7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25FcnJvclJlc3VtZU5leHRXaXRoLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9vbkVycm9yUmVzdW1lTmV4dFdpdGguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9wYWlyd2lzZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9wYWlyd2lzZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnBhaXJ3aXNlID0gdm9pZCAwO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIHBhaXJ3aXNlKCkge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIHByZXY7XFxuICAgICAgICB2YXIgaGFzUHJldiA9IGZhbHNlO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgdmFyIHAgPSBwcmV2O1xcbiAgICAgICAgICAgIHByZXYgPSB2YWx1ZTtcXG4gICAgICAgICAgICBoYXNQcmV2ICYmIHN1YnNjcmliZXIubmV4dChbcCwgdmFsdWVdKTtcXG4gICAgICAgICAgICBoYXNQcmV2ID0gdHJ1ZTtcXG4gICAgICAgIH0pKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMucGFpcndpc2UgPSBwYWlyd2lzZTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWlyd2lzZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcGFpcndpc2UuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9wYXJ0aXRpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3BhcnRpdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5wYXJ0aXRpb24gPSB2b2lkIDA7XFxudmFyIG5vdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9ub3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9ub3QuanNcXFwiKTtcXG52YXIgZmlsdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZpbHRlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZmlsdGVyLmpzXFxcIik7XFxuZnVuY3Rpb24gcGFydGl0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZykge1xcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xcbiAgICAgICAgcmV0dXJuIFtmaWx0ZXJfMS5maWx0ZXIocHJlZGljYXRlLCB0aGlzQXJnKShzb3VyY2UpLCBmaWx0ZXJfMS5maWx0ZXIobm90XzEubm90KHByZWRpY2F0ZSwgdGhpc0FyZykpKHNvdXJjZSldO1xcbiAgICB9O1xcbn1cXG5leHBvcnRzLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJ0aXRpb24uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3BhcnRpdGlvbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3BsdWNrLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3BsdWNrLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMucGx1Y2sgPSB2b2lkIDA7XFxudmFyIG1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21hcC5qc1xcXCIpO1xcbmZ1bmN0aW9uIHBsdWNrKCkge1xcbiAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgcHJvcGVydGllc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHZhciBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcXG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaXN0IG9mIHByb3BlcnRpZXMgY2Fubm90IGJlIGVtcHR5LicpO1xcbiAgICB9XFxuICAgIHJldHVybiBtYXBfMS5tYXAoZnVuY3Rpb24gKHgpIHtcXG4gICAgICAgIHZhciBjdXJyZW50UHJvcCA9IHg7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgdmFyIHAgPSBjdXJyZW50UHJvcCA9PT0gbnVsbCB8fCBjdXJyZW50UHJvcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFByb3BbcHJvcGVydGllc1tpXV07XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvcCA9IHA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBjdXJyZW50UHJvcDtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMucGx1Y2sgPSBwbHVjaztcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVjay5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcGx1Y2suanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9wdWJsaXNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcHVibGlzaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMucHVibGlzaCA9IHZvaWQgMDtcXG52YXIgU3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vU3ViamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJqZWN0LmpzXFxcIik7XFxudmFyIG11bHRpY2FzdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tdWx0aWNhc3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL211bHRpY2FzdC5qc1xcXCIpO1xcbnZhciBjb25uZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Nvbm5lY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2Nvbm5lY3QuanNcXFwiKTtcXG5mdW5jdGlvbiBwdWJsaXNoKHNlbGVjdG9yKSB7XFxuICAgIHJldHVybiBzZWxlY3RvciA/IGZ1bmN0aW9uIChzb3VyY2UpIHsgcmV0dXJuIGNvbm5lY3RfMS5jb25uZWN0KHNlbGVjdG9yKShzb3VyY2UpOyB9IDogZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gbXVsdGljYXN0XzEubXVsdGljYXN0KG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpKShzb3VyY2UpOyB9O1xcbn1cXG5leHBvcnRzLnB1Ymxpc2ggPSBwdWJsaXNoO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1Ymxpc2guanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3B1Ymxpc2guanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9wdWJsaXNoQmVoYXZpb3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3B1Ymxpc2hCZWhhdmlvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5wdWJsaXNoQmVoYXZpb3IgPSB2b2lkIDA7XFxudmFyIEJlaGF2aW9yU3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vQmVoYXZpb3JTdWJqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL0JlaGF2aW9yU3ViamVjdC5qc1xcXCIpO1xcbnZhciBDb25uZWN0YWJsZU9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlLmpzXFxcIik7XFxuZnVuY3Rpb24gcHVibGlzaEJlaGF2aW9yKGluaXRpYWxWYWx1ZSkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xcbiAgICAgICAgdmFyIHN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0XzEuQmVoYXZpb3JTdWJqZWN0KGluaXRpYWxWYWx1ZSk7XFxuICAgICAgICByZXR1cm4gbmV3IENvbm5lY3RhYmxlT2JzZXJ2YWJsZV8xLkNvbm5lY3RhYmxlT2JzZXJ2YWJsZShzb3VyY2UsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YmplY3Q7IH0pO1xcbiAgICB9O1xcbn1cXG5leHBvcnRzLnB1Ymxpc2hCZWhhdmlvciA9IHB1Ymxpc2hCZWhhdmlvcjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJsaXNoQmVoYXZpb3IuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3B1Ymxpc2hCZWhhdmlvci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3B1Ymxpc2hMYXN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3B1Ymxpc2hMYXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMucHVibGlzaExhc3QgPSB2b2lkIDA7XFxudmFyIEFzeW5jU3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vQXN5bmNTdWJqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL0FzeW5jU3ViamVjdC5qc1xcXCIpO1xcbnZhciBDb25uZWN0YWJsZU9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlLmpzXFxcIik7XFxuZnVuY3Rpb24gcHVibGlzaExhc3QoKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XFxuICAgICAgICB2YXIgc3ViamVjdCA9IG5ldyBBc3luY1N1YmplY3RfMS5Bc3luY1N1YmplY3QoKTtcXG4gICAgICAgIHJldHVybiBuZXcgQ29ubmVjdGFibGVPYnNlcnZhYmxlXzEuQ29ubmVjdGFibGVPYnNlcnZhYmxlKHNvdXJjZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViamVjdDsgfSk7XFxuICAgIH07XFxufVxcbmV4cG9ydHMucHVibGlzaExhc3QgPSBwdWJsaXNoTGFzdDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdWJsaXNoTGFzdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcHVibGlzaExhc3QuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9wdWJsaXNoUmVwbGF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcHVibGlzaFJlcGxheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMucHVibGlzaFJlcGxheSA9IHZvaWQgMDtcXG52YXIgUmVwbGF5U3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vUmVwbGF5U3ViamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9SZXBsYXlTdWJqZWN0LmpzXFxcIik7XFxudmFyIG11bHRpY2FzdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tdWx0aWNhc3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL211bHRpY2FzdC5qc1xcXCIpO1xcbnZhciBpc0Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzRnVuY3Rpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxuZnVuY3Rpb24gcHVibGlzaFJlcGxheShidWZmZXJTaXplLCB3aW5kb3dUaW1lLCBzZWxlY3Rvck9yU2NoZWR1bGVyLCB0aW1lc3RhbXBQcm92aWRlcikge1xcbiAgICBpZiAoc2VsZWN0b3JPclNjaGVkdWxlciAmJiAhaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oc2VsZWN0b3JPclNjaGVkdWxlcikpIHtcXG4gICAgICAgIHRpbWVzdGFtcFByb3ZpZGVyID0gc2VsZWN0b3JPclNjaGVkdWxlcjtcXG4gICAgfVxcbiAgICB2YXIgc2VsZWN0b3IgPSBpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihzZWxlY3Rvck9yU2NoZWR1bGVyKSA/IHNlbGVjdG9yT3JTY2hlZHVsZXIgOiB1bmRlZmluZWQ7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBtdWx0aWNhc3RfMS5tdWx0aWNhc3QobmV3IFJlcGxheVN1YmplY3RfMS5SZXBsYXlTdWJqZWN0KGJ1ZmZlclNpemUsIHdpbmRvd1RpbWUsIHRpbWVzdGFtcFByb3ZpZGVyKSwgc2VsZWN0b3IpKHNvdXJjZSk7IH07XFxufVxcbmV4cG9ydHMucHVibGlzaFJlcGxheSA9IHB1Ymxpc2hSZXBsYXk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaFJlcGxheS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcHVibGlzaFJlcGxheS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3JhY2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yYWNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcXG4gICAgaWYgKCFtKSByZXR1cm4gbztcXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XFxuICAgIHRyeSB7XFxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcXG4gICAgfVxcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cXG4gICAgZmluYWxseSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1xcXCJyZXR1cm5cXFwiXSkpIG0uY2FsbChpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxcbiAgICB9XFxuICAgIHJldHVybiBhcjtcXG59O1xcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXFxuICAgICAgICB0b1tqXSA9IGZyb21baV07XFxuICAgIHJldHVybiB0bztcXG59O1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnJhY2UgPSB2b2lkIDA7XFxudmFyIGFyZ3NPckFyZ0FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyZ3NPckFyZ0FycmF5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJnc09yQXJnQXJyYXkuanNcXFwiKTtcXG52YXIgcmFjZVdpdGhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmFjZVdpdGggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3JhY2VXaXRoLmpzXFxcIik7XFxuZnVuY3Rpb24gcmFjZSgpIHtcXG4gICAgdmFyIGFyZ3MgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmFjZVdpdGhfMS5yYWNlV2l0aC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzT3JBcmdBcnJheV8xLmFyZ3NPckFyZ0FycmF5KGFyZ3MpKSkpO1xcbn1cXG5leHBvcnRzLnJhY2UgPSByYWNlO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhY2UuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3JhY2UuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yYWNlV2l0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yYWNlV2l0aC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xcbiAgICBpZiAoIW0pIHJldHVybiBvO1xcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xcbiAgICB9XFxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxcbiAgICBmaW5hbGx5IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXFxcInJldHVyblxcXCJdKSkgbS5jYWxsKGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFyO1xcbn07XFxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcXG4gICAgcmV0dXJuIHRvO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMucmFjZVdpdGggPSB2b2lkIDA7XFxudmFyIHJhY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvcmFjZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3JhY2UuanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBpZGVudGl0eV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pZGVudGl0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lkZW50aXR5LmpzXFxcIik7XFxuZnVuY3Rpb24gcmFjZVdpdGgoKSB7XFxuICAgIHZhciBvdGhlclNvdXJjZXMgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIG90aGVyU291cmNlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHJldHVybiAhb3RoZXJTb3VyY2VzLmxlbmd0aFxcbiAgICAgICAgPyBpZGVudGl0eV8xLmlkZW50aXR5XFxuICAgICAgICA6IGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgICAgICByYWNlXzEucmFjZUluaXQoX19zcHJlYWRBcnJheShbc291cmNlXSwgX19yZWFkKG90aGVyU291cmNlcykpKShzdWJzY3JpYmVyKTtcXG4gICAgICAgIH0pO1xcbn1cXG5leHBvcnRzLnJhY2VXaXRoID0gcmFjZVdpdGg7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFjZVdpdGguanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3JhY2VXaXRoLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmVkdWNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yZWR1Y2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMucmVkdWNlID0gdm9pZCAwO1xcbnZhciBzY2FuSW50ZXJuYWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NjYW5JbnRlcm5hbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NjYW5JbnRlcm5hbHMuanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbmZ1bmN0aW9uIHJlZHVjZShhY2N1bXVsYXRvciwgc2VlZCkge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoc2NhbkludGVybmFsc18xLnNjYW5JbnRlcm5hbHMoYWNjdW11bGF0b3IsIHNlZWQsIGFyZ3VtZW50cy5sZW5ndGggPj0gMiwgZmFsc2UsIHRydWUpKTtcXG59XFxuZXhwb3J0cy5yZWR1Y2UgPSByZWR1Y2U7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdWNlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yZWR1Y2UuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yZWZDb3VudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yZWZDb3VudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnJlZkNvdW50ID0gdm9pZCAwO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIHJlZkNvdW50KCkge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBudWxsO1xcbiAgICAgICAgc291cmNlLl9yZWZDb3VudCsrO1xcbiAgICAgICAgdmFyIHJlZkNvdW50ZXIgPSBPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICghc291cmNlIHx8IHNvdXJjZS5fcmVmQ291bnQgPD0gMCB8fCAwIDwgLS1zb3VyY2UuX3JlZkNvdW50KSB7XFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBudWxsO1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciBzaGFyZWRDb25uZWN0aW9uID0gc291cmNlLl9jb25uZWN0aW9uO1xcbiAgICAgICAgICAgIHZhciBjb25uID0gY29ubmVjdGlvbjtcXG4gICAgICAgICAgICBjb25uZWN0aW9uID0gbnVsbDtcXG4gICAgICAgICAgICBpZiAoc2hhcmVkQ29ubmVjdGlvbiAmJiAoIWNvbm4gfHwgc2hhcmVkQ29ubmVjdGlvbiA9PT0gY29ubikpIHtcXG4gICAgICAgICAgICAgICAgc2hhcmVkQ29ubmVjdGlvbi51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUocmVmQ291bnRlcik7XFxuICAgICAgICBpZiAoIXJlZkNvdW50ZXIuY2xvc2VkKSB7XFxuICAgICAgICAgICAgY29ubmVjdGlvbiA9IHNvdXJjZS5jb25uZWN0KCk7XFxuICAgICAgICB9XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLnJlZkNvdW50ID0gcmVmQ291bnQ7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmQ291bnQuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3JlZkNvdW50LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmVwZWF0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yZXBlYXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMucmVwZWF0ID0gdm9pZCAwO1xcbnZhciBlbXB0eV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9lbXB0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2VtcHR5LmpzXFxcIik7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG52YXIgdGltZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvdGltZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS90aW1lci5qc1xcXCIpO1xcbmZ1bmN0aW9uIHJlcGVhdChjb3VudE9yQ29uZmlnKSB7XFxuICAgIHZhciBfYTtcXG4gICAgdmFyIGNvdW50ID0gSW5maW5pdHk7XFxuICAgIHZhciBkZWxheTtcXG4gICAgaWYgKGNvdW50T3JDb25maWcgIT0gbnVsbCkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBjb3VudE9yQ29uZmlnID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgICAgIChfYSA9IGNvdW50T3JDb25maWcuY291bnQsIGNvdW50ID0gX2EgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX2EsIGRlbGF5ID0gY291bnRPckNvbmZpZy5kZWxheSk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBjb3VudCA9IGNvdW50T3JDb25maWc7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGNvdW50IDw9IDBcXG4gICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gZW1wdHlfMS5FTVBUWTsgfVxcbiAgICAgICAgOiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICAgICAgdmFyIHNvRmFyID0gMDtcXG4gICAgICAgICAgICB2YXIgc291cmNlU3ViO1xcbiAgICAgICAgICAgIHZhciByZXN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgc291cmNlU3ViID09PSBudWxsIHx8IHNvdXJjZVN1YiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlU3ViLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgICAgIHNvdXJjZVN1YiA9IG51bGw7XFxuICAgICAgICAgICAgICAgIGlmIChkZWxheSAhPSBudWxsKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgbm90aWZpZXIgPSB0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInID8gdGltZXJfMS50aW1lcihkZWxheSkgOiBpbm5lckZyb21fMS5pbm5lckZyb20oZGVsYXkoc29GYXIpKTtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3RpZmllclN1YnNjcmliZXJfMSA9IE9wZXJhdG9yU3Vic2NyaWJlcl8xLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpZXJTdWJzY3JpYmVyXzEudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVUb1NvdXJjZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICBub3RpZmllci5zdWJzY3JpYmUobm90aWZpZXJTdWJzY3JpYmVyXzEpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlVG9Tb3VyY2UoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgdmFyIHN1YnNjcmliZVRvU291cmNlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgc3luY1Vuc3ViID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgIHNvdXJjZVN1YiA9IHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrc29GYXIgPCBjb3VudCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VTdWIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNVbnN1YiA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgICAgIGlmIChzeW5jVW5zdWIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJlc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIHN1YnNjcmliZVRvU291cmNlKCk7XFxuICAgICAgICB9KTtcXG59XFxuZXhwb3J0cy5yZXBlYXQgPSByZXBlYXQ7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwZWF0LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yZXBlYXQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yZXBlYXRXaGVuLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmVwZWF0V2hlbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMucmVwZWF0V2hlbiA9IHZvaWQgMDtcXG52YXIgaW5uZXJGcm9tXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vYnNlcnZhYmxlL2lubmVyRnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2lubmVyRnJvbS5qc1xcXCIpO1xcbnZhciBTdWJqZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9TdWJqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YmplY3QuanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG5mdW5jdGlvbiByZXBlYXRXaGVuKG5vdGlmaWVyKSB7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgaW5uZXJTdWI7XFxuICAgICAgICB2YXIgc3luY1Jlc3ViID0gZmFsc2U7XFxuICAgICAgICB2YXIgY29tcGxldGlvbnMkO1xcbiAgICAgICAgdmFyIGlzTm90aWZpZXJDb21wbGV0ZSA9IGZhbHNlO1xcbiAgICAgICAgdmFyIGlzTWFpbkNvbXBsZXRlID0gZmFsc2U7XFxuICAgICAgICB2YXIgY2hlY2tDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzTWFpbkNvbXBsZXRlICYmIGlzTm90aWZpZXJDb21wbGV0ZSAmJiAoc3Vic2NyaWJlci5jb21wbGV0ZSgpLCB0cnVlKTsgfTtcXG4gICAgICAgIHZhciBnZXRDb21wbGV0aW9uU3ViamVjdCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRpb25zJCkge1xcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9ucyQgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcXG4gICAgICAgICAgICAgICAgaW5uZXJGcm9tXzEuaW5uZXJGcm9tKG5vdGlmaWVyKGNvbXBsZXRpb25zJCkpLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyU3ViKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlRm9yUmVwZWF0V2hlbigpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3luY1Jlc3ViID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgaXNOb3RpZmllckNvbXBsZXRlID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQ29tcGxldGUoKTtcXG4gICAgICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGlvbnMkO1xcbiAgICAgICAgfTtcXG4gICAgICAgIHZhciBzdWJzY3JpYmVGb3JSZXBlYXRXaGVuID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlzTWFpbkNvbXBsZXRlID0gZmFsc2U7XFxuICAgICAgICAgICAgaW5uZXJTdWIgPSBzb3VyY2Uuc3Vic2NyaWJlKE9wZXJhdG9yU3Vic2NyaWJlcl8xLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgaXNNYWluQ29tcGxldGUgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAhY2hlY2tDb21wbGV0ZSgpICYmIGdldENvbXBsZXRpb25TdWJqZWN0KCkubmV4dCgpO1xcbiAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICBpZiAoc3luY1Jlc3ViKSB7XFxuICAgICAgICAgICAgICAgIGlubmVyU3ViLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgICAgIGlubmVyU3ViID0gbnVsbDtcXG4gICAgICAgICAgICAgICAgc3luY1Jlc3ViID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZUZvclJlcGVhdFdoZW4oKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgICAgc3Vic2NyaWJlRm9yUmVwZWF0V2hlbigpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5yZXBlYXRXaGVuID0gcmVwZWF0V2hlbjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBlYXRXaGVuLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yZXBlYXRXaGVuLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmV0cnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmV0cnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5yZXRyeSA9IHZvaWQgMDtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG52YXIgaWRlbnRpdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaWRlbnRpdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pZGVudGl0eS5qc1xcXCIpO1xcbnZhciB0aW1lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS90aW1lciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3RpbWVyLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG5mdW5jdGlvbiByZXRyeShjb25maWdPckNvdW50KSB7XFxuICAgIGlmIChjb25maWdPckNvdW50ID09PSB2b2lkIDApIHsgY29uZmlnT3JDb3VudCA9IEluZmluaXR5OyB9XFxuICAgIHZhciBjb25maWc7XFxuICAgIGlmIChjb25maWdPckNvdW50ICYmIHR5cGVvZiBjb25maWdPckNvdW50ID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgY29uZmlnID0gY29uZmlnT3JDb3VudDtcXG4gICAgfVxcbiAgICBlbHNlIHtcXG4gICAgICAgIGNvbmZpZyA9IHtcXG4gICAgICAgICAgICBjb3VudDogY29uZmlnT3JDb3VudCxcXG4gICAgICAgIH07XFxuICAgIH1cXG4gICAgdmFyIF9hID0gY29uZmlnLmNvdW50LCBjb3VudCA9IF9hID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9hLCBkZWxheSA9IGNvbmZpZy5kZWxheSwgX2IgPSBjb25maWcucmVzZXRPblN1Y2Nlc3MsIHJlc2V0T25TdWNjZXNzID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XFxuICAgIHJldHVybiBjb3VudCA8PSAwXFxuICAgICAgICA/IGlkZW50aXR5XzEuaWRlbnRpdHlcXG4gICAgICAgIDogbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgICAgIHZhciBzb0ZhciA9IDA7XFxuICAgICAgICAgICAgdmFyIGlubmVyU3ViO1xcbiAgICAgICAgICAgIHZhciBzdWJzY3JpYmVGb3JSZXRyeSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHN5bmNVbnN1YiA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICBpbm5lclN1YiA9IHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc2V0T25TdWNjZXNzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIgPSAwO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoc29GYXIrKyA8IGNvdW50KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3ViXzEgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbm5lclN1Yikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJTdWIudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyU3ViID0gbnVsbDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZUZvclJldHJ5KCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jVW5zdWIgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsYXkgIT0gbnVsbCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm90aWZpZXIgPSB0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInID8gdGltZXJfMS50aW1lcihkZWxheSkgOiBpbm5lckZyb21fMS5pbm5lckZyb20oZGVsYXkoZXJyLCBzb0ZhcikpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm90aWZpZXJTdWJzY3JpYmVyXzEgPSBPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpZXJTdWJzY3JpYmVyXzEudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3ViXzEoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpZXIuc3Vic2NyaWJlKG5vdGlmaWVyU3Vic2NyaWJlcl8xKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3ViXzEoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICAgICAgaWYgKHN5bmNVbnN1Yikge1xcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJTdWIudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICAgICAgICAgIGlubmVyU3ViID0gbnVsbDtcXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZUZvclJldHJ5KCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIHN1YnNjcmliZUZvclJldHJ5KCk7XFxuICAgICAgICB9KTtcXG59XFxuZXhwb3J0cy5yZXRyeSA9IHJldHJ5O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yZXRyeS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3JldHJ5V2hlbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmV0cnlXaGVuLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnJldHJ5V2hlbiA9IHZvaWQgMDtcXG52YXIgaW5uZXJGcm9tXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vYnNlcnZhYmxlL2lubmVyRnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2lubmVyRnJvbS5qc1xcXCIpO1xcbnZhciBTdWJqZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9TdWJqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YmplY3QuanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG5mdW5jdGlvbiByZXRyeVdoZW4obm90aWZpZXIpIHtcXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBpbm5lclN1YjtcXG4gICAgICAgIHZhciBzeW5jUmVzdWIgPSBmYWxzZTtcXG4gICAgICAgIHZhciBlcnJvcnMkO1xcbiAgICAgICAgdmFyIHN1YnNjcmliZUZvclJldHJ5V2hlbiA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpbm5lclN1YiA9IHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICAgICAgICAgIGlmICghZXJyb3JzJCkge1xcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzJCA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJGcm9tXzEuaW5uZXJGcm9tKG5vdGlmaWVyKGVycm9ycyQpKS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXJTdWIgPyBzdWJzY3JpYmVGb3JSZXRyeVdoZW4oKSA6IChzeW5jUmVzdWIgPSB0cnVlKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzJCkge1xcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzJC5uZXh0KGVycik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgaWYgKHN5bmNSZXN1Yikge1xcbiAgICAgICAgICAgICAgICBpbm5lclN1Yi51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgICAgICBpbm5lclN1YiA9IG51bGw7XFxuICAgICAgICAgICAgICAgIHN5bmNSZXN1YiA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVGb3JSZXRyeVdoZW4oKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgICAgc3Vic2NyaWJlRm9yUmV0cnlXaGVuKCk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLnJldHJ5V2hlbiA9IHJldHJ5V2hlbjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeVdoZW4uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3JldHJ5V2hlbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NhbXBsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2FtcGxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnNhbXBsZSA9IHZvaWQgMDtcXG52YXIgaW5uZXJGcm9tXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vYnNlcnZhYmxlL2lubmVyRnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2lubmVyRnJvbS5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIG5vb3BfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbm9vcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL25vb3AuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxuZnVuY3Rpb24gc2FtcGxlKG5vdGlmaWVyKSB7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgaGFzVmFsdWUgPSBmYWxzZTtcXG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBudWxsO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xcbiAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHZhbHVlO1xcbiAgICAgICAgfSkpO1xcbiAgICAgICAgaW5uZXJGcm9tXzEuaW5uZXJGcm9tKG5vdGlmaWVyKS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAoaGFzVmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgaGFzVmFsdWUgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbGFzdFZhbHVlO1xcbiAgICAgICAgICAgICAgICBsYXN0VmFsdWUgPSBudWxsO1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIG5vb3BfMS5ub29wKSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLnNhbXBsZSA9IHNhbXBsZTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYW1wbGUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NhbXBsZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NhbXBsZVRpbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zYW1wbGVUaW1lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5zYW1wbGVUaW1lID0gdm9pZCAwO1xcbnZhciBhc3luY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc2NoZWR1bGVyL2FzeW5jICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9hc3luYy5qc1xcXCIpO1xcbnZhciBzYW1wbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2FtcGxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zYW1wbGUuanNcXFwiKTtcXG52YXIgaW50ZXJ2YWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvaW50ZXJ2YWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbnRlcnZhbC5qc1xcXCIpO1xcbmZ1bmN0aW9uIHNhbXBsZVRpbWUocGVyaW9kLCBzY2hlZHVsZXIpIHtcXG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmNTY2hlZHVsZXI7IH1cXG4gICAgcmV0dXJuIHNhbXBsZV8xLnNhbXBsZShpbnRlcnZhbF8xLmludGVydmFsKHBlcmlvZCwgc2NoZWR1bGVyKSk7XFxufVxcbmV4cG9ydHMuc2FtcGxlVGltZSA9IHNhbXBsZVRpbWU7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FtcGxlVGltZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2FtcGxlVGltZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NjYW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zY2FuLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5zY2FuID0gdm9pZCAwO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIHNjYW5JbnRlcm5hbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2NhbkludGVybmFscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2NhbkludGVybmFscy5qc1xcXCIpO1xcbmZ1bmN0aW9uIHNjYW4oYWNjdW11bGF0b3IsIHNlZWQpIHtcXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKHNjYW5JbnRlcm5hbHNfMS5zY2FuSW50ZXJuYWxzKGFjY3VtdWxhdG9yLCBzZWVkLCBhcmd1bWVudHMubGVuZ3RoID49IDIsIHRydWUpKTtcXG59XFxuZXhwb3J0cy5zY2FuID0gc2NhbjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2FuLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zY2FuLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2NhbkludGVybmFscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NjYW5JbnRlcm5hbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnNjYW5JbnRlcm5hbHMgPSB2b2lkIDA7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIHNjYW5JbnRlcm5hbHMoYWNjdW11bGF0b3IsIHNlZWQsIGhhc1NlZWQsIGVtaXRPbk5leHQsIGVtaXRCZWZvcmVDb21wbGV0ZSkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGhhc1N0YXRlID0gaGFzU2VlZDtcXG4gICAgICAgIHZhciBzdGF0ZSA9IHNlZWQ7XFxuICAgICAgICB2YXIgaW5kZXggPSAwO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgdmFyIGkgPSBpbmRleCsrO1xcbiAgICAgICAgICAgIHN0YXRlID0gaGFzU3RhdGVcXG4gICAgICAgICAgICAgICAgP1xcbiAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0b3Ioc3RhdGUsIHZhbHVlLCBpKVxcbiAgICAgICAgICAgICAgICA6XFxuICAgICAgICAgICAgICAgICAgICAoKGhhc1N0YXRlID0gdHJ1ZSksIHZhbHVlKTtcXG4gICAgICAgICAgICBlbWl0T25OZXh0ICYmIHN1YnNjcmliZXIubmV4dChzdGF0ZSk7XFxuICAgICAgICB9LCBlbWl0QmVmb3JlQ29tcGxldGUgJiZcXG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBoYXNTdGF0ZSAmJiBzdWJzY3JpYmVyLm5leHQoc3RhdGUpO1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgfSkpKTtcXG4gICAgfTtcXG59XFxuZXhwb3J0cy5zY2FuSW50ZXJuYWxzID0gc2NhbkludGVybmFscztcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2FuSW50ZXJuYWxzLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zY2FuSW50ZXJuYWxzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2VxdWVuY2VFcXVhbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NlcXVlbmNlRXF1YWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnNlcXVlbmNlRXF1YWwgPSB2b2lkIDA7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG5mdW5jdGlvbiBzZXF1ZW5jZUVxdWFsKGNvbXBhcmVUbywgY29tcGFyYXRvcikge1xcbiAgICBpZiAoY29tcGFyYXRvciA9PT0gdm9pZCAwKSB7IGNvbXBhcmF0b3IgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSA9PT0gYjsgfTsgfVxcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGFTdGF0ZSA9IGNyZWF0ZVN0YXRlKCk7XFxuICAgICAgICB2YXIgYlN0YXRlID0gY3JlYXRlU3RhdGUoKTtcXG4gICAgICAgIHZhciBlbWl0ID0gZnVuY3Rpb24gKGlzRXF1YWwpIHtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoaXNFcXVhbCk7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgfTtcXG4gICAgICAgIHZhciBjcmVhdGVTdWJzY3JpYmVyID0gZnVuY3Rpb24gKHNlbGZTdGF0ZSwgb3RoZXJTdGF0ZSkge1xcbiAgICAgICAgICAgIHZhciBzZXF1ZW5jZUVxdWFsU3Vic2NyaWJlciA9IE9wZXJhdG9yU3Vic2NyaWJlcl8xLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gb3RoZXJTdGF0ZS5idWZmZXIsIGNvbXBsZXRlID0gb3RoZXJTdGF0ZS5jb21wbGV0ZTtcXG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlID8gZW1pdChmYWxzZSkgOiBzZWxmU3RhdGUuYnVmZmVyLnB1c2goYSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAhY29tcGFyYXRvcihhLCBidWZmZXIuc2hpZnQoKSkgJiYgZW1pdChmYWxzZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHNlbGZTdGF0ZS5jb21wbGV0ZSA9IHRydWU7XFxuICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IG90aGVyU3RhdGUuY29tcGxldGUsIGJ1ZmZlciA9IG90aGVyU3RhdGUuYnVmZmVyO1xcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSAmJiBlbWl0KGJ1ZmZlci5sZW5ndGggPT09IDApO1xcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZUVxdWFsU3Vic2NyaWJlciA9PT0gbnVsbCB8fCBzZXF1ZW5jZUVxdWFsU3Vic2NyaWJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VxdWVuY2VFcXVhbFN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICByZXR1cm4gc2VxdWVuY2VFcXVhbFN1YnNjcmliZXI7XFxuICAgICAgICB9O1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShjcmVhdGVTdWJzY3JpYmVyKGFTdGF0ZSwgYlN0YXRlKSk7XFxuICAgICAgICBpbm5lckZyb21fMS5pbm5lckZyb20oY29tcGFyZVRvKS5zdWJzY3JpYmUoY3JlYXRlU3Vic2NyaWJlcihiU3RhdGUsIGFTdGF0ZSkpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5zZXF1ZW5jZUVxdWFsID0gc2VxdWVuY2VFcXVhbDtcXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZSgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAgIGJ1ZmZlcjogW10sXFxuICAgICAgICBjb21wbGV0ZTogZmFsc2UsXFxuICAgIH07XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcXVlbmNlRXF1YWwuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NlcXVlbmNlRXF1YWwuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zaGFyZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zaGFyZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xcbiAgICBpZiAoIW0pIHJldHVybiBvO1xcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xcbiAgICB9XFxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxcbiAgICBmaW5hbGx5IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXFxcInJldHVyblxcXCJdKSkgbS5jYWxsKGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFyO1xcbn07XFxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcXG4gICAgcmV0dXJuIHRvO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuc2hhcmUgPSB2b2lkIDA7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG52YXIgU3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vU3ViamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJqZWN0LmpzXFxcIik7XFxudmFyIFN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1N1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvU3Vic2NyaWJlci5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxuZnVuY3Rpb24gc2hhcmUob3B0aW9ucykge1xcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxcbiAgICB2YXIgX2EgPSBvcHRpb25zLmNvbm5lY3RvciwgY29ubmVjdG9yID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpOyB9IDogX2EsIF9iID0gb3B0aW9ucy5yZXNldE9uRXJyb3IsIHJlc2V0T25FcnJvciA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIF9jID0gb3B0aW9ucy5yZXNldE9uQ29tcGxldGUsIHJlc2V0T25Db21wbGV0ZSA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gb3B0aW9ucy5yZXNldE9uUmVmQ291bnRaZXJvLCByZXNldE9uUmVmQ291bnRaZXJvID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZDtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh3cmFwcGVyU291cmNlKSB7XFxuICAgICAgICB2YXIgY29ubmVjdGlvbjtcXG4gICAgICAgIHZhciByZXNldENvbm5lY3Rpb247XFxuICAgICAgICB2YXIgc3ViamVjdDtcXG4gICAgICAgIHZhciByZWZDb3VudCA9IDA7XFxuICAgICAgICB2YXIgaGFzQ29tcGxldGVkID0gZmFsc2U7XFxuICAgICAgICB2YXIgaGFzRXJyb3JlZCA9IGZhbHNlO1xcbiAgICAgICAgdmFyIGNhbmNlbFJlc2V0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJlc2V0Q29ubmVjdGlvbiA9PT0gbnVsbCB8fCByZXNldENvbm5lY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc2V0Q29ubmVjdGlvbi51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgIHJlc2V0Q29ubmVjdGlvbiA9IHVuZGVmaW5lZDtcXG4gICAgICAgIH07XFxuICAgICAgICB2YXIgcmVzZXQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgY2FuY2VsUmVzZXQoKTtcXG4gICAgICAgICAgICBjb25uZWN0aW9uID0gc3ViamVjdCA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgICBoYXNDb21wbGV0ZWQgPSBoYXNFcnJvcmVkID0gZmFsc2U7XFxuICAgICAgICB9O1xcbiAgICAgICAgdmFyIHJlc2V0QW5kVW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIGNvbm4gPSBjb25uZWN0aW9uO1xcbiAgICAgICAgICAgIHJlc2V0KCk7XFxuICAgICAgICAgICAgY29ubiA9PT0gbnVsbCB8fCBjb25uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICB9O1xcbiAgICAgICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgICAgICByZWZDb3VudCsrO1xcbiAgICAgICAgICAgIGlmICghaGFzRXJyb3JlZCAmJiAhaGFzQ29tcGxldGVkKSB7XFxuICAgICAgICAgICAgICAgIGNhbmNlbFJlc2V0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciBkZXN0ID0gKHN1YmplY3QgPSBzdWJqZWN0ICE9PSBudWxsICYmIHN1YmplY3QgIT09IHZvaWQgMCA/IHN1YmplY3QgOiBjb25uZWN0b3IoKSk7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICByZWZDb3VudC0tO1xcbiAgICAgICAgICAgICAgICBpZiAocmVmQ291bnQgPT09IDAgJiYgIWhhc0Vycm9yZWQgJiYgIWhhc0NvbXBsZXRlZCkge1xcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRDb25uZWN0aW9uID0gaGFuZGxlUmVzZXQocmVzZXRBbmRVbnN1YnNjcmliZSwgcmVzZXRPblJlZkNvdW50WmVybyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBkZXN0LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcXG4gICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb24gJiZcXG4gICAgICAgICAgICAgICAgcmVmQ291bnQgPiAwKSB7XFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBuZXcgU3Vic2NyaWJlcl8xLlNhZmVTdWJzY3JpYmVyKHtcXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZGVzdC5uZXh0KHZhbHVlKTsgfSxcXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3JlZCA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsUmVzZXQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldENvbm5lY3Rpb24gPSBoYW5kbGVSZXNldChyZXNldCwgcmVzZXRPbkVycm9yLCBlcnIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3QuZXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NvbXBsZXRlZCA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsUmVzZXQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldENvbm5lY3Rpb24gPSBoYW5kbGVSZXNldChyZXNldCwgcmVzZXRPbkNvbXBsZXRlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0LmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgaW5uZXJGcm9tXzEuaW5uZXJGcm9tKHNvdXJjZSkuc3Vic2NyaWJlKGNvbm5lY3Rpb24pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pKHdyYXBwZXJTb3VyY2UpO1xcbiAgICB9O1xcbn1cXG5leHBvcnRzLnNoYXJlID0gc2hhcmU7XFxuZnVuY3Rpb24gaGFuZGxlUmVzZXQocmVzZXQsIG9uKSB7XFxuICAgIHZhciBhcmdzID0gW107XFxuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIGlmIChvbiA9PT0gdHJ1ZSkge1xcbiAgICAgICAgcmVzZXQoKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBpZiAob24gPT09IGZhbHNlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgdmFyIG9uU3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyXzEuU2FmZVN1YnNjcmliZXIoe1xcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIG9uU3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgIHJlc2V0KCk7XFxuICAgICAgICB9LFxcbiAgICB9KTtcXG4gICAgcmV0dXJuIGlubmVyRnJvbV8xLmlubmVyRnJvbShvbi5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSkpKS5zdWJzY3JpYmUob25TdWJzY3JpYmVyKTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhcmUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NoYXJlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2hhcmVSZXBsYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2hhcmVSZXBsYXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5zaGFyZVJlcGxheSA9IHZvaWQgMDtcXG52YXIgUmVwbGF5U3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vUmVwbGF5U3ViamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9SZXBsYXlTdWJqZWN0LmpzXFxcIik7XFxudmFyIHNoYXJlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NoYXJlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zaGFyZS5qc1xcXCIpO1xcbmZ1bmN0aW9uIHNoYXJlUmVwbGF5KGNvbmZpZ09yQnVmZmVyU2l6ZSwgd2luZG93VGltZSwgc2NoZWR1bGVyKSB7XFxuICAgIHZhciBfYSwgX2IsIF9jO1xcbiAgICB2YXIgYnVmZmVyU2l6ZTtcXG4gICAgdmFyIHJlZkNvdW50ID0gZmFsc2U7XFxuICAgIGlmIChjb25maWdPckJ1ZmZlclNpemUgJiYgdHlwZW9mIGNvbmZpZ09yQnVmZmVyU2l6ZSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgIChfYSA9IGNvbmZpZ09yQnVmZmVyU2l6ZS5idWZmZXJTaXplLCBidWZmZXJTaXplID0gX2EgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX2EsIF9iID0gY29uZmlnT3JCdWZmZXJTaXplLndpbmRvd1RpbWUsIHdpbmRvd1RpbWUgPSBfYiA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfYiwgX2MgPSBjb25maWdPckJ1ZmZlclNpemUucmVmQ291bnQsIHJlZkNvdW50ID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIHNjaGVkdWxlciA9IGNvbmZpZ09yQnVmZmVyU2l6ZS5zY2hlZHVsZXIpO1xcbiAgICB9XFxuICAgIGVsc2Uge1xcbiAgICAgICAgYnVmZmVyU2l6ZSA9IChjb25maWdPckJ1ZmZlclNpemUgIT09IG51bGwgJiYgY29uZmlnT3JCdWZmZXJTaXplICE9PSB2b2lkIDAgPyBjb25maWdPckJ1ZmZlclNpemUgOiBJbmZpbml0eSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHNoYXJlXzEuc2hhcmUoe1xcbiAgICAgICAgY29ubmVjdG9yOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgUmVwbGF5U3ViamVjdF8xLlJlcGxheVN1YmplY3QoYnVmZmVyU2l6ZSwgd2luZG93VGltZSwgc2NoZWR1bGVyKTsgfSxcXG4gICAgICAgIHJlc2V0T25FcnJvcjogdHJ1ZSxcXG4gICAgICAgIHJlc2V0T25Db21wbGV0ZTogZmFsc2UsXFxuICAgICAgICByZXNldE9uUmVmQ291bnRaZXJvOiByZWZDb3VudCxcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuc2hhcmVSZXBsYXkgPSBzaGFyZVJlcGxheTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZVJlcGxheS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2hhcmVSZXBsYXkuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zaW5nbGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NpbmdsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5zaW5nbGUgPSB2b2lkIDA7XFxudmFyIEVtcHR5RXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvRW1wdHlFcnJvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL0VtcHR5RXJyb3IuanNcXFwiKTtcXG52YXIgU2VxdWVuY2VFcnJvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9TZXF1ZW5jZUVycm9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvU2VxdWVuY2VFcnJvci5qc1xcXCIpO1xcbnZhciBOb3RGb3VuZEVycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL05vdEZvdW5kRXJyb3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9Ob3RGb3VuZEVycm9yLmpzXFxcIik7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxuZnVuY3Rpb24gc2luZ2xlKHByZWRpY2F0ZSkge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGhhc1ZhbHVlID0gZmFsc2U7XFxuICAgICAgICB2YXIgc2luZ2xlVmFsdWU7XFxuICAgICAgICB2YXIgc2VlblZhbHVlID0gZmFsc2U7XFxuICAgICAgICB2YXIgaW5kZXggPSAwO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgc2VlblZhbHVlID0gdHJ1ZTtcXG4gICAgICAgICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUodmFsdWUsIGluZGV4KyssIHNvdXJjZSkpIHtcXG4gICAgICAgICAgICAgICAgaGFzVmFsdWUgJiYgc3Vic2NyaWJlci5lcnJvcihuZXcgU2VxdWVuY2VFcnJvcl8xLlNlcXVlbmNlRXJyb3IoJ1RvbyBtYW55IG1hdGNoaW5nIHZhbHVlcycpKTtcXG4gICAgICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICBzaW5nbGVWYWx1ZSA9IHZhbHVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAoaGFzVmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHNpbmdsZVZhbHVlKTtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihzZWVuVmFsdWUgPyBuZXcgTm90Rm91bmRFcnJvcl8xLk5vdEZvdW5kRXJyb3IoJ05vIG1hdGNoaW5nIHZhbHVlcycpIDogbmV3IEVtcHR5RXJyb3JfMS5FbXB0eUVycm9yKCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuc2luZ2xlID0gc2luZ2xlO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbmdsZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2luZ2xlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2tpcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NraXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnNraXAgPSB2b2lkIDA7XFxudmFyIGZpbHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9maWx0ZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbHRlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIHNraXAoY291bnQpIHtcXG4gICAgcmV0dXJuIGZpbHRlcl8xLmZpbHRlcihmdW5jdGlvbiAoXywgaW5kZXgpIHsgcmV0dXJuIGNvdW50IDw9IGluZGV4OyB9KTtcXG59XFxuZXhwb3J0cy5za2lwID0gc2tpcDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1za2lwLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9za2lwLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2tpcExhc3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2tpcExhc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5za2lwTGFzdCA9IHZvaWQgMDtcXG52YXIgaWRlbnRpdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaWRlbnRpdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pZGVudGl0eS5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIHNraXBMYXN0KHNraXBDb3VudCkge1xcbiAgICByZXR1cm4gc2tpcENvdW50IDw9IDBcXG4gICAgICAgID9cXG4gICAgICAgICAgICBpZGVudGl0eV8xLmlkZW50aXR5XFxuICAgICAgICA6IGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgICAgICB2YXIgcmluZyA9IG5ldyBBcnJheShza2lwQ291bnQpO1xcbiAgICAgICAgICAgIHZhciBzZWVuID0gMDtcXG4gICAgICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKE9wZXJhdG9yU3Vic2NyaWJlcl8xLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlSW5kZXggPSBzZWVuKys7XFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZUluZGV4IDwgc2tpcENvdW50KSB7XFxuICAgICAgICAgICAgICAgICAgICByaW5nW3ZhbHVlSW5kZXhdID0gdmFsdWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB2YWx1ZUluZGV4ICUgc2tpcENvdW50O1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gcmluZ1tpbmRleF07XFxuICAgICAgICAgICAgICAgICAgICByaW5nW2luZGV4XSA9IHZhbHVlO1xcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KG9sZFZhbHVlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICByaW5nID0gbnVsbDtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfSk7XFxufVxcbmV4cG9ydHMuc2tpcExhc3QgPSBza2lwTGFzdDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1za2lwTGFzdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2tpcExhc3QuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9za2lwVW50aWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NraXBVbnRpbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5za2lwVW50aWwgPSB2b2lkIDA7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG52YXIgbm9vcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9ub29wICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbm9vcC5qc1xcXCIpO1xcbmZ1bmN0aW9uIHNraXBVbnRpbChub3RpZmllcikge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIHRha2luZyA9IGZhbHNlO1xcbiAgICAgICAgdmFyIHNraXBTdWJzY3JpYmVyID0gT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBza2lwU3Vic2NyaWJlciA9PT0gbnVsbCB8fCBza2lwU3Vic2NyaWJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2tpcFN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICB0YWtpbmcgPSB0cnVlO1xcbiAgICAgICAgfSwgbm9vcF8xLm5vb3ApO1xcbiAgICAgICAgaW5uZXJGcm9tXzEuaW5uZXJGcm9tKG5vdGlmaWVyKS5zdWJzY3JpYmUoc2tpcFN1YnNjcmliZXIpO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0YWtpbmcgJiYgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTsgfSkpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5za2lwVW50aWwgPSBza2lwVW50aWw7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2tpcFVudGlsLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9za2lwVW50aWwuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9za2lwV2hpbGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NraXBXaGlsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5za2lwV2hpbGUgPSB2b2lkIDA7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxuZnVuY3Rpb24gc2tpcFdoaWxlKHByZWRpY2F0ZSkge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIHRha2luZyA9IGZhbHNlO1xcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gKHRha2luZyB8fCAodGFraW5nID0gIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgrKykpKSAmJiBzdWJzY3JpYmVyLm5leHQodmFsdWUpOyB9KSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLnNraXBXaGlsZSA9IHNraXBXaGlsZTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1za2lwV2hpbGUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NraXBXaGlsZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3N0YXJ0V2l0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc3RhcnRXaXRoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnN0YXJ0V2l0aCA9IHZvaWQgMDtcXG52YXIgY29uY2F0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vYnNlcnZhYmxlL2NvbmNhdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2NvbmNhdC5qc1xcXCIpO1xcbnZhciBhcmdzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyZ3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9hcmdzLmpzXFxcIik7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG5mdW5jdGlvbiBzdGFydFdpdGgoKSB7XFxuICAgIHZhciB2YWx1ZXMgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIHZhbHVlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHZhciBzY2hlZHVsZXIgPSBhcmdzXzEucG9wU2NoZWR1bGVyKHZhbHVlcyk7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICAoc2NoZWR1bGVyID8gY29uY2F0XzEuY29uY2F0KHZhbHVlcywgc291cmNlLCBzY2hlZHVsZXIpIDogY29uY2F0XzEuY29uY2F0KHZhbHVlcywgc291cmNlKSkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5zdGFydFdpdGggPSBzdGFydFdpdGg7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhcnRXaXRoLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zdGFydFdpdGguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zdWJzY3JpYmVPbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zdWJzY3JpYmVPbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnN1YnNjcmliZU9uID0gdm9pZCAwO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxuZnVuY3Rpb24gc3Vic2NyaWJlT24oc2NoZWR1bGVyLCBkZWxheSkge1xcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHN1YnNjcmliZXIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpOyB9LCBkZWxheSkpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5zdWJzY3JpYmVPbiA9IHN1YnNjcmliZU9uO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZU9uLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zdWJzY3JpYmVPbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3N3aXRjaEFsbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoQWxsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnN3aXRjaEFsbCA9IHZvaWQgMDtcXG52YXIgc3dpdGNoTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N3aXRjaE1hcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoTWFwLmpzXFxcIik7XFxudmFyIGlkZW50aXR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lkZW50aXR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaWRlbnRpdHkuanNcXFwiKTtcXG5mdW5jdGlvbiBzd2l0Y2hBbGwoKSB7XFxuICAgIHJldHVybiBzd2l0Y2hNYXBfMS5zd2l0Y2hNYXAoaWRlbnRpdHlfMS5pZGVudGl0eSk7XFxufVxcbmV4cG9ydHMuc3dpdGNoQWxsID0gc3dpdGNoQWxsO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaEFsbC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoQWxsLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoTWFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zd2l0Y2hNYXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuc3dpdGNoTWFwID0gdm9pZCAwO1xcbnZhciBpbm5lckZyb21fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvaW5uZXJGcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29ic2VydmFibGUvaW5uZXJGcm9tLmpzXFxcIik7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxuZnVuY3Rpb24gc3dpdGNoTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpYmVyID0gbnVsbDtcXG4gICAgICAgIHZhciBpbmRleCA9IDA7XFxuICAgICAgICB2YXIgaXNDb21wbGV0ZSA9IGZhbHNlO1xcbiAgICAgICAgdmFyIGNoZWNrQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpc0NvbXBsZXRlICYmICFpbm5lclN1YnNjcmliZXIgJiYgc3Vic2NyaWJlci5jb21wbGV0ZSgpOyB9O1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgaW5uZXJTdWJzY3JpYmVyID09PSBudWxsIHx8IGlubmVyU3Vic2NyaWJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5uZXJTdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgdmFyIGlubmVySW5kZXggPSAwO1xcbiAgICAgICAgICAgIHZhciBvdXRlckluZGV4ID0gaW5kZXgrKztcXG4gICAgICAgICAgICBpbm5lckZyb21fMS5pbm5lckZyb20ocHJvamVjdCh2YWx1ZSwgb3V0ZXJJbmRleCkpLnN1YnNjcmliZSgoaW5uZXJTdWJzY3JpYmVyID0gT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uIChpbm5lclZhbHVlKSB7IHJldHVybiBzdWJzY3JpYmVyLm5leHQocmVzdWx0U2VsZWN0b3IgPyByZXN1bHRTZWxlY3Rvcih2YWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCsrKSA6IGlubmVyVmFsdWUpOyB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGlubmVyU3Vic2NyaWJlciA9IG51bGw7XFxuICAgICAgICAgICAgICAgIGNoZWNrQ29tcGxldGUoKTtcXG4gICAgICAgICAgICB9KSkpO1xcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlzQ29tcGxldGUgPSB0cnVlO1xcbiAgICAgICAgICAgIGNoZWNrQ29tcGxldGUoKTtcXG4gICAgICAgIH0pKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuc3dpdGNoTWFwID0gc3dpdGNoTWFwO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaE1hcC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoTWFwLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoTWFwVG8uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoTWFwVG8uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5zd2l0Y2hNYXBUbyA9IHZvaWQgMDtcXG52YXIgc3dpdGNoTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N3aXRjaE1hcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoTWFwLmpzXFxcIik7XFxudmFyIGlzRnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG5mdW5jdGlvbiBzd2l0Y2hNYXBUbyhpbm5lck9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yKSB7XFxuICAgIHJldHVybiBpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihyZXN1bHRTZWxlY3RvcikgPyBzd2l0Y2hNYXBfMS5zd2l0Y2hNYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5uZXJPYnNlcnZhYmxlOyB9LCByZXN1bHRTZWxlY3RvcikgOiBzd2l0Y2hNYXBfMS5zd2l0Y2hNYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5uZXJPYnNlcnZhYmxlOyB9KTtcXG59XFxuZXhwb3J0cy5zd2l0Y2hNYXBUbyA9IHN3aXRjaE1hcFRvO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaE1hcFRvLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zd2l0Y2hNYXBUby5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3N3aXRjaFNjYW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zd2l0Y2hTY2FuLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5zd2l0Y2hTY2FuID0gdm9pZCAwO1xcbnZhciBzd2l0Y2hNYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3dpdGNoTWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zd2l0Y2hNYXAuanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbmZ1bmN0aW9uIHN3aXRjaFNjYW4oYWNjdW11bGF0b3IsIHNlZWQpIHtcXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBzdGF0ZSA9IHNlZWQ7XFxuICAgICAgICBzd2l0Y2hNYXBfMS5zd2l0Y2hNYXAoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkgeyByZXR1cm4gYWNjdW11bGF0b3Ioc3RhdGUsIHZhbHVlLCBpbmRleCk7IH0sIGZ1bmN0aW9uIChfLCBpbm5lclZhbHVlKSB7IHJldHVybiAoKHN0YXRlID0gaW5uZXJWYWx1ZSksIGlubmVyVmFsdWUpOyB9KShzb3VyY2UpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgc3RhdGUgPSBudWxsO1xcbiAgICAgICAgfTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuc3dpdGNoU2NhbiA9IHN3aXRjaFNjYW47XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoU2Nhbi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoU2Nhbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90YWtlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy50YWtlID0gdm9pZCAwO1xcbnZhciBlbXB0eV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9lbXB0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2VtcHR5LmpzXFxcIik7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxuZnVuY3Rpb24gdGFrZShjb3VudCkge1xcbiAgICByZXR1cm4gY291bnQgPD0gMFxcbiAgICAgICAgP1xcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVtcHR5XzEuRU1QVFk7IH1cXG4gICAgICAgIDogbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgICAgIHZhciBzZWVuID0gMDtcXG4gICAgICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKE9wZXJhdG9yU3Vic2NyaWJlcl8xLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCsrc2VlbiA8PSBjb3VudCkge1xcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA8PSBzZWVuKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgfSk7XFxufVxcbmV4cG9ydHMudGFrZSA9IHRha2U7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2VMYXN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2VMYXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XFxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcXFwibnVtYmVyXFxcIikgcmV0dXJuIHtcXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXFxcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXFxcIiA6IFxcXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXFxcIik7XFxufTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy50YWtlTGFzdCA9IHZvaWQgMDtcXG52YXIgZW1wdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29ic2VydmFibGUvZW1wdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9lbXB0eS5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIHRha2VMYXN0KGNvdW50KSB7XFxuICAgIHJldHVybiBjb3VudCA8PSAwXFxuICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVtcHR5XzEuRU1QVFk7IH1cXG4gICAgICAgIDogbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBbXTtcXG4gICAgICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKE9wZXJhdG9yU3Vic2NyaWJlcl8xLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1c2godmFsdWUpO1xcbiAgICAgICAgICAgICAgICBjb3VudCA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyLnNoaWZ0KCk7XFxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgZV8xLCBfYTtcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGJ1ZmZlcl8xID0gX192YWx1ZXMoYnVmZmVyKSwgYnVmZmVyXzFfMSA9IGJ1ZmZlcl8xLm5leHQoKTsgIWJ1ZmZlcl8xXzEuZG9uZTsgYnVmZmVyXzFfMSA9IGJ1ZmZlcl8xLm5leHQoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGJ1ZmZlcl8xXzEudmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcl8xXzEgJiYgIWJ1ZmZlcl8xXzEuZG9uZSAmJiAoX2EgPSBidWZmZXJfMS5yZXR1cm4pKSBfYS5jYWxsKGJ1ZmZlcl8xKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG51bGw7XFxuICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgfSk7XFxufVxcbmV4cG9ydHMudGFrZUxhc3QgPSB0YWtlTGFzdDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlTGFzdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZUxhc3QuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90YWtlVW50aWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2VVbnRpbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy50YWtlVW50aWwgPSB2b2lkIDA7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG52YXIgbm9vcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9ub29wICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbm9vcC5qc1xcXCIpO1xcbmZ1bmN0aW9uIHRha2VVbnRpbChub3RpZmllcikge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgaW5uZXJGcm9tXzEuaW5uZXJGcm9tKG5vdGlmaWVyKS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTsgfSwgbm9vcF8xLm5vb3ApKTtcXG4gICAgICAgICFzdWJzY3JpYmVyLmNsb3NlZCAmJiBzb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy50YWtlVW50aWwgPSB0YWtlVW50aWw7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZVVudGlsLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90YWtlVW50aWwuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90YWtlV2hpbGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2VXaGlsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy50YWtlV2hpbGUgPSB2b2lkIDA7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxuZnVuY3Rpb24gdGFrZVdoaWxlKHByZWRpY2F0ZSwgaW5jbHVzaXZlKSB7XFxuICAgIGlmIChpbmNsdXNpdmUgPT09IHZvaWQgMCkgeyBpbmNsdXNpdmUgPSBmYWxzZTsgfVxcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBwcmVkaWNhdGUodmFsdWUsIGluZGV4KyspO1xcbiAgICAgICAgICAgIChyZXN1bHQgfHwgaW5jbHVzaXZlKSAmJiBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xcbiAgICAgICAgICAgICFyZXN1bHQgJiYgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgfSkpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy50YWtlV2hpbGUgPSB0YWtlV2hpbGU7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZVdoaWxlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90YWtlV2hpbGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90YXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3RhcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy50YXAgPSB2b2lkIDA7XFxudmFyIGlzRnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG52YXIgaWRlbnRpdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaWRlbnRpdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pZGVudGl0eS5qc1xcXCIpO1xcbmZ1bmN0aW9uIHRhcChvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XFxuICAgIHZhciB0YXBPYnNlcnZlciA9IGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9ic2VydmVyT3JOZXh0KSB8fCBlcnJvciB8fCBjb21wbGV0ZVxcbiAgICAgICAgP1xcbiAgICAgICAgICAgIHsgbmV4dDogb2JzZXJ2ZXJPck5leHQsIGVycm9yOiBlcnJvciwgY29tcGxldGU6IGNvbXBsZXRlIH1cXG4gICAgICAgIDogb2JzZXJ2ZXJPck5leHQ7XFxuICAgIHJldHVybiB0YXBPYnNlcnZlclxcbiAgICAgICAgPyBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgICAgIChfYSA9IHRhcE9ic2VydmVyLnN1YnNjcmliZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGFwT2JzZXJ2ZXIpO1xcbiAgICAgICAgICAgIHZhciBpc1Vuc3ViID0gdHJ1ZTtcXG4gICAgICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKE9wZXJhdG9yU3Vic2NyaWJlcl8xLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgICAgICAgICAoX2EgPSB0YXBPYnNlcnZlci5uZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0YXBPYnNlcnZlciwgdmFsdWUpO1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgICAgICAgICBpc1Vuc3ViID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgIChfYSA9IHRhcE9ic2VydmVyLmNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0YXBPYnNlcnZlcik7XFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICAgICAgICAgIHZhciBfYTtcXG4gICAgICAgICAgICAgICAgaXNVbnN1YiA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICAoX2EgPSB0YXBPYnNlcnZlci5lcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGFwT2JzZXJ2ZXIsIGVycik7XFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XFxuICAgICAgICAgICAgICAgIGlmIChpc1Vuc3ViKSB7XFxuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0YXBPYnNlcnZlci51bnN1YnNjcmliZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGFwT2JzZXJ2ZXIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIChfYiA9IHRhcE9ic2VydmVyLmZpbmFsaXplKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh0YXBPYnNlcnZlcik7XFxuICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgfSlcXG4gICAgICAgIDpcXG4gICAgICAgICAgICBpZGVudGl0eV8xLmlkZW50aXR5O1xcbn1cXG5leHBvcnRzLnRhcCA9IHRhcDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YXAuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3RhcC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm90dGxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm90dGxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMudGhyb3R0bGUgPSB2b2lkIDA7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG5mdW5jdGlvbiB0aHJvdHRsZShkdXJhdGlvblNlbGVjdG9yLCBjb25maWcpIHtcXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBfYSA9IGNvbmZpZyAhPT0gbnVsbCAmJiBjb25maWcgIT09IHZvaWQgMCA/IGNvbmZpZyA6IHt9LCBfYiA9IF9hLmxlYWRpbmcsIGxlYWRpbmcgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBfYyA9IF9hLnRyYWlsaW5nLCB0cmFpbGluZyA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jO1xcbiAgICAgICAgdmFyIGhhc1ZhbHVlID0gZmFsc2U7XFxuICAgICAgICB2YXIgc2VuZFZhbHVlID0gbnVsbDtcXG4gICAgICAgIHZhciB0aHJvdHRsZWQgPSBudWxsO1xcbiAgICAgICAgdmFyIGlzQ29tcGxldGUgPSBmYWxzZTtcXG4gICAgICAgIHZhciBlbmRUaHJvdHRsaW5nID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHRocm90dGxlZCA9PT0gbnVsbCB8fCB0aHJvdHRsZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRocm90dGxlZC51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgIHRocm90dGxlZCA9IG51bGw7XFxuICAgICAgICAgICAgaWYgKHRyYWlsaW5nKSB7XFxuICAgICAgICAgICAgICAgIHNlbmQoKTtcXG4gICAgICAgICAgICAgICAgaXNDb21wbGV0ZSAmJiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfTtcXG4gICAgICAgIHZhciBjbGVhbnVwVGhyb3R0bGluZyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0aHJvdHRsZWQgPSBudWxsO1xcbiAgICAgICAgICAgIGlzQ29tcGxldGUgJiYgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgfTtcXG4gICAgICAgIHZhciBzdGFydFRocm90dGxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgcmV0dXJuICh0aHJvdHRsZWQgPSBpbm5lckZyb21fMS5pbm5lckZyb20oZHVyYXRpb25TZWxlY3Rvcih2YWx1ZSkpLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZW5kVGhyb3R0bGluZywgY2xlYW51cFRocm90dGxpbmcpKSk7XFxuICAgICAgICB9O1xcbiAgICAgICAgdmFyIHNlbmQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKGhhc1ZhbHVlKSB7XFxuICAgICAgICAgICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNlbmRWYWx1ZTtcXG4gICAgICAgICAgICAgICAgc2VuZFZhbHVlID0gbnVsbDtcXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgIWlzQ29tcGxldGUgJiYgc3RhcnRUaHJvdHRsZSh2YWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfTtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcXG4gICAgICAgICAgICBzZW5kVmFsdWUgPSB2YWx1ZTtcXG4gICAgICAgICAgICAhKHRocm90dGxlZCAmJiAhdGhyb3R0bGVkLmNsb3NlZCkgJiYgKGxlYWRpbmcgPyBzZW5kKCkgOiBzdGFydFRocm90dGxlKHZhbHVlKSk7XFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaXNDb21wbGV0ZSA9IHRydWU7XFxuICAgICAgICAgICAgISh0cmFpbGluZyAmJiBoYXNWYWx1ZSAmJiB0aHJvdHRsZWQgJiYgIXRocm90dGxlZC5jbG9zZWQpICYmIHN1YnNjcmliZXIuY29tcGxldGUoKTtcXG4gICAgICAgIH0pKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdHRsZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGhyb3R0bGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90aHJvdHRsZVRpbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm90dGxlVGltZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy50aHJvdHRsZVRpbWUgPSB2b2lkIDA7XFxudmFyIGFzeW5jXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9zY2hlZHVsZXIvYXN5bmMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL2FzeW5jLmpzXFxcIik7XFxudmFyIHRocm90dGxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Rocm90dGxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90aHJvdHRsZS5qc1xcXCIpO1xcbnZhciB0aW1lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS90aW1lciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL3RpbWVyLmpzXFxcIik7XFxuZnVuY3Rpb24gdGhyb3R0bGVUaW1lKGR1cmF0aW9uLCBzY2hlZHVsZXIsIGNvbmZpZykge1xcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luY1NjaGVkdWxlcjsgfVxcbiAgICB2YXIgZHVyYXRpb24kID0gdGltZXJfMS50aW1lcihkdXJhdGlvbiwgc2NoZWR1bGVyKTtcXG4gICAgcmV0dXJuIHRocm90dGxlXzEudGhyb3R0bGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZHVyYXRpb24kOyB9LCBjb25maWcpO1xcbn1cXG5leHBvcnRzLnRocm90dGxlVGltZSA9IHRocm90dGxlVGltZTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdHRsZVRpbWUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm90dGxlVGltZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm93SWZFbXB0eS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGhyb3dJZkVtcHR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnRocm93SWZFbXB0eSA9IHZvaWQgMDtcXG52YXIgRW1wdHlFcnJvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9FbXB0eUVycm9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvRW1wdHlFcnJvci5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIHRocm93SWZFbXB0eShlcnJvckZhY3RvcnkpIHtcXG4gICAgaWYgKGVycm9yRmFjdG9yeSA9PT0gdm9pZCAwKSB7IGVycm9yRmFjdG9yeSA9IGRlZmF1bHRFcnJvckZhY3Rvcnk7IH1cXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBoYXNWYWx1ZSA9IGZhbHNlO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoaGFzVmFsdWUgPyBzdWJzY3JpYmVyLmNvbXBsZXRlKCkgOiBzdWJzY3JpYmVyLmVycm9yKGVycm9yRmFjdG9yeSgpKSk7IH0pKTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMudGhyb3dJZkVtcHR5ID0gdGhyb3dJZkVtcHR5O1xcbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckZhY3RvcnkoKSB7XFxuICAgIHJldHVybiBuZXcgRW1wdHlFcnJvcl8xLkVtcHR5RXJyb3IoKTtcXG59XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3dJZkVtcHR5LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90aHJvd0lmRW1wdHkuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90aW1lSW50ZXJ2YWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3RpbWVJbnRlcnZhbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5UaW1lSW50ZXJ2YWwgPSBleHBvcnRzLnRpbWVJbnRlcnZhbCA9IHZvaWQgMDtcXG52YXIgYXN5bmNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3NjaGVkdWxlci9hc3luYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvYXN5bmMuanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG5mdW5jdGlvbiB0aW1lSW50ZXJ2YWwoc2NoZWR1bGVyKSB7XFxuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jU2NoZWR1bGVyOyB9XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgbGFzdCA9IHNjaGVkdWxlci5ub3coKTtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIHZhciBub3cgPSBzY2hlZHVsZXIubm93KCk7XFxuICAgICAgICAgICAgdmFyIGludGVydmFsID0gbm93IC0gbGFzdDtcXG4gICAgICAgICAgICBsYXN0ID0gbm93O1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChuZXcgVGltZUludGVydmFsKHZhbHVlLCBpbnRlcnZhbCkpO1xcbiAgICAgICAgfSkpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy50aW1lSW50ZXJ2YWwgPSB0aW1lSW50ZXJ2YWw7XFxudmFyIFRpbWVJbnRlcnZhbCA9IChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIFRpbWVJbnRlcnZhbCh2YWx1ZSwgaW50ZXJ2YWwpIHtcXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcXG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcXG4gICAgfVxcbiAgICByZXR1cm4gVGltZUludGVydmFsO1xcbn0oKSk7XFxuZXhwb3J0cy5UaW1lSW50ZXJ2YWwgPSBUaW1lSW50ZXJ2YWw7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZUludGVydmFsLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90aW1lSW50ZXJ2YWwuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90aW1lb3V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGltZW91dC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMudGltZW91dCA9IGV4cG9ydHMuVGltZW91dEVycm9yID0gdm9pZCAwO1xcbnZhciBhc3luY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc2NoZWR1bGVyL2FzeW5jICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9hc3luYy5qc1xcXCIpO1xcbnZhciBpc0RhdGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNEYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNEYXRlLmpzXFxcIik7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgaW5uZXJGcm9tXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vYnNlcnZhYmxlL2lubmVyRnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2lubmVyRnJvbS5qc1xcXCIpO1xcbnZhciBjcmVhdGVFcnJvckNsYXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2NyZWF0ZUVycm9yQ2xhc3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9jcmVhdGVFcnJvckNsYXNzLmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbnZhciBleGVjdXRlU2NoZWR1bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvZXhlY3V0ZVNjaGVkdWxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvZXhlY3V0ZVNjaGVkdWxlLmpzXFxcIik7XFxuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBjcmVhdGVFcnJvckNsYXNzXzEuY3JlYXRlRXJyb3JDbGFzcyhmdW5jdGlvbiAoX3N1cGVyKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiBUaW1lb3V0RXJyb3JJbXBsKGluZm8pIHtcXG4gICAgICAgIGlmIChpbmZvID09PSB2b2lkIDApIHsgaW5mbyA9IG51bGw7IH1cXG4gICAgICAgIF9zdXBlcih0aGlzKTtcXG4gICAgICAgIHRoaXMubWVzc2FnZSA9ICdUaW1lb3V0IGhhcyBvY2N1cnJlZCc7XFxuICAgICAgICB0aGlzLm5hbWUgPSAnVGltZW91dEVycm9yJztcXG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm87XFxuICAgIH07XFxufSk7XFxuZnVuY3Rpb24gdGltZW91dChjb25maWcsIHNjaGVkdWxlckFyZykge1xcbiAgICB2YXIgX2EgPSAoaXNEYXRlXzEuaXNWYWxpZERhdGUoY29uZmlnKSA/IHsgZmlyc3Q6IGNvbmZpZyB9IDogdHlwZW9mIGNvbmZpZyA9PT0gJ251bWJlcicgPyB7IGVhY2g6IGNvbmZpZyB9IDogY29uZmlnKSwgZmlyc3QgPSBfYS5maXJzdCwgZWFjaCA9IF9hLmVhY2gsIF9iID0gX2Eud2l0aCwgX3dpdGggPSBfYiA9PT0gdm9pZCAwID8gdGltZW91dEVycm9yRmFjdG9yeSA6IF9iLCBfYyA9IF9hLnNjaGVkdWxlciwgc2NoZWR1bGVyID0gX2MgPT09IHZvaWQgMCA/IHNjaGVkdWxlckFyZyAhPT0gbnVsbCAmJiBzY2hlZHVsZXJBcmcgIT09IHZvaWQgMCA/IHNjaGVkdWxlckFyZyA6IGFzeW5jXzEuYXN5bmNTY2hlZHVsZXIgOiBfYywgX2QgPSBfYS5tZXRhLCBtZXRhID0gX2QgPT09IHZvaWQgMCA/IG51bGwgOiBfZDtcXG4gICAgaWYgKGZpcnN0ID09IG51bGwgJiYgZWFjaCA9PSBudWxsKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyB0aW1lb3V0IHByb3ZpZGVkLicpO1xcbiAgICB9XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgb3JpZ2luYWxTb3VyY2VTdWJzY3JpcHRpb247XFxuICAgICAgICB2YXIgdGltZXJTdWJzY3JpcHRpb247XFxuICAgICAgICB2YXIgbGFzdFZhbHVlID0gbnVsbDtcXG4gICAgICAgIHZhciBzZWVuID0gMDtcXG4gICAgICAgIHZhciBzdGFydFRpbWVyID0gZnVuY3Rpb24gKGRlbGF5KSB7XFxuICAgICAgICAgICAgdGltZXJTdWJzY3JpcHRpb24gPSBleGVjdXRlU2NoZWR1bGVfMS5leGVjdXRlU2NoZWR1bGUoc3Vic2NyaWJlciwgc2NoZWR1bGVyLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFNvdXJjZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJGcm9tXzEuaW5uZXJGcm9tKF93aXRoKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiBtZXRhLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RWYWx1ZTogbGFzdFZhbHVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW46IHNlZW4sXFxuICAgICAgICAgICAgICAgICAgICB9KSkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sIGRlbGF5KTtcXG4gICAgICAgIH07XFxuICAgICAgICBvcmlnaW5hbFNvdXJjZVN1YnNjcmlwdGlvbiA9IHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIHRpbWVyU3Vic2NyaXB0aW9uID09PSBudWxsIHx8IHRpbWVyU3Vic2NyaXB0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aW1lclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgIHNlZW4rKztcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoKGxhc3RWYWx1ZSA9IHZhbHVlKSk7XFxuICAgICAgICAgICAgZWFjaCA+IDAgJiYgc3RhcnRUaW1lcihlYWNoKTtcXG4gICAgICAgIH0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKCEodGltZXJTdWJzY3JpcHRpb24gPT09IG51bGwgfHwgdGltZXJTdWJzY3JpcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpbWVyU3Vic2NyaXB0aW9uLmNsb3NlZCkpIHtcXG4gICAgICAgICAgICAgICAgdGltZXJTdWJzY3JpcHRpb24gPT09IG51bGwgfHwgdGltZXJTdWJzY3JpcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpbWVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxhc3RWYWx1ZSA9IG51bGw7XFxuICAgICAgICB9KSk7XFxuICAgICAgICAhc2VlbiAmJiBzdGFydFRpbWVyKGZpcnN0ICE9IG51bGwgPyAodHlwZW9mIGZpcnN0ID09PSAnbnVtYmVyJyA/IGZpcnN0IDogK2ZpcnN0IC0gc2NoZWR1bGVyLm5vdygpKSA6IGVhY2gpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dDtcXG5mdW5jdGlvbiB0aW1lb3V0RXJyb3JGYWN0b3J5KGluZm8pIHtcXG4gICAgdGhyb3cgbmV3IGV4cG9ydHMuVGltZW91dEVycm9yKGluZm8pO1xcbn1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lb3V0LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90aW1lb3V0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGltZW91dFdpdGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGltZW91dFdpdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy50aW1lb3V0V2l0aCA9IHZvaWQgMDtcXG52YXIgYXN5bmNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3NjaGVkdWxlci9hc3luYyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvYXN5bmMuanNcXFwiKTtcXG52YXIgaXNEYXRlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzRGF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRGF0ZS5qc1xcXCIpO1xcbnZhciB0aW1lb3V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RpbWVvdXQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3RpbWVvdXQuanNcXFwiKTtcXG5mdW5jdGlvbiB0aW1lb3V0V2l0aChkdWUsIHdpdGhPYnNlcnZhYmxlLCBzY2hlZHVsZXIpIHtcXG4gICAgdmFyIGZpcnN0O1xcbiAgICB2YXIgZWFjaDtcXG4gICAgdmFyIF93aXRoO1xcbiAgICBzY2hlZHVsZXIgPSBzY2hlZHVsZXIgIT09IG51bGwgJiYgc2NoZWR1bGVyICE9PSB2b2lkIDAgPyBzY2hlZHVsZXIgOiBhc3luY18xLmFzeW5jO1xcbiAgICBpZiAoaXNEYXRlXzEuaXNWYWxpZERhdGUoZHVlKSkge1xcbiAgICAgICAgZmlyc3QgPSBkdWU7XFxuICAgIH1cXG4gICAgZWxzZSBpZiAodHlwZW9mIGR1ZSA9PT0gJ251bWJlcicpIHtcXG4gICAgICAgIGVhY2ggPSBkdWU7XFxuICAgIH1cXG4gICAgaWYgKHdpdGhPYnNlcnZhYmxlKSB7XFxuICAgICAgICBfd2l0aCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpdGhPYnNlcnZhYmxlOyB9O1xcbiAgICB9XFxuICAgIGVsc2Uge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gb2JzZXJ2YWJsZSBwcm92aWRlZCB0byBzd2l0Y2ggdG8nKTtcXG4gICAgfVxcbiAgICBpZiAoZmlyc3QgPT0gbnVsbCAmJiBlYWNoID09IG51bGwpIHtcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIHRpbWVvdXQgcHJvdmlkZWQuJyk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRpbWVvdXRfMS50aW1lb3V0KHtcXG4gICAgICAgIGZpcnN0OiBmaXJzdCxcXG4gICAgICAgIGVhY2g6IGVhY2gsXFxuICAgICAgICBzY2hlZHVsZXI6IHNjaGVkdWxlcixcXG4gICAgICAgIHdpdGg6IF93aXRoLFxcbiAgICB9KTtcXG59XFxuZXhwb3J0cy50aW1lb3V0V2l0aCA9IHRpbWVvdXRXaXRoO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVvdXRXaXRoLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90aW1lb3V0V2l0aC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3RpbWVzdGFtcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGltZXN0YW1wLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnRpbWVzdGFtcCA9IHZvaWQgMDtcXG52YXIgZGF0ZVRpbWVzdGFtcFByb3ZpZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9zY2hlZHVsZXIvZGF0ZVRpbWVzdGFtcFByb3ZpZGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9kYXRlVGltZXN0YW1wUHJvdmlkZXIuanNcXFwiKTtcXG52YXIgbWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21hcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWFwLmpzXFxcIik7XFxuZnVuY3Rpb24gdGltZXN0YW1wKHRpbWVzdGFtcFByb3ZpZGVyKSB7XFxuICAgIGlmICh0aW1lc3RhbXBQcm92aWRlciA9PT0gdm9pZCAwKSB7IHRpbWVzdGFtcFByb3ZpZGVyID0gZGF0ZVRpbWVzdGFtcFByb3ZpZGVyXzEuZGF0ZVRpbWVzdGFtcFByb3ZpZGVyOyB9XFxuICAgIHJldHVybiBtYXBfMS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAoeyB2YWx1ZTogdmFsdWUsIHRpbWVzdGFtcDogdGltZXN0YW1wUHJvdmlkZXIubm93KCkgfSk7IH0pO1xcbn1cXG5leHBvcnRzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lc3RhbXAuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3RpbWVzdGFtcC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3RvQXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90b0FycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy50b0FycmF5ID0gdm9pZCAwO1xcbnZhciByZWR1Y2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVkdWNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yZWR1Y2UuanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBhcnJSZWR1Y2VyID0gZnVuY3Rpb24gKGFyciwgdmFsdWUpIHsgcmV0dXJuIChhcnIucHVzaCh2YWx1ZSksIGFycik7IH07XFxuZnVuY3Rpb24gdG9BcnJheSgpIHtcXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHJlZHVjZV8xLnJlZHVjZShhcnJSZWR1Y2VyLCBbXSkoc291cmNlKS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvQXJyYXkuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3RvQXJyYXkuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3cuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvdy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy53aW5kb3cgPSB2b2lkIDA7XFxudmFyIFN1YmplY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1N1YmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvU3ViamVjdC5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbnZhciBub29wXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL25vb3AgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9ub29wLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG5mdW5jdGlvbiB3aW5kb3cod2luZG93Qm91bmRhcmllcykge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIHdpbmRvd1N1YmplY3QgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcXG4gICAgICAgIHN1YnNjcmliZXIubmV4dCh3aW5kb3dTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpKTtcXG4gICAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICAgICAgd2luZG93U3ViamVjdC5lcnJvcihlcnIpO1xcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcXG4gICAgICAgIH07XFxuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKE9wZXJhdG9yU3Vic2NyaWJlcl8xLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHdpbmRvd1N1YmplY3QgPT09IG51bGwgfHwgd2luZG93U3ViamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93U3ViamVjdC5uZXh0KHZhbHVlKTsgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHdpbmRvd1N1YmplY3QuY29tcGxldGUoKTtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9LCBlcnJvckhhbmRsZXIpKTtcXG4gICAgICAgIGlubmVyRnJvbV8xLmlubmVyRnJvbSh3aW5kb3dCb3VuZGFyaWVzKS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB3aW5kb3dTdWJqZWN0LmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KCh3aW5kb3dTdWJqZWN0ID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCkpKTtcXG4gICAgICAgIH0sIG5vb3BfMS5ub29wLCBlcnJvckhhbmRsZXIpKTtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgd2luZG93U3ViamVjdCA9PT0gbnVsbCB8fCB3aW5kb3dTdWJqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3dTdWJqZWN0LnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgd2luZG93U3ViamVjdCA9IG51bGw7XFxuICAgICAgICB9O1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy53aW5kb3cgPSB3aW5kb3c7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3cuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3dDb3VudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3dDb3VudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XFxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXFxcIm51bWJlclxcXCIpIHJldHVybiB7XFxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFxcXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlxcXCIgOiBcXFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlxcXCIpO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMud2luZG93Q291bnQgPSB2b2lkIDA7XFxudmFyIFN1YmplY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1N1YmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvU3ViamVjdC5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIE9wZXJhdG9yU3Vic2NyaWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9PcGVyYXRvclN1YnNjcmliZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIHdpbmRvd0NvdW50KHdpbmRvd1NpemUsIHN0YXJ0V2luZG93RXZlcnkpIHtcXG4gICAgaWYgKHN0YXJ0V2luZG93RXZlcnkgPT09IHZvaWQgMCkgeyBzdGFydFdpbmRvd0V2ZXJ5ID0gMDsgfVxcbiAgICB2YXIgc3RhcnRFdmVyeSA9IHN0YXJ0V2luZG93RXZlcnkgPiAwID8gc3RhcnRXaW5kb3dFdmVyeSA6IHdpbmRvd1NpemU7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgd2luZG93cyA9IFtuZXcgU3ViamVjdF8xLlN1YmplY3QoKV07XFxuICAgICAgICB2YXIgc3RhcnRzID0gW107XFxuICAgICAgICB2YXIgY291bnQgPSAwO1xcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KHdpbmRvd3NbMF0uYXNPYnNlcnZhYmxlKCkpO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd2luZG93c18xID0gX192YWx1ZXMod2luZG93cyksIHdpbmRvd3NfMV8xID0gd2luZG93c18xLm5leHQoKTsgIXdpbmRvd3NfMV8xLmRvbmU7IHdpbmRvd3NfMV8xID0gd2luZG93c18xLm5leHQoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRvd18xID0gd2luZG93c18xXzEudmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3dfMS5uZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxcbiAgICAgICAgICAgIGZpbmFsbHkge1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvd3NfMV8xICYmICF3aW5kb3dzXzFfMS5kb25lICYmIChfYSA9IHdpbmRvd3NfMS5yZXR1cm4pKSBfYS5jYWxsKHdpbmRvd3NfMSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgYyA9IGNvdW50IC0gd2luZG93U2l6ZSArIDE7XFxuICAgICAgICAgICAgaWYgKGMgPj0gMCAmJiBjICUgc3RhcnRFdmVyeSA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICB3aW5kb3dzLnNoaWZ0KCkuY29tcGxldGUoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKCsrY291bnQgJSBzdGFydEV2ZXJ5ID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIHZhciB3aW5kb3dfMiA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xcbiAgICAgICAgICAgICAgICB3aW5kb3dzLnB1c2god2luZG93XzIpO1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQod2luZG93XzIuYXNPYnNlcnZhYmxlKCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB3aGlsZSAod2luZG93cy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgIHdpbmRvd3Muc2hpZnQoKS5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICAgICAgd2hpbGUgKHdpbmRvd3MubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgICAgICB3aW5kb3dzLnNoaWZ0KCkuZXJyb3IoZXJyKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHN0YXJ0cyA9IG51bGw7XFxuICAgICAgICAgICAgd2luZG93cyA9IG51bGw7XFxuICAgICAgICB9KSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLndpbmRvd0NvdW50ID0gd2luZG93Q291bnQ7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93Q291bnQuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvd0NvdW50LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvd2luZG93VGltZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvd1RpbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLndpbmRvd1RpbWUgPSB2b2lkIDA7XFxudmFyIFN1YmplY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1N1YmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvU3ViamVjdC5qc1xcXCIpO1xcbnZhciBhc3luY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc2NoZWR1bGVyL2FzeW5jICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9hc3luYy5qc1xcXCIpO1xcbnZhciBTdWJzY3JpcHRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1N1YnNjcmlwdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJzY3JpcHRpb24uanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbnZhciBPcGVyYXRvclN1YnNjcmliZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vT3BlcmF0b3JTdWJzY3JpYmVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanNcXFwiKTtcXG52YXIgYXJyUmVtb3ZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyclJlbW92ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyclJlbW92ZS5qc1xcXCIpO1xcbnZhciBhcmdzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyZ3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9hcmdzLmpzXFxcIik7XFxudmFyIGV4ZWN1dGVTY2hlZHVsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9leGVjdXRlU2NoZWR1bGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9leGVjdXRlU2NoZWR1bGUuanNcXFwiKTtcXG5mdW5jdGlvbiB3aW5kb3dUaW1lKHdpbmRvd1RpbWVTcGFuKSB7XFxuICAgIHZhciBfYSwgX2I7XFxuICAgIHZhciBvdGhlckFyZ3MgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIG90aGVyQXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcXG4gICAgfVxcbiAgICB2YXIgc2NoZWR1bGVyID0gKF9hID0gYXJnc18xLnBvcFNjaGVkdWxlcihvdGhlckFyZ3MpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBhc3luY18xLmFzeW5jU2NoZWR1bGVyO1xcbiAgICB2YXIgd2luZG93Q3JlYXRpb25JbnRlcnZhbCA9IChfYiA9IG90aGVyQXJnc1swXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcXG4gICAgdmFyIG1heFdpbmRvd1NpemUgPSBvdGhlckFyZ3NbMV0gfHwgSW5maW5pdHk7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgd2luZG93UmVjb3JkcyA9IFtdO1xcbiAgICAgICAgdmFyIHJlc3RhcnRPbkNsb3NlID0gZmFsc2U7XFxuICAgICAgICB2YXIgY2xvc2VXaW5kb3cgPSBmdW5jdGlvbiAocmVjb3JkKSB7XFxuICAgICAgICAgICAgdmFyIHdpbmRvdyA9IHJlY29yZC53aW5kb3csIHN1YnMgPSByZWNvcmQuc3VicztcXG4gICAgICAgICAgICB3aW5kb3cuY29tcGxldGUoKTtcXG4gICAgICAgICAgICBzdWJzLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgYXJyUmVtb3ZlXzEuYXJyUmVtb3ZlKHdpbmRvd1JlY29yZHMsIHJlY29yZCk7XFxuICAgICAgICAgICAgcmVzdGFydE9uQ2xvc2UgJiYgc3RhcnRXaW5kb3coKTtcXG4gICAgICAgIH07XFxuICAgICAgICB2YXIgc3RhcnRXaW5kb3cgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKHdpbmRvd1JlY29yZHMpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHN1YnMgPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKCk7XFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuYWRkKHN1YnMpO1xcbiAgICAgICAgICAgICAgICB2YXIgd2luZG93XzEgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcXG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZF8xID0ge1xcbiAgICAgICAgICAgICAgICAgICAgd2luZG93OiB3aW5kb3dfMSxcXG4gICAgICAgICAgICAgICAgICAgIHN1YnM6IHN1YnMsXFxuICAgICAgICAgICAgICAgICAgICBzZWVuOiAwLFxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICB3aW5kb3dSZWNvcmRzLnB1c2gocmVjb3JkXzEpO1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQod2luZG93XzEuYXNPYnNlcnZhYmxlKCkpO1xcbiAgICAgICAgICAgICAgICBleGVjdXRlU2NoZWR1bGVfMS5leGVjdXRlU2NoZWR1bGUoc3Vicywgc2NoZWR1bGVyLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjbG9zZVdpbmRvdyhyZWNvcmRfMSk7IH0sIHdpbmRvd1RpbWVTcGFuKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgICAgaWYgKHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgIT09IG51bGwgJiYgd2luZG93Q3JlYXRpb25JbnRlcnZhbCA+PSAwKSB7XFxuICAgICAgICAgICAgZXhlY3V0ZVNjaGVkdWxlXzEuZXhlY3V0ZVNjaGVkdWxlKHN1YnNjcmliZXIsIHNjaGVkdWxlciwgc3RhcnRXaW5kb3csIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwsIHRydWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgcmVzdGFydE9uQ2xvc2UgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3RhcnRXaW5kb3coKTtcXG4gICAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKGNiKSB7IHJldHVybiB3aW5kb3dSZWNvcmRzLnNsaWNlKCkuZm9yRWFjaChjYik7IH07XFxuICAgICAgICB2YXIgdGVybWluYXRlID0gZnVuY3Rpb24gKGNiKSB7XFxuICAgICAgICAgICAgbG9vcChmdW5jdGlvbiAoX2EpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHdpbmRvdyA9IF9hLndpbmRvdztcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKHdpbmRvdyk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgY2Ioc3Vic2NyaWJlcik7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgfTtcXG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoT3BlcmF0b3JTdWJzY3JpYmVyXzEuY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIGxvb3AoZnVuY3Rpb24gKHJlY29yZCkge1xcbiAgICAgICAgICAgICAgICByZWNvcmQud2luZG93Lm5leHQodmFsdWUpO1xcbiAgICAgICAgICAgICAgICBtYXhXaW5kb3dTaXplIDw9ICsrcmVjb3JkLnNlZW4gJiYgY2xvc2VXaW5kb3cocmVjb3JkKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRlcm1pbmF0ZShmdW5jdGlvbiAoY29uc3VtZXIpIHsgcmV0dXJuIGNvbnN1bWVyLmNvbXBsZXRlKCk7IH0pOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiB0ZXJtaW5hdGUoZnVuY3Rpb24gKGNvbnN1bWVyKSB7IHJldHVybiBjb25zdW1lci5lcnJvcihlcnIpOyB9KTsgfSkpO1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB3aW5kb3dSZWNvcmRzID0gbnVsbDtcXG4gICAgICAgIH07XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLndpbmRvd1RpbWUgPSB3aW5kb3dUaW1lO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvd1RpbWUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvd1RpbWUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3dUb2dnbGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvd1RvZ2dsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XFxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFxcXCJudW1iZXJcXFwiKSByZXR1cm4ge1xcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XFxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcXFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cXFwiIDogXFxcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cXFwiKTtcXG59O1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLndpbmRvd1RvZ2dsZSA9IHZvaWQgMDtcXG52YXIgU3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vU3ViamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJqZWN0LmpzXFxcIik7XFxudmFyIFN1YnNjcmlwdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vU3Vic2NyaXB0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YnNjcmlwdGlvbi5qc1xcXCIpO1xcbnZhciBsaWZ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2xpZnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxudmFyIG5vb3BfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbm9vcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL25vb3AuanNcXFwiKTtcXG52YXIgYXJyUmVtb3ZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyclJlbW92ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyclJlbW92ZS5qc1xcXCIpO1xcbmZ1bmN0aW9uIHdpbmRvd1RvZ2dsZShvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSB7XFxuICAgIHJldHVybiBsaWZ0XzEub3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XFxuICAgICAgICB2YXIgd2luZG93cyA9IFtdO1xcbiAgICAgICAgdmFyIGhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGVycikge1xcbiAgICAgICAgICAgIHdoaWxlICgwIDwgd2luZG93cy5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgd2luZG93cy5zaGlmdCgpLmVycm9yKGVycik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcXG4gICAgICAgIH07XFxuICAgICAgICBpbm5lckZyb21fMS5pbm5lckZyb20ob3BlbmluZ3MpLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKG9wZW5WYWx1ZSkge1xcbiAgICAgICAgICAgIHZhciB3aW5kb3cgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcXG4gICAgICAgICAgICB3aW5kb3dzLnB1c2god2luZG93KTtcXG4gICAgICAgICAgICB2YXIgY2xvc2luZ1N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oKTtcXG4gICAgICAgICAgICB2YXIgY2xvc2VXaW5kb3cgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGFyclJlbW92ZV8xLmFyclJlbW92ZSh3aW5kb3dzLCB3aW5kb3cpO1xcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29tcGxldGUoKTtcXG4gICAgICAgICAgICAgICAgY2xvc2luZ1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgdmFyIGNsb3NpbmdOb3RpZmllcjtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICBjbG9zaW5nTm90aWZpZXIgPSBpbm5lckZyb21fMS5pbm5lckZyb20oY2xvc2luZ1NlbGVjdG9yKG9wZW5WYWx1ZSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHdpbmRvdy5hc09ic2VydmFibGUoKSk7XFxuICAgICAgICAgICAgY2xvc2luZ1N1YnNjcmlwdGlvbi5hZGQoY2xvc2luZ05vdGlmaWVyLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgY2xvc2VXaW5kb3csIG5vb3BfMS5ub29wLCBoYW5kbGVFcnJvcikpKTtcXG4gICAgICAgIH0sIG5vb3BfMS5ub29wKSk7XFxuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKE9wZXJhdG9yU3Vic2NyaWJlcl8xLmNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgICAgICB2YXIgZV8xLCBfYTtcXG4gICAgICAgICAgICB2YXIgd2luZG93c0NvcHkgPSB3aW5kb3dzLnNsaWNlKCk7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd2luZG93c0NvcHlfMSA9IF9fdmFsdWVzKHdpbmRvd3NDb3B5KSwgd2luZG93c0NvcHlfMV8xID0gd2luZG93c0NvcHlfMS5uZXh0KCk7ICF3aW5kb3dzQ29weV8xXzEuZG9uZTsgd2luZG93c0NvcHlfMV8xID0gd2luZG93c0NvcHlfMS5uZXh0KCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aW5kb3dfMSA9IHdpbmRvd3NDb3B5XzFfMS52YWx1ZTtcXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd18xLm5leHQodmFsdWUpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XFxuICAgICAgICAgICAgZmluYWxseSB7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93c0NvcHlfMV8xICYmICF3aW5kb3dzQ29weV8xXzEuZG9uZSAmJiAoX2EgPSB3aW5kb3dzQ29weV8xLnJldHVybikpIF9hLmNhbGwod2luZG93c0NvcHlfMSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB3aGlsZSAoMCA8IHdpbmRvd3MubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIHdpbmRvd3Muc2hpZnQoKS5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9LCBoYW5kbGVFcnJvciwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHdoaWxlICgwIDwgd2luZG93cy5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgd2luZG93cy5zaGlmdCgpLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSkpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy53aW5kb3dUb2dnbGUgPSB3aW5kb3dUb2dnbGU7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93VG9nZ2xlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3dUb2dnbGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3dXaGVuLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvd2luZG93V2hlbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMud2luZG93V2hlbiA9IHZvaWQgMDtcXG52YXIgU3ViamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vU3ViamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJqZWN0LmpzXFxcIik7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG5mdW5jdGlvbiB3aW5kb3dXaGVuKGNsb3NpbmdTZWxlY3Rvcikge1xcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIHdpbmRvdztcXG4gICAgICAgIHZhciBjbG9zaW5nU3Vic2NyaWJlcjtcXG4gICAgICAgIHZhciBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICAgICAgICB3aW5kb3cuZXJyb3IoZXJyKTtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XFxuICAgICAgICB9O1xcbiAgICAgICAgdmFyIG9wZW5XaW5kb3cgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgY2xvc2luZ1N1YnNjcmliZXIgPT09IG51bGwgfHwgY2xvc2luZ1N1YnNjcmliZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3NpbmdTdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgICAgd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgd2luZG93ID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XFxuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHdpbmRvdy5hc09ic2VydmFibGUoKSk7XFxuICAgICAgICAgICAgdmFyIGNsb3NpbmdOb3RpZmllcjtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICBjbG9zaW5nTm90aWZpZXIgPSBpbm5lckZyb21fMS5pbm5lckZyb20oY2xvc2luZ1NlbGVjdG9yKCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY2xvc2luZ05vdGlmaWVyLnN1YnNjcmliZSgoY2xvc2luZ1N1YnNjcmliZXIgPSBPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgb3BlbldpbmRvdywgb3BlbldpbmRvdywgaGFuZGxlRXJyb3IpKSk7XFxuICAgICAgICB9O1xcbiAgICAgICAgb3BlbldpbmRvdygpO1xcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB3aW5kb3cubmV4dCh2YWx1ZSk7IH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB3aW5kb3cuY29tcGxldGUoKTtcXG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICB9LCBoYW5kbGVFcnJvciwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGNsb3NpbmdTdWJzY3JpYmVyID09PSBudWxsIHx8IGNsb3NpbmdTdWJzY3JpYmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zaW5nU3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgIHdpbmRvdyA9IG51bGw7XFxuICAgICAgICB9KSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLndpbmRvd1doZW4gPSB3aW5kb3dXaGVuO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvd1doZW4uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvd1doZW4uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy93aXRoTGF0ZXN0RnJvbS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy93aXRoTGF0ZXN0RnJvbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xcbiAgICBpZiAoIW0pIHJldHVybiBvO1xcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xcbiAgICB9XFxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxcbiAgICBmaW5hbGx5IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXFxcInJldHVyblxcXCJdKSkgbS5jYWxsKGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFyO1xcbn07XFxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcXG4gICAgcmV0dXJuIHRvO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMud2l0aExhdGVzdEZyb20gPSB2b2lkIDA7XFxudmFyIGxpZnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvbGlmdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2xpZnQuanNcXFwiKTtcXG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL09wZXJhdG9yU3Vic2NyaWJlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzXFxcIik7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG52YXIgaWRlbnRpdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaWRlbnRpdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pZGVudGl0eS5qc1xcXCIpO1xcbnZhciBub29wXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL25vb3AgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9ub29wLmpzXFxcIik7XFxudmFyIGFyZ3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvYXJncyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyZ3MuanNcXFwiKTtcXG5mdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbSgpIHtcXG4gICAgdmFyIGlucHV0cyA9IFtdO1xcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgaW5wdXRzW19pXSA9IGFyZ3VtZW50c1tfaV07XFxuICAgIH1cXG4gICAgdmFyIHByb2plY3QgPSBhcmdzXzEucG9wUmVzdWx0U2VsZWN0b3IoaW5wdXRzKTtcXG4gICAgcmV0dXJuIGxpZnRfMS5vcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcXG4gICAgICAgIHZhciBsZW4gPSBpbnB1dHMubGVuZ3RoO1xcbiAgICAgICAgdmFyIG90aGVyVmFsdWVzID0gbmV3IEFycmF5KGxlbik7XFxuICAgICAgICB2YXIgaGFzVmFsdWUgPSBpbnB1dHMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9KTtcXG4gICAgICAgIHZhciByZWFkeSA9IGZhbHNlO1xcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICAgIGlubmVyRnJvbV8xLmlubmVyRnJvbShpbnB1dHNbaV0pLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgICAgIG90aGVyVmFsdWVzW2ldID0gdmFsdWU7XFxuICAgICAgICAgICAgICAgIGlmICghcmVhZHkgJiYgIWhhc1ZhbHVlW2ldKSB7XFxuICAgICAgICAgICAgICAgICAgICBoYXNWYWx1ZVtpXSA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICAocmVhZHkgPSBoYXNWYWx1ZS5ldmVyeShpZGVudGl0eV8xLmlkZW50aXR5KSkgJiYgKGhhc1ZhbHVlID0gbnVsbCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LCBub29wXzEubm9vcCkpO1xcbiAgICAgICAgfTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShPcGVyYXRvclN1YnNjcmliZXJfMS5jcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgaWYgKHJlYWR5KSB7XFxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBfX3NwcmVhZEFycmF5KFt2YWx1ZV0sIF9fcmVhZChvdGhlclZhbHVlcykpO1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQocHJvamVjdCA/IHByb2plY3QuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQodmFsdWVzKSkpIDogdmFsdWVzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLndpdGhMYXRlc3RGcm9tID0gd2l0aExhdGVzdEZyb207XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2l0aExhdGVzdEZyb20uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpdGhMYXRlc3RGcm9tLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvemlwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy96aXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XFxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XFxuICAgIGlmICghbSkgcmV0dXJuIG87XFxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xcbiAgICB0cnkge1xcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XFxuICAgIH1cXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XFxuICAgIGZpbmFsbHkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcXFwicmV0dXJuXFxcIl0pKSBtLmNhbGwoaSk7XFxuICAgICAgICB9XFxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cXG4gICAgfVxcbiAgICByZXR1cm4gYXI7XFxufTtcXG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tKSB7XFxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xcbiAgICByZXR1cm4gdG87XFxufTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy56aXAgPSB2b2lkIDA7XFxudmFyIHppcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS96aXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS96aXAuanNcXFwiKTtcXG52YXIgbGlmdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9saWZ0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbGlmdC5qc1xcXCIpO1xcbmZ1bmN0aW9uIHppcCgpIHtcXG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIHNvdXJjZXNbX2ldID0gYXJndW1lbnRzW19pXTtcXG4gICAgfVxcbiAgICByZXR1cm4gbGlmdF8xLm9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xcbiAgICAgICAgemlwXzEuemlwLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbc291cmNlXSwgX19yZWFkKHNvdXJjZXMpKSkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy56aXAgPSB6aXA7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9emlwLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy96aXAuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy96aXBBbGwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3ppcEFsbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy56aXBBbGwgPSB2b2lkIDA7XFxudmFyIHppcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS96aXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS96aXAuanNcXFwiKTtcXG52YXIgam9pbkFsbEludGVybmFsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qb2luQWxsSW50ZXJuYWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9qb2luQWxsSW50ZXJuYWxzLmpzXFxcIik7XFxuZnVuY3Rpb24gemlwQWxsKHByb2plY3QpIHtcXG4gICAgcmV0dXJuIGpvaW5BbGxJbnRlcm5hbHNfMS5qb2luQWxsSW50ZXJuYWxzKHppcF8xLnppcCwgcHJvamVjdCk7XFxufVxcbmV4cG9ydHMuemlwQWxsID0gemlwQWxsO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcEFsbC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvemlwQWxsLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvemlwV2l0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3ppcFdpdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xcbiAgICBpZiAoIW0pIHJldHVybiBvO1xcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xcbiAgICB9XFxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxcbiAgICBmaW5hbGx5IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXFxcInJldHVyblxcXCJdKSkgbS5jYWxsKGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFyO1xcbn07XFxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcXG4gICAgcmV0dXJuIHRvO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuemlwV2l0aCA9IHZvaWQgMDtcXG52YXIgemlwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ppcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvemlwLmpzXFxcIik7XFxuZnVuY3Rpb24gemlwV2l0aCgpIHtcXG4gICAgdmFyIG90aGVySW5wdXRzID0gW107XFxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICBvdGhlcklucHV0c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHJldHVybiB6aXBfMS56aXAuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQob3RoZXJJbnB1dHMpKSk7XFxufVxcbmV4cG9ydHMuemlwV2l0aCA9IHppcFdpdGg7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9emlwV2l0aC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvemlwV2l0aC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlQXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZUFycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5zY2hlZHVsZUFycmF5ID0gdm9pZCAwO1xcbnZhciBPYnNlcnZhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9PYnNlcnZhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL09ic2VydmFibGUuanNcXFwiKTtcXG5mdW5jdGlvbiBzY2hlZHVsZUFycmF5KGlucHV0LCBzY2hlZHVsZXIpIHtcXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGkgPSAwO1xcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKGkgPT09IGlucHV0Lmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoaW5wdXRbaSsrXSk7XFxuICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG59XFxuZXhwb3J0cy5zY2hlZHVsZUFycmF5ID0gc2NoZWR1bGVBcnJheTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlZHVsZUFycmF5LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZUFycmF5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVBc3luY0l0ZXJhYmxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZUFzeW5jSXRlcmFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuc2NoZWR1bGVBc3luY0l0ZXJhYmxlID0gdm9pZCAwO1xcbnZhciBPYnNlcnZhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9PYnNlcnZhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL09ic2VydmFibGUuanNcXFwiKTtcXG52YXIgZXhlY3V0ZVNjaGVkdWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2V4ZWN1dGVTY2hlZHVsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2V4ZWN1dGVTY2hlZHVsZS5qc1xcXCIpO1xcbmZ1bmN0aW9uIHNjaGVkdWxlQXN5bmNJdGVyYWJsZShpbnB1dCwgc2NoZWR1bGVyKSB7XFxuICAgIGlmICghaW5wdXQpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSXRlcmFibGUgY2Fubm90IGJlIG51bGwnKTtcXG4gICAgfVxcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XFxuICAgICAgICBleGVjdXRlU2NoZWR1bGVfMS5leGVjdXRlU2NoZWR1bGUoc3Vic2NyaWJlciwgc2NoZWR1bGVyLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaW5wdXRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XFxuICAgICAgICAgICAgZXhlY3V0ZVNjaGVkdWxlXzEuZXhlY3V0ZVNjaGVkdWxlKHN1YnNjcmliZXIsIHNjaGVkdWxlciwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQocmVzdWx0LnZhbHVlKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSwgMCwgdHJ1ZSk7XFxuICAgICAgICB9KTtcXG4gICAgfSk7XFxufVxcbmV4cG9ydHMuc2NoZWR1bGVBc3luY0l0ZXJhYmxlID0gc2NoZWR1bGVBc3luY0l0ZXJhYmxlO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVkdWxlQXN5bmNJdGVyYWJsZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVBc3luY0l0ZXJhYmxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVJdGVyYWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlSXRlcmFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnNjaGVkdWxlSXRlcmFibGUgPSB2b2lkIDA7XFxudmFyIE9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbnZhciBpdGVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc3ltYm9sL2l0ZXJhdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3N5bWJvbC9pdGVyYXRvci5qc1xcXCIpO1xcbnZhciBpc0Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzRnVuY3Rpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxudmFyIGV4ZWN1dGVTY2hlZHVsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9leGVjdXRlU2NoZWR1bGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9leGVjdXRlU2NoZWR1bGUuanNcXFwiKTtcXG5mdW5jdGlvbiBzY2hlZHVsZUl0ZXJhYmxlKGlucHV0LCBzY2hlZHVsZXIpIHtcXG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xcbiAgICAgICAgdmFyIGl0ZXJhdG9yO1xcbiAgICAgICAgZXhlY3V0ZVNjaGVkdWxlXzEuZXhlY3V0ZVNjaGVkdWxlKHN1YnNjcmliZXIsIHNjaGVkdWxlciwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gaW5wdXRbaXRlcmF0b3JfMS5pdGVyYXRvcl0oKTtcXG4gICAgICAgICAgICBleGVjdXRlU2NoZWR1bGVfMS5leGVjdXRlU2NoZWR1bGUoc3Vic2NyaWJlciwgc2NoZWR1bGVyLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHZhciBfYTtcXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xcbiAgICAgICAgICAgICAgICB2YXIgZG9uZTtcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGl0ZXJhdG9yLm5leHQoKSwgdmFsdWUgPSBfYS52YWx1ZSwgZG9uZSA9IF9hLmRvbmUpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sIDAsIHRydWUpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oaXRlcmF0b3IgPT09IG51bGwgfHwgaXRlcmF0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZXJhdG9yLnJldHVybikgJiYgaXRlcmF0b3IucmV0dXJuKCk7IH07XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLnNjaGVkdWxlSXRlcmFibGUgPSBzY2hlZHVsZUl0ZXJhYmxlO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVkdWxlSXRlcmFibGUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlSXRlcmFibGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZU9ic2VydmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlT2JzZXJ2YWJsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5zY2hlZHVsZU9ic2VydmFibGUgPSB2b2lkIDA7XFxudmFyIGlubmVyRnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb2JzZXJ2YWJsZS9pbm5lckZyb20uanNcXFwiKTtcXG52YXIgb2JzZXJ2ZU9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vcGVyYXRvcnMvb2JzZXJ2ZU9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9vYnNlcnZlT24uanNcXFwiKTtcXG52YXIgc3Vic2NyaWJlT25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29wZXJhdG9ycy9zdWJzY3JpYmVPbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc3Vic2NyaWJlT24uanNcXFwiKTtcXG5mdW5jdGlvbiBzY2hlZHVsZU9ic2VydmFibGUoaW5wdXQsIHNjaGVkdWxlcikge1xcbiAgICByZXR1cm4gaW5uZXJGcm9tXzEuaW5uZXJGcm9tKGlucHV0KS5waXBlKHN1YnNjcmliZU9uXzEuc3Vic2NyaWJlT24oc2NoZWR1bGVyKSwgb2JzZXJ2ZU9uXzEub2JzZXJ2ZU9uKHNjaGVkdWxlcikpO1xcbn1cXG5leHBvcnRzLnNjaGVkdWxlT2JzZXJ2YWJsZSA9IHNjaGVkdWxlT2JzZXJ2YWJsZTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlZHVsZU9ic2VydmFibGUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlT2JzZXJ2YWJsZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlUHJvbWlzZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVQcm9taXNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnNjaGVkdWxlUHJvbWlzZSA9IHZvaWQgMDtcXG52YXIgaW5uZXJGcm9tXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9vYnNlcnZhYmxlL2lubmVyRnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vYnNlcnZhYmxlL2lubmVyRnJvbS5qc1xcXCIpO1xcbnZhciBvYnNlcnZlT25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL29wZXJhdG9ycy9vYnNlcnZlT24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmVPbi5qc1xcXCIpO1xcbnZhciBzdWJzY3JpYmVPbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb3BlcmF0b3JzL3N1YnNjcmliZU9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zdWJzY3JpYmVPbi5qc1xcXCIpO1xcbmZ1bmN0aW9uIHNjaGVkdWxlUHJvbWlzZShpbnB1dCwgc2NoZWR1bGVyKSB7XFxuICAgIHJldHVybiBpbm5lckZyb21fMS5pbm5lckZyb20oaW5wdXQpLnBpcGUoc3Vic2NyaWJlT25fMS5zdWJzY3JpYmVPbihzY2hlZHVsZXIpLCBvYnNlcnZlT25fMS5vYnNlcnZlT24oc2NoZWR1bGVyKSk7XFxufVxcbmV4cG9ydHMuc2NoZWR1bGVQcm9taXNlID0gc2NoZWR1bGVQcm9taXNlO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVkdWxlUHJvbWlzZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVQcm9taXNlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVSZWFkYWJsZVN0cmVhbUxpa2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVSZWFkYWJsZVN0cmVhbUxpa2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5zY2hlZHVsZVJlYWRhYmxlU3RyZWFtTGlrZSA9IHZvaWQgMDtcXG52YXIgc2NoZWR1bGVBc3luY0l0ZXJhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NjaGVkdWxlQXN5bmNJdGVyYWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVBc3luY0l0ZXJhYmxlLmpzXFxcIik7XFxudmFyIGlzUmVhZGFibGVTdHJlYW1MaWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzUmVhZGFibGVTdHJlYW1MaWtlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNSZWFkYWJsZVN0cmVhbUxpa2UuanNcXFwiKTtcXG5mdW5jdGlvbiBzY2hlZHVsZVJlYWRhYmxlU3RyZWFtTGlrZShpbnB1dCwgc2NoZWR1bGVyKSB7XFxuICAgIHJldHVybiBzY2hlZHVsZUFzeW5jSXRlcmFibGVfMS5zY2hlZHVsZUFzeW5jSXRlcmFibGUoaXNSZWFkYWJsZVN0cmVhbUxpa2VfMS5yZWFkYWJsZVN0cmVhbUxpa2VUb0FzeW5jR2VuZXJhdG9yKGlucHV0KSwgc2NoZWR1bGVyKTtcXG59XFxuZXhwb3J0cy5zY2hlZHVsZVJlYWRhYmxlU3RyZWFtTGlrZSA9IHNjaGVkdWxlUmVhZGFibGVTdHJlYW1MaWtlO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVkdWxlUmVhZGFibGVTdHJlYW1MaWtlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZVJlYWRhYmxlU3RyZWFtTGlrZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnNjaGVkdWxlZCA9IHZvaWQgMDtcXG52YXIgc2NoZWR1bGVPYnNlcnZhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NjaGVkdWxlT2JzZXJ2YWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVPYnNlcnZhYmxlLmpzXFxcIik7XFxudmFyIHNjaGVkdWxlUHJvbWlzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zY2hlZHVsZVByb21pc2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlUHJvbWlzZS5qc1xcXCIpO1xcbnZhciBzY2hlZHVsZUFycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NjaGVkdWxlQXJyYXkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlQXJyYXkuanNcXFwiKTtcXG52YXIgc2NoZWR1bGVJdGVyYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zY2hlZHVsZUl0ZXJhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZUl0ZXJhYmxlLmpzXFxcIik7XFxudmFyIHNjaGVkdWxlQXN5bmNJdGVyYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zY2hlZHVsZUFzeW5jSXRlcmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlQXN5bmNJdGVyYWJsZS5qc1xcXCIpO1xcbnZhciBpc0ludGVyb3BPYnNlcnZhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzSW50ZXJvcE9ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0ludGVyb3BPYnNlcnZhYmxlLmpzXFxcIik7XFxudmFyIGlzUHJvbWlzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc1Byb21pc2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc1Byb21pc2UuanNcXFwiKTtcXG52YXIgaXNBcnJheUxpa2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaXNBcnJheUxpa2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0FycmF5TGlrZS5qc1xcXCIpO1xcbnZhciBpc0l0ZXJhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2lzSXRlcmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0l0ZXJhYmxlLmpzXFxcIik7XFxudmFyIGlzQXN5bmNJdGVyYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc0FzeW5jSXRlcmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0FzeW5jSXRlcmFibGUuanNcXFwiKTtcXG52YXIgdGhyb3dVbm9ic2VydmFibGVFcnJvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC90aHJvd1Vub2JzZXJ2YWJsZUVycm9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvdGhyb3dVbm9ic2VydmFibGVFcnJvci5qc1xcXCIpO1xcbnZhciBpc1JlYWRhYmxlU3RyZWFtTGlrZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9pc1JlYWRhYmxlU3RyZWFtTGlrZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzUmVhZGFibGVTdHJlYW1MaWtlLmpzXFxcIik7XFxudmFyIHNjaGVkdWxlUmVhZGFibGVTdHJlYW1MaWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NjaGVkdWxlUmVhZGFibGVTdHJlYW1MaWtlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZVJlYWRhYmxlU3RyZWFtTGlrZS5qc1xcXCIpO1xcbmZ1bmN0aW9uIHNjaGVkdWxlZChpbnB1dCwgc2NoZWR1bGVyKSB7XFxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XFxuICAgICAgICBpZiAoaXNJbnRlcm9wT2JzZXJ2YWJsZV8xLmlzSW50ZXJvcE9ic2VydmFibGUoaW5wdXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlT2JzZXJ2YWJsZV8xLnNjaGVkdWxlT2JzZXJ2YWJsZShpbnB1dCwgc2NoZWR1bGVyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpc0FycmF5TGlrZV8xLmlzQXJyYXlMaWtlKGlucHV0KSkge1xcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFycmF5XzEuc2NoZWR1bGVBcnJheShpbnB1dCwgc2NoZWR1bGVyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpc1Byb21pc2VfMS5pc1Byb21pc2UoaW5wdXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlUHJvbWlzZV8xLnNjaGVkdWxlUHJvbWlzZShpbnB1dCwgc2NoZWR1bGVyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpc0FzeW5jSXRlcmFibGVfMS5pc0FzeW5jSXRlcmFibGUoaW5wdXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQXN5bmNJdGVyYWJsZV8xLnNjaGVkdWxlQXN5bmNJdGVyYWJsZShpbnB1dCwgc2NoZWR1bGVyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpc0l0ZXJhYmxlXzEuaXNJdGVyYWJsZShpbnB1dCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVJdGVyYWJsZV8xLnNjaGVkdWxlSXRlcmFibGUoaW5wdXQsIHNjaGVkdWxlcik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaXNSZWFkYWJsZVN0cmVhbUxpa2VfMS5pc1JlYWRhYmxlU3RyZWFtTGlrZShpbnB1dCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVSZWFkYWJsZVN0cmVhbUxpa2VfMS5zY2hlZHVsZVJlYWRhYmxlU3RyZWFtTGlrZShpbnB1dCwgc2NoZWR1bGVyKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICB0aHJvdyB0aHJvd1Vub2JzZXJ2YWJsZUVycm9yXzEuY3JlYXRlSW52YWxpZE9ic2VydmFibGVUeXBlRXJyb3IoaW5wdXQpO1xcbn1cXG5leHBvcnRzLnNjaGVkdWxlZCA9IHNjaGVkdWxlZDtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlZHVsZWQuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlZC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL0FjdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvQWN0aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XFxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgYiAhPT0gbnVsbClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDbGFzcyBleHRlbmRzIHZhbHVlIFxcXCIgKyBTdHJpbmcoYikgKyBcXFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcXFwiKTtcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcXG4gICAgfTtcXG59KSgpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLkFjdGlvbiA9IHZvaWQgMDtcXG52YXIgU3Vic2NyaXB0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9TdWJzY3JpcHRpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvU3Vic2NyaXB0aW9uLmpzXFxcIik7XFxudmFyIEFjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XFxuICAgIF9fZXh0ZW5kcyhBY3Rpb24sIF9zdXBlcik7XFxuICAgIGZ1bmN0aW9uIEFjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xcbiAgICB9XFxuICAgIEFjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XFxuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9O1xcbiAgICByZXR1cm4gQWN0aW9uO1xcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XFxuZXhwb3J0cy5BY3Rpb24gPSBBY3Rpb247XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWN0aW9uLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9BY3Rpb24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9BbmltYXRpb25GcmFtZUFjdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9BbmltYXRpb25GcmFtZUFjdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XFxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgYiAhPT0gbnVsbClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDbGFzcyBleHRlbmRzIHZhbHVlIFxcXCIgKyBTdHJpbmcoYikgKyBcXFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcXFwiKTtcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcXG4gICAgfTtcXG59KSgpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLkFuaW1hdGlvbkZyYW1lQWN0aW9uID0gdm9pZCAwO1xcbnZhciBBc3luY0FjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Bc3luY0FjdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvQXN5bmNBY3Rpb24uanNcXFwiKTtcXG52YXIgYW5pbWF0aW9uRnJhbWVQcm92aWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hbmltYXRpb25GcmFtZVByb3ZpZGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9hbmltYXRpb25GcmFtZVByb3ZpZGVyLmpzXFxcIik7XFxudmFyIEFuaW1hdGlvbkZyYW1lQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcXG4gICAgX19leHRlbmRzKEFuaW1hdGlvbkZyYW1lQWN0aW9uLCBfc3VwZXIpO1xcbiAgICBmdW5jdGlvbiBBbmltYXRpb25GcmFtZUFjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNjaGVkdWxlciwgd29yaykgfHwgdGhpcztcXG4gICAgICAgIF90aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcXG4gICAgICAgIF90aGlzLndvcmsgPSB3b3JrO1xcbiAgICAgICAgcmV0dXJuIF90aGlzO1xcbiAgICB9XFxuICAgIEFuaW1hdGlvbkZyYW1lQWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XFxuICAgICAgICBpZiAoZGVsYXkgIT09IG51bGwgJiYgZGVsYXkgPiAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIGlkLCBkZWxheSk7XFxuICAgICAgICB9XFxuICAgICAgICBzY2hlZHVsZXIuYWN0aW9ucy5wdXNoKHRoaXMpO1xcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5fc2NoZWR1bGVkIHx8IChzY2hlZHVsZXIuX3NjaGVkdWxlZCA9IGFuaW1hdGlvbkZyYW1lUHJvdmlkZXJfMS5hbmltYXRpb25GcmFtZVByb3ZpZGVyLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7IHJldHVybiBzY2hlZHVsZXIuZmx1c2godW5kZWZpbmVkKTsgfSkpO1xcbiAgICB9O1xcbiAgICBBbmltYXRpb25GcmFtZUFjdGlvbi5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxcbiAgICAgICAgaWYgKGRlbGF5ICE9IG51bGwgPyBkZWxheSA+IDAgOiB0aGlzLmRlbGF5ID4gMCkge1xcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkLmNhbGwodGhpcywgc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBzY2hlZHVsZXIuYWN0aW9ucztcXG4gICAgICAgIGlmIChpZCAhPSBudWxsICYmICgoX2EgPSBhY3Rpb25zW2FjdGlvbnMubGVuZ3RoIC0gMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZCkgIT09IGlkKSB7XFxuICAgICAgICAgICAgYW5pbWF0aW9uRnJhbWVQcm92aWRlcl8xLmFuaW1hdGlvbkZyYW1lUHJvdmlkZXIuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xcbiAgICAgICAgICAgIHNjaGVkdWxlci5fc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgfTtcXG4gICAgcmV0dXJuIEFuaW1hdGlvbkZyYW1lQWN0aW9uO1xcbn0oQXN5bmNBY3Rpb25fMS5Bc3luY0FjdGlvbikpO1xcbmV4cG9ydHMuQW5pbWF0aW9uRnJhbWVBY3Rpb24gPSBBbmltYXRpb25GcmFtZUFjdGlvbjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1BbmltYXRpb25GcmFtZUFjdGlvbi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvQW5pbWF0aW9uRnJhbWVBY3Rpb24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9BbmltYXRpb25GcmFtZVNjaGVkdWxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9BbmltYXRpb25GcmFtZVNjaGVkdWxlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XFxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgYiAhPT0gbnVsbClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDbGFzcyBleHRlbmRzIHZhbHVlIFxcXCIgKyBTdHJpbmcoYikgKyBcXFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcXFwiKTtcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcXG4gICAgfTtcXG59KSgpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLkFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyID0gdm9pZCAwO1xcbnZhciBBc3luY1NjaGVkdWxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Bc3luY1NjaGVkdWxlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvQXN5bmNTY2hlZHVsZXIuanNcXFwiKTtcXG52YXIgQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xcbiAgICBfX2V4dGVuZHMoQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIsIF9zdXBlcik7XFxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKCkge1xcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xcbiAgICB9XFxuICAgIEFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcXG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XFxuICAgICAgICB2YXIgZmx1c2hJZCA9IHRoaXMuX3NjaGVkdWxlZDtcXG4gICAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IHVuZGVmaW5lZDtcXG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xcbiAgICAgICAgdmFyIGVycm9yO1xcbiAgICAgICAgYWN0aW9uID0gYWN0aW9uIHx8IGFjdGlvbnMuc2hpZnQoKTtcXG4gICAgICAgIGRvIHtcXG4gICAgICAgICAgICBpZiAoKGVycm9yID0gYWN0aW9uLmV4ZWN1dGUoYWN0aW9uLnN0YXRlLCBhY3Rpb24uZGVsYXkpKSkge1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IHdoaWxlICgoYWN0aW9uID0gYWN0aW9uc1swXSkgJiYgYWN0aW9uLmlkID09PSBmbHVzaElkICYmIGFjdGlvbnMuc2hpZnQoKSk7XFxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcXG4gICAgICAgIGlmIChlcnJvcikge1xcbiAgICAgICAgICAgIHdoaWxlICgoYWN0aW9uID0gYWN0aW9uc1swXSkgJiYgYWN0aW9uLmlkID09PSBmbHVzaElkICYmIGFjdGlvbnMuc2hpZnQoKSkge1xcbiAgICAgICAgICAgICAgICBhY3Rpb24udW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIHJldHVybiBBbmltYXRpb25GcmFtZVNjaGVkdWxlcjtcXG59KEFzeW5jU2NoZWR1bGVyXzEuQXN5bmNTY2hlZHVsZXIpKTtcXG5leHBvcnRzLkFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyID0gQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXI7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvQXNhcEFjdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL0FzYXBBY3Rpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XFxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgYiAhPT0gbnVsbClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDbGFzcyBleHRlbmRzIHZhbHVlIFxcXCIgKyBTdHJpbmcoYikgKyBcXFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcXFwiKTtcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcXG4gICAgfTtcXG59KSgpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLkFzYXBBY3Rpb24gPSB2b2lkIDA7XFxudmFyIEFzeW5jQWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0FzeW5jQWN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9Bc3luY0FjdGlvbi5qc1xcXCIpO1xcbnZhciBpbW1lZGlhdGVQcm92aWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbW1lZGlhdGVQcm92aWRlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvaW1tZWRpYXRlUHJvdmlkZXIuanNcXFwiKTtcXG52YXIgQXNhcEFjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XFxuICAgIF9fZXh0ZW5kcyhBc2FwQWN0aW9uLCBfc3VwZXIpO1xcbiAgICBmdW5jdGlvbiBBc2FwQWN0aW9uKHNjaGVkdWxlciwgd29yaykge1xcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2NoZWR1bGVyLCB3b3JrKSB8fCB0aGlzO1xcbiAgICAgICAgX3RoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xcbiAgICAgICAgX3RoaXMud29yayA9IHdvcms7XFxuICAgICAgICByZXR1cm4gX3RoaXM7XFxuICAgIH1cXG4gICAgQXNhcEFjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcXG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxcbiAgICAgICAgaWYgKGRlbGF5ICE9PSBudWxsICYmIGRlbGF5ID4gMCkge1xcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkLmNhbGwodGhpcywgc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2NoZWR1bGVyLmFjdGlvbnMucHVzaCh0aGlzKTtcXG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuX3NjaGVkdWxlZCB8fCAoc2NoZWR1bGVyLl9zY2hlZHVsZWQgPSBpbW1lZGlhdGVQcm92aWRlcl8xLmltbWVkaWF0ZVByb3ZpZGVyLnNldEltbWVkaWF0ZShzY2hlZHVsZXIuZmx1c2guYmluZChzY2hlZHVsZXIsIHVuZGVmaW5lZCkpKTtcXG4gICAgfTtcXG4gICAgQXNhcEFjdGlvbi5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxcbiAgICAgICAgaWYgKGRlbGF5ICE9IG51bGwgPyBkZWxheSA+IDAgOiB0aGlzLmRlbGF5ID4gMCkge1xcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkLmNhbGwodGhpcywgc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBzY2hlZHVsZXIuYWN0aW9ucztcXG4gICAgICAgIGlmIChpZCAhPSBudWxsICYmICgoX2EgPSBhY3Rpb25zW2FjdGlvbnMubGVuZ3RoIC0gMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZCkgIT09IGlkKSB7XFxuICAgICAgICAgICAgaW1tZWRpYXRlUHJvdmlkZXJfMS5pbW1lZGlhdGVQcm92aWRlci5jbGVhckltbWVkaWF0ZShpZCk7XFxuICAgICAgICAgICAgaWYgKHNjaGVkdWxlci5fc2NoZWR1bGVkID09PSBpZCkge1xcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXIuX3NjaGVkdWxlZCA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgICB9O1xcbiAgICByZXR1cm4gQXNhcEFjdGlvbjtcXG59KEFzeW5jQWN0aW9uXzEuQXN5bmNBY3Rpb24pKTtcXG5leHBvcnRzLkFzYXBBY3Rpb24gPSBBc2FwQWN0aW9uO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzYXBBY3Rpb24uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL0FzYXBBY3Rpb24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9Bc2FwU2NoZWR1bGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvQXNhcFNjaGVkdWxlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xcbiAgICB9O1xcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBiICE9PSBudWxsKVxcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXFxcIiArIFN0cmluZyhiKSArIFxcXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFxcXCIpO1xcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xcbiAgICB9O1xcbn0pKCk7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuQXNhcFNjaGVkdWxlciA9IHZvaWQgMDtcXG52YXIgQXN5bmNTY2hlZHVsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vQXN5bmNTY2hlZHVsZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL0FzeW5jU2NoZWR1bGVyLmpzXFxcIik7XFxudmFyIEFzYXBTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xcbiAgICBfX2V4dGVuZHMoQXNhcFNjaGVkdWxlciwgX3N1cGVyKTtcXG4gICAgZnVuY3Rpb24gQXNhcFNjaGVkdWxlcigpIHtcXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcXG4gICAgfVxcbiAgICBBc2FwU2NoZWR1bGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcXG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XFxuICAgICAgICB2YXIgZmx1c2hJZCA9IHRoaXMuX3NjaGVkdWxlZDtcXG4gICAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IHVuZGVmaW5lZDtcXG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xcbiAgICAgICAgdmFyIGVycm9yO1xcbiAgICAgICAgYWN0aW9uID0gYWN0aW9uIHx8IGFjdGlvbnMuc2hpZnQoKTtcXG4gICAgICAgIGRvIHtcXG4gICAgICAgICAgICBpZiAoKGVycm9yID0gYWN0aW9uLmV4ZWN1dGUoYWN0aW9uLnN0YXRlLCBhY3Rpb24uZGVsYXkpKSkge1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IHdoaWxlICgoYWN0aW9uID0gYWN0aW9uc1swXSkgJiYgYWN0aW9uLmlkID09PSBmbHVzaElkICYmIGFjdGlvbnMuc2hpZnQoKSk7XFxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcXG4gICAgICAgIGlmIChlcnJvcikge1xcbiAgICAgICAgICAgIHdoaWxlICgoYWN0aW9uID0gYWN0aW9uc1swXSkgJiYgYWN0aW9uLmlkID09PSBmbHVzaElkICYmIGFjdGlvbnMuc2hpZnQoKSkge1xcbiAgICAgICAgICAgICAgICBhY3Rpb24udW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIHJldHVybiBBc2FwU2NoZWR1bGVyO1xcbn0oQXN5bmNTY2hlZHVsZXJfMS5Bc3luY1NjaGVkdWxlcikpO1xcbmV4cG9ydHMuQXNhcFNjaGVkdWxlciA9IEFzYXBTY2hlZHVsZXI7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNhcFNjaGVkdWxlci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvQXNhcFNjaGVkdWxlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL0FzeW5jQWN0aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL0FzeW5jQWN0aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xcbiAgICB9O1xcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBiICE9PSBudWxsKVxcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXFxcIiArIFN0cmluZyhiKSArIFxcXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFxcXCIpO1xcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xcbiAgICB9O1xcbn0pKCk7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuQXN5bmNBY3Rpb24gPSB2b2lkIDA7XFxudmFyIEFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9BY3Rpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL0FjdGlvbi5qc1xcXCIpO1xcbnZhciBpbnRlcnZhbFByb3ZpZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ludGVydmFsUHJvdmlkZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL2ludGVydmFsUHJvdmlkZXIuanNcXFwiKTtcXG52YXIgYXJyUmVtb3ZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2FyclJlbW92ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyclJlbW92ZS5qc1xcXCIpO1xcbnZhciBBc3luY0FjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XFxuICAgIF9fZXh0ZW5kcyhBc3luY0FjdGlvbiwgX3N1cGVyKTtcXG4gICAgZnVuY3Rpb24gQXN5bmNBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIHdvcmspIHx8IHRoaXM7XFxuICAgICAgICBfdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XFxuICAgICAgICBfdGhpcy53b3JrID0gd29yaztcXG4gICAgICAgIF90aGlzLnBlbmRpbmcgPSBmYWxzZTtcXG4gICAgICAgIHJldHVybiBfdGhpcztcXG4gICAgfVxcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XFxuICAgICAgICB2YXIgX2E7XFxuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cXG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcXG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XFxuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQoc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcXG4gICAgICAgIHRoaXMuaWQgPSAoX2EgPSB0aGlzLmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnJlcXVlc3RBc3luY0lkKHNjaGVkdWxlciwgdGhpcy5pZCwgZGVsYXkpO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH07XFxuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIF9pZCwgZGVsYXkpIHtcXG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxcbiAgICAgICAgcmV0dXJuIGludGVydmFsUHJvdmlkZXJfMS5pbnRlcnZhbFByb3ZpZGVyLnNldEludGVydmFsKHNjaGVkdWxlci5mbHVzaC5iaW5kKHNjaGVkdWxlciwgdGhpcyksIGRlbGF5KTtcXG4gICAgfTtcXG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkID0gZnVuY3Rpb24gKF9zY2hlZHVsZXIsIGlkLCBkZWxheSkge1xcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XFxuICAgICAgICBpZiAoZGVsYXkgIT0gbnVsbCAmJiB0aGlzLmRlbGF5ID09PSBkZWxheSAmJiB0aGlzLnBlbmRpbmcgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGlkO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcXG4gICAgICAgICAgICBpbnRlcnZhbFByb3ZpZGVyXzEuaW50ZXJ2YWxQcm92aWRlci5jbGVhckludGVydmFsKGlkKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICAgIH07XFxuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignZXhlY3V0aW5nIGEgY2FuY2VsbGVkIGFjdGlvbicpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XFxuICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLl9leGVjdXRlKHN0YXRlLCBkZWxheSk7XFxuICAgICAgICBpZiAoZXJyb3IpIHtcXG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmICh0aGlzLnBlbmRpbmcgPT09IGZhbHNlICYmIHRoaXMuaWQgIT0gbnVsbCkge1xcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHRoaXMuc2NoZWR1bGVyLCB0aGlzLmlkLCBudWxsKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBfZGVsYXkpIHtcXG4gICAgICAgIHZhciBlcnJvcmVkID0gZmFsc2U7XFxuICAgICAgICB2YXIgZXJyb3JWYWx1ZTtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgdGhpcy53b3JrKHN0YXRlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XFxuICAgICAgICAgICAgZXJyb3JWYWx1ZSA9IGUgPyBlIDogbmV3IEVycm9yKCdTY2hlZHVsZWQgYWN0aW9uIHRocmV3IGZhbHN5IGVycm9yJyk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZXJyb3JlZCkge1xcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICByZXR1cm4gZXJyb3JWYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NlZCkge1xcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMsIGlkID0gX2EuaWQsIHNjaGVkdWxlciA9IF9hLnNjaGVkdWxlcjtcXG4gICAgICAgICAgICB2YXIgYWN0aW9ucyA9IHNjaGVkdWxlci5hY3Rpb25zO1xcbiAgICAgICAgICAgIHRoaXMud29yayA9IHRoaXMuc3RhdGUgPSB0aGlzLnNjaGVkdWxlciA9IG51bGw7XFxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XFxuICAgICAgICAgICAgYXJyUmVtb3ZlXzEuYXJyUmVtb3ZlKGFjdGlvbnMsIHRoaXMpO1xcbiAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIG51bGwpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB0aGlzLmRlbGF5ID0gbnVsbDtcXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIHJldHVybiBBc3luY0FjdGlvbjtcXG59KEFjdGlvbl8xLkFjdGlvbikpO1xcbmV4cG9ydHMuQXN5bmNBY3Rpb24gPSBBc3luY0FjdGlvbjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY0FjdGlvbi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvQXN5bmNBY3Rpb24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9Bc3luY1NjaGVkdWxlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9Bc3luY1NjaGVkdWxlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XFxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgYiAhPT0gbnVsbClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDbGFzcyBleHRlbmRzIHZhbHVlIFxcXCIgKyBTdHJpbmcoYikgKyBcXFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcXFwiKTtcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcXG4gICAgfTtcXG59KSgpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLkFzeW5jU2NoZWR1bGVyID0gdm9pZCAwO1xcbnZhciBTY2hlZHVsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1NjaGVkdWxlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TY2hlZHVsZXIuanNcXFwiKTtcXG52YXIgQXN5bmNTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xcbiAgICBfX2V4dGVuZHMoQXN5bmNTY2hlZHVsZXIsIF9zdXBlcik7XFxuICAgIGZ1bmN0aW9uIEFzeW5jU2NoZWR1bGVyKFNjaGVkdWxlckFjdGlvbiwgbm93KSB7XFxuICAgICAgICBpZiAobm93ID09PSB2b2lkIDApIHsgbm93ID0gU2NoZWR1bGVyXzEuU2NoZWR1bGVyLm5vdzsgfVxcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgU2NoZWR1bGVyQWN0aW9uLCBub3cpIHx8IHRoaXM7XFxuICAgICAgICBfdGhpcy5hY3Rpb25zID0gW107XFxuICAgICAgICBfdGhpcy5fYWN0aXZlID0gZmFsc2U7XFxuICAgICAgICByZXR1cm4gX3RoaXM7XFxuICAgIH1cXG4gICAgQXN5bmNTY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xcbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XFxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlKSB7XFxuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGVycm9yO1xcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcXG4gICAgICAgIGRvIHtcXG4gICAgICAgICAgICBpZiAoKGVycm9yID0gYWN0aW9uLmV4ZWN1dGUoYWN0aW9uLnN0YXRlLCBhY3Rpb24uZGVsYXkpKSkge1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IHdoaWxlICgoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSk7XFxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcXG4gICAgICAgIGlmIChlcnJvcikge1xcbiAgICAgICAgICAgIHdoaWxlICgoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSkge1xcbiAgICAgICAgICAgICAgICBhY3Rpb24udW5zdWJzY3JpYmUoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIHJldHVybiBBc3luY1NjaGVkdWxlcjtcXG59KFNjaGVkdWxlcl8xLlNjaGVkdWxlcikpO1xcbmV4cG9ydHMuQXN5bmNTY2hlZHVsZXIgPSBBc3luY1NjaGVkdWxlcjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY1NjaGVkdWxlci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvQXN5bmNTY2hlZHVsZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9RdWV1ZUFjdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9RdWV1ZUFjdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XFxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgYiAhPT0gbnVsbClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDbGFzcyBleHRlbmRzIHZhbHVlIFxcXCIgKyBTdHJpbmcoYikgKyBcXFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcXFwiKTtcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcXG4gICAgfTtcXG59KSgpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLlF1ZXVlQWN0aW9uID0gdm9pZCAwO1xcbnZhciBBc3luY0FjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Bc3luY0FjdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvQXN5bmNBY3Rpb24uanNcXFwiKTtcXG52YXIgUXVldWVBY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xcbiAgICBfX2V4dGVuZHMoUXVldWVBY3Rpb24sIF9zdXBlcik7XFxuICAgIGZ1bmN0aW9uIFF1ZXVlQWN0aW9uKHNjaGVkdWxlciwgd29yaykge1xcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2NoZWR1bGVyLCB3b3JrKSB8fCB0aGlzO1xcbiAgICAgICAgX3RoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xcbiAgICAgICAgX3RoaXMud29yayA9IHdvcms7XFxuICAgICAgICByZXR1cm4gX3RoaXM7XFxuICAgIH1cXG4gICAgUXVldWVBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XFxuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc2NoZWR1bGUuY2FsbCh0aGlzLCBzdGF0ZSwgZGVsYXkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIuZmx1c2godGhpcyk7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfTtcXG4gICAgUXVldWVBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XFxuICAgICAgICByZXR1cm4gZGVsYXkgPiAwIHx8IHRoaXMuY2xvc2VkID8gX3N1cGVyLnByb3RvdHlwZS5leGVjdXRlLmNhbGwodGhpcywgc3RhdGUsIGRlbGF5KSA6IHRoaXMuX2V4ZWN1dGUoc3RhdGUsIGRlbGF5KTtcXG4gICAgfTtcXG4gICAgUXVldWVBY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XFxuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cXG4gICAgICAgIGlmICgoZGVsYXkgIT0gbnVsbCAmJiBkZWxheSA+IDApIHx8IChkZWxheSA9PSBudWxsICYmIHRoaXMuZGVsYXkgPiAwKSkge1xcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkLmNhbGwodGhpcywgc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2NoZWR1bGVyLmZsdXNoKHRoaXMpO1xcbiAgICAgICAgcmV0dXJuIDA7XFxuICAgIH07XFxuICAgIHJldHVybiBRdWV1ZUFjdGlvbjtcXG59KEFzeW5jQWN0aW9uXzEuQXN5bmNBY3Rpb24pKTtcXG5leHBvcnRzLlF1ZXVlQWN0aW9uID0gUXVldWVBY3Rpb247XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVldWVBY3Rpb24uanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL1F1ZXVlQWN0aW9uLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvUXVldWVTY2hlZHVsZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvUXVldWVTY2hlZHVsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XFxuICAgIH07XFxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIGIgIT09IG51bGwpXFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcXFwiICsgU3RyaW5nKGIpICsgXFxcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXFxcIik7XFxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XFxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XFxuICAgIH07XFxufSkoKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5RdWV1ZVNjaGVkdWxlciA9IHZvaWQgMDtcXG52YXIgQXN5bmNTY2hlZHVsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vQXN5bmNTY2hlZHVsZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL0FzeW5jU2NoZWR1bGVyLmpzXFxcIik7XFxudmFyIFF1ZXVlU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcXG4gICAgX19leHRlbmRzKFF1ZXVlU2NoZWR1bGVyLCBfc3VwZXIpO1xcbiAgICBmdW5jdGlvbiBRdWV1ZVNjaGVkdWxlcigpIHtcXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcXG4gICAgfVxcbiAgICByZXR1cm4gUXVldWVTY2hlZHVsZXI7XFxufShBc3luY1NjaGVkdWxlcl8xLkFzeW5jU2NoZWR1bGVyKSk7XFxuZXhwb3J0cy5RdWV1ZVNjaGVkdWxlciA9IFF1ZXVlU2NoZWR1bGVyO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVF1ZXVlU2NoZWR1bGVyLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9RdWV1ZVNjaGVkdWxlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL1ZpcnR1YWxUaW1lU2NoZWR1bGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL1ZpcnR1YWxUaW1lU2NoZWR1bGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xcbiAgICB9O1xcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBiICE9PSBudWxsKVxcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXFxcIiArIFN0cmluZyhiKSArIFxcXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFxcXCIpO1xcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xcbiAgICB9O1xcbn0pKCk7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuVmlydHVhbEFjdGlvbiA9IGV4cG9ydHMuVmlydHVhbFRpbWVTY2hlZHVsZXIgPSB2b2lkIDA7XFxudmFyIEFzeW5jQWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0FzeW5jQWN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9Bc3luY0FjdGlvbi5qc1xcXCIpO1xcbnZhciBTdWJzY3JpcHRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1N1YnNjcmlwdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9TdWJzY3JpcHRpb24uanNcXFwiKTtcXG52YXIgQXN5bmNTY2hlZHVsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vQXN5bmNTY2hlZHVsZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL0FzeW5jU2NoZWR1bGVyLmpzXFxcIik7XFxudmFyIFZpcnR1YWxUaW1lU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcXG4gICAgX19leHRlbmRzKFZpcnR1YWxUaW1lU2NoZWR1bGVyLCBfc3VwZXIpO1xcbiAgICBmdW5jdGlvbiBWaXJ0dWFsVGltZVNjaGVkdWxlcihzY2hlZHVsZXJBY3Rpb25DdG9yLCBtYXhGcmFtZXMpIHtcXG4gICAgICAgIGlmIChzY2hlZHVsZXJBY3Rpb25DdG9yID09PSB2b2lkIDApIHsgc2NoZWR1bGVyQWN0aW9uQ3RvciA9IFZpcnR1YWxBY3Rpb247IH1cXG4gICAgICAgIGlmIChtYXhGcmFtZXMgPT09IHZvaWQgMCkgeyBtYXhGcmFtZXMgPSBJbmZpbml0eTsgfVxcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2NoZWR1bGVyQWN0aW9uQ3RvciwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZnJhbWU7IH0pIHx8IHRoaXM7XFxuICAgICAgICBfdGhpcy5tYXhGcmFtZXMgPSBtYXhGcmFtZXM7XFxuICAgICAgICBfdGhpcy5mcmFtZSA9IDA7XFxuICAgICAgICBfdGhpcy5pbmRleCA9IC0xO1xcbiAgICAgICAgcmV0dXJuIF90aGlzO1xcbiAgICB9XFxuICAgIFZpcnR1YWxUaW1lU2NoZWR1bGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGFjdGlvbnMgPSBfYS5hY3Rpb25zLCBtYXhGcmFtZXMgPSBfYS5tYXhGcmFtZXM7XFxuICAgICAgICB2YXIgZXJyb3I7XFxuICAgICAgICB2YXIgYWN0aW9uO1xcbiAgICAgICAgd2hpbGUgKChhY3Rpb24gPSBhY3Rpb25zWzBdKSAmJiBhY3Rpb24uZGVsYXkgPD0gbWF4RnJhbWVzKSB7XFxuICAgICAgICAgICAgYWN0aW9ucy5zaGlmdCgpO1xcbiAgICAgICAgICAgIHRoaXMuZnJhbWUgPSBhY3Rpb24uZGVsYXk7XFxuICAgICAgICAgICAgaWYgKChlcnJvciA9IGFjdGlvbi5leGVjdXRlKGFjdGlvbi5zdGF0ZSwgYWN0aW9uLmRlbGF5KSkpIHtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGVycm9yKSB7XFxuICAgICAgICAgICAgd2hpbGUgKChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpKSB7XFxuICAgICAgICAgICAgICAgIGFjdGlvbi51bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgVmlydHVhbFRpbWVTY2hlZHVsZXIuZnJhbWVUaW1lRmFjdG9yID0gMTA7XFxuICAgIHJldHVybiBWaXJ0dWFsVGltZVNjaGVkdWxlcjtcXG59KEFzeW5jU2NoZWR1bGVyXzEuQXN5bmNTY2hlZHVsZXIpKTtcXG5leHBvcnRzLlZpcnR1YWxUaW1lU2NoZWR1bGVyID0gVmlydHVhbFRpbWVTY2hlZHVsZXI7XFxudmFyIFZpcnR1YWxBY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xcbiAgICBfX2V4dGVuZHMoVmlydHVhbEFjdGlvbiwgX3N1cGVyKTtcXG4gICAgZnVuY3Rpb24gVmlydHVhbEFjdGlvbihzY2hlZHVsZXIsIHdvcmssIGluZGV4KSB7XFxuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IChzY2hlZHVsZXIuaW5kZXggKz0gMSk7IH1cXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNjaGVkdWxlciwgd29yaykgfHwgdGhpcztcXG4gICAgICAgIF90aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcXG4gICAgICAgIF90aGlzLndvcmsgPSB3b3JrO1xcbiAgICAgICAgX3RoaXMuaW5kZXggPSBpbmRleDtcXG4gICAgICAgIF90aGlzLmFjdGl2ZSA9IHRydWU7XFxuICAgICAgICBfdGhpcy5pbmRleCA9IHNjaGVkdWxlci5pbmRleCA9IGluZGV4O1xcbiAgICAgICAgcmV0dXJuIF90aGlzO1xcbiAgICB9XFxuICAgIFZpcnR1YWxBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XFxuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGRlbGF5KSkge1xcbiAgICAgICAgICAgIGlmICghdGhpcy5pZCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5zY2hlZHVsZS5jYWxsKHRoaXMsIHN0YXRlLCBkZWxheSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XFxuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IG5ldyBWaXJ0dWFsQWN0aW9uKHRoaXMuc2NoZWR1bGVyLCB0aGlzLndvcmspO1xcbiAgICAgICAgICAgIHRoaXMuYWRkKGFjdGlvbik7XFxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5zY2hlZHVsZShzdGF0ZSwgZGVsYXkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgVmlydHVhbEFjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcXG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxcbiAgICAgICAgdGhpcy5kZWxheSA9IHNjaGVkdWxlci5mcmFtZSArIGRlbGF5O1xcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBzY2hlZHVsZXIuYWN0aW9ucztcXG4gICAgICAgIGFjdGlvbnMucHVzaCh0aGlzKTtcXG4gICAgICAgIGFjdGlvbnMuc29ydChWaXJ0dWFsQWN0aW9uLnNvcnRBY3Rpb25zKTtcXG4gICAgICAgIHJldHVybiAxO1xcbiAgICB9O1xcbiAgICBWaXJ0dWFsQWN0aW9uLnByb3RvdHlwZS5yZWN5Y2xlQXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgICB9O1xcbiAgICBWaXJ0dWFsQWN0aW9uLnByb3RvdHlwZS5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLl9leGVjdXRlLmNhbGwodGhpcywgc3RhdGUsIGRlbGF5KTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG4gICAgVmlydHVhbEFjdGlvbi5zb3J0QWN0aW9ucyA9IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICBpZiAoYS5kZWxheSA9PT0gYi5kZWxheSkge1xcbiAgICAgICAgICAgIGlmIChhLmluZGV4ID09PSBiLmluZGV4KSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChhLmluZGV4ID4gYi5pbmRleCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChhLmRlbGF5ID4gYi5kZWxheSkge1xcbiAgICAgICAgICAgIHJldHVybiAxO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICByZXR1cm4gVmlydHVhbEFjdGlvbjtcXG59KEFzeW5jQWN0aW9uXzEuQXN5bmNBY3Rpb24pKTtcXG5leHBvcnRzLlZpcnR1YWxBY3Rpb24gPSBWaXJ0dWFsQWN0aW9uO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpcnR1YWxUaW1lU2NoZWR1bGVyLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9WaXJ0dWFsVGltZVNjaGVkdWxlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL2FuaW1hdGlvbkZyYW1lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL2FuaW1hdGlvbkZyYW1lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuYW5pbWF0aW9uRnJhbWUgPSBleHBvcnRzLmFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyID0gdm9pZCAwO1xcbnZhciBBbmltYXRpb25GcmFtZUFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9BbmltYXRpb25GcmFtZUFjdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvQW5pbWF0aW9uRnJhbWVBY3Rpb24uanNcXFwiKTtcXG52YXIgQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLmpzXFxcIik7XFxuZXhwb3J0cy5hbmltYXRpb25GcmFtZVNjaGVkdWxlciA9IG5ldyBBbmltYXRpb25GcmFtZVNjaGVkdWxlcl8xLkFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKEFuaW1hdGlvbkZyYW1lQWN0aW9uXzEuQW5pbWF0aW9uRnJhbWVBY3Rpb24pO1xcbmV4cG9ydHMuYW5pbWF0aW9uRnJhbWUgPSBleHBvcnRzLmFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFuaW1hdGlvbkZyYW1lLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9hbmltYXRpb25GcmFtZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL2FuaW1hdGlvbkZyYW1lUHJvdmlkZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9hbmltYXRpb25GcmFtZVByb3ZpZGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcXG4gICAgaWYgKCFtKSByZXR1cm4gbztcXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XFxuICAgIHRyeSB7XFxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcXG4gICAgfVxcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cXG4gICAgZmluYWxseSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1xcXCJyZXR1cm5cXFwiXSkpIG0uY2FsbChpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxcbiAgICB9XFxuICAgIHJldHVybiBhcjtcXG59O1xcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXFxuICAgICAgICB0b1tqXSA9IGZyb21baV07XFxuICAgIHJldHVybiB0bztcXG59O1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmFuaW1hdGlvbkZyYW1lUHJvdmlkZXIgPSB2b2lkIDA7XFxudmFyIFN1YnNjcmlwdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vU3Vic2NyaXB0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL1N1YnNjcmlwdGlvbi5qc1xcXCIpO1xcbmV4cG9ydHMuYW5pbWF0aW9uRnJhbWVQcm92aWRlciA9IHtcXG4gICAgc2NoZWR1bGU6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xcbiAgICAgICAgdmFyIHJlcXVlc3QgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XFxuICAgICAgICB2YXIgY2FuY2VsID0gY2FuY2VsQW5pbWF0aW9uRnJhbWU7XFxuICAgICAgICB2YXIgZGVsZWdhdGUgPSBleHBvcnRzLmFuaW1hdGlvbkZyYW1lUHJvdmlkZXIuZGVsZWdhdGU7XFxuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcXG4gICAgICAgICAgICByZXF1ZXN0ID0gZGVsZWdhdGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xcbiAgICAgICAgICAgIGNhbmNlbCA9IGRlbGVnYXRlLmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGhhbmRsZSA9IHJlcXVlc3QoZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xcbiAgICAgICAgICAgIGNhbmNlbCA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgICBjYWxsYmFjayh0aW1lc3RhbXApO1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbihmdW5jdGlvbiAoKSB7IHJldHVybiBjYW5jZWwgPT09IG51bGwgfHwgY2FuY2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYW5jZWwoaGFuZGxlKTsgfSk7XFxuICAgIH0sXFxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gZXhwb3J0cy5hbmltYXRpb25GcmFtZVByb3ZpZGVyLmRlbGVnYXRlO1xcbiAgICAgICAgcmV0dXJuICgoZGVsZWdhdGUgPT09IG51bGwgfHwgZGVsZWdhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlbGVnYXRlLnJlcXVlc3RBbmltYXRpb25GcmFtZSkgfHwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKS5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSkpO1xcbiAgICB9LFxcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gZXhwb3J0cy5hbmltYXRpb25GcmFtZVByb3ZpZGVyLmRlbGVnYXRlO1xcbiAgICAgICAgcmV0dXJuICgoZGVsZWdhdGUgPT09IG51bGwgfHwgZGVsZWdhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlbGVnYXRlLmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB8fCBjYW5jZWxBbmltYXRpb25GcmFtZSkuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncykpKTtcXG4gICAgfSxcXG4gICAgZGVsZWdhdGU6IHVuZGVmaW5lZCxcXG59O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFuaW1hdGlvbkZyYW1lUHJvdmlkZXIuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL2FuaW1hdGlvbkZyYW1lUHJvdmlkZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9hc2FwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvYXNhcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuYXNhcCA9IGV4cG9ydHMuYXNhcFNjaGVkdWxlciA9IHZvaWQgMDtcXG52YXIgQXNhcEFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Bc2FwQWN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9Bc2FwQWN0aW9uLmpzXFxcIik7XFxudmFyIEFzYXBTY2hlZHVsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vQXNhcFNjaGVkdWxlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvQXNhcFNjaGVkdWxlci5qc1xcXCIpO1xcbmV4cG9ydHMuYXNhcFNjaGVkdWxlciA9IG5ldyBBc2FwU2NoZWR1bGVyXzEuQXNhcFNjaGVkdWxlcihBc2FwQWN0aW9uXzEuQXNhcEFjdGlvbik7XFxuZXhwb3J0cy5hc2FwID0gZXhwb3J0cy5hc2FwU2NoZWR1bGVyO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzYXAuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL2FzYXAuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9hc3luYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9hc3luYy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmFzeW5jID0gZXhwb3J0cy5hc3luY1NjaGVkdWxlciA9IHZvaWQgMDtcXG52YXIgQXN5bmNBY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vQXN5bmNBY3Rpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL0FzeW5jQWN0aW9uLmpzXFxcIik7XFxudmFyIEFzeW5jU2NoZWR1bGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL0FzeW5jU2NoZWR1bGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9Bc3luY1NjaGVkdWxlci5qc1xcXCIpO1xcbmV4cG9ydHMuYXN5bmNTY2hlZHVsZXIgPSBuZXcgQXN5bmNTY2hlZHVsZXJfMS5Bc3luY1NjaGVkdWxlcihBc3luY0FjdGlvbl8xLkFzeW5jQWN0aW9uKTtcXG5leHBvcnRzLmFzeW5jID0gZXhwb3J0cy5hc3luY1NjaGVkdWxlcjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvYXN5bmMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9kYXRlVGltZXN0YW1wUHJvdmlkZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL2RhdGVUaW1lc3RhbXBQcm92aWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5kYXRlVGltZXN0YW1wUHJvdmlkZXIgPSB2b2lkIDA7XFxuZXhwb3J0cy5kYXRlVGltZXN0YW1wUHJvdmlkZXIgPSB7XFxuICAgIG5vdzogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIChleHBvcnRzLmRhdGVUaW1lc3RhbXBQcm92aWRlci5kZWxlZ2F0ZSB8fCBEYXRlKS5ub3coKTtcXG4gICAgfSxcXG4gICAgZGVsZWdhdGU6IHVuZGVmaW5lZCxcXG59O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGVUaW1lc3RhbXBQcm92aWRlci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvZGF0ZVRpbWVzdGFtcFByb3ZpZGVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvaW1tZWRpYXRlUHJvdmlkZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvaW1tZWRpYXRlUHJvdmlkZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcXG4gICAgaWYgKCFtKSByZXR1cm4gbztcXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XFxuICAgIHRyeSB7XFxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcXG4gICAgfVxcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cXG4gICAgZmluYWxseSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1xcXCJyZXR1cm5cXFwiXSkpIG0uY2FsbChpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxcbiAgICB9XFxuICAgIHJldHVybiBhcjtcXG59O1xcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXFxuICAgICAgICB0b1tqXSA9IGZyb21baV07XFxuICAgIHJldHVybiB0bztcXG59O1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmltbWVkaWF0ZVByb3ZpZGVyID0gdm9pZCAwO1xcbnZhciBJbW1lZGlhdGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvSW1tZWRpYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvSW1tZWRpYXRlLmpzXFxcIik7XFxudmFyIHNldEltbWVkaWF0ZSA9IEltbWVkaWF0ZV8xLkltbWVkaWF0ZS5zZXRJbW1lZGlhdGUsIGNsZWFySW1tZWRpYXRlID0gSW1tZWRpYXRlXzEuSW1tZWRpYXRlLmNsZWFySW1tZWRpYXRlO1xcbmV4cG9ydHMuaW1tZWRpYXRlUHJvdmlkZXIgPSB7XFxuICAgIHNldEltbWVkaWF0ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gZXhwb3J0cy5pbW1lZGlhdGVQcm92aWRlci5kZWxlZ2F0ZTtcXG4gICAgICAgIHJldHVybiAoKGRlbGVnYXRlID09PSBudWxsIHx8IGRlbGVnYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWxlZ2F0ZS5zZXRJbW1lZGlhdGUpIHx8IHNldEltbWVkaWF0ZSkuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncykpKTtcXG4gICAgfSxcXG4gICAgY2xlYXJJbW1lZGlhdGU6IGZ1bmN0aW9uIChoYW5kbGUpIHtcXG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGV4cG9ydHMuaW1tZWRpYXRlUHJvdmlkZXIuZGVsZWdhdGU7XFxuICAgICAgICByZXR1cm4gKChkZWxlZ2F0ZSA9PT0gbnVsbCB8fCBkZWxlZ2F0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVsZWdhdGUuY2xlYXJJbW1lZGlhdGUpIHx8IGNsZWFySW1tZWRpYXRlKShoYW5kbGUpO1xcbiAgICB9LFxcbiAgICBkZWxlZ2F0ZTogdW5kZWZpbmVkLFxcbn07XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1tZWRpYXRlUHJvdmlkZXIuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL2ltbWVkaWF0ZVByb3ZpZGVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvaW50ZXJ2YWxQcm92aWRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL2ludGVydmFsUHJvdmlkZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiXFxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xcbiAgICBpZiAoIW0pIHJldHVybiBvO1xcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xcbiAgICB9XFxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxcbiAgICBmaW5hbGx5IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXFxcInJldHVyblxcXCJdKSkgbS5jYWxsKGkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFyO1xcbn07XFxudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcXG4gICAgcmV0dXJuIHRvO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuaW50ZXJ2YWxQcm92aWRlciA9IHZvaWQgMDtcXG5leHBvcnRzLmludGVydmFsUHJvdmlkZXIgPSB7XFxuICAgIHNldEludGVydmFsOiBmdW5jdGlvbiAoaGFuZGxlciwgdGltZW91dCkge1xcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcXG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XFxuICAgICAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGV4cG9ydHMuaW50ZXJ2YWxQcm92aWRlci5kZWxlZ2F0ZTtcXG4gICAgICAgIGlmIChkZWxlZ2F0ZSA9PT0gbnVsbCB8fCBkZWxlZ2F0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVsZWdhdGUuc2V0SW50ZXJ2YWwpIHtcXG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuc2V0SW50ZXJ2YWwuYXBwbHkoZGVsZWdhdGUsIF9fc3ByZWFkQXJyYXkoW2hhbmRsZXIsIHRpbWVvdXRdLCBfX3JlYWQoYXJncykpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBzZXRJbnRlcnZhbC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW2hhbmRsZXIsIHRpbWVvdXRdLCBfX3JlYWQoYXJncykpKTtcXG4gICAgfSxcXG4gICAgY2xlYXJJbnRlcnZhbDogZnVuY3Rpb24gKGhhbmRsZSkge1xcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gZXhwb3J0cy5pbnRlcnZhbFByb3ZpZGVyLmRlbGVnYXRlO1xcbiAgICAgICAgcmV0dXJuICgoZGVsZWdhdGUgPT09IG51bGwgfHwgZGVsZWdhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlbGVnYXRlLmNsZWFySW50ZXJ2YWwpIHx8IGNsZWFySW50ZXJ2YWwpKGhhbmRsZSk7XFxuICAgIH0sXFxuICAgIGRlbGVnYXRlOiB1bmRlZmluZWQsXFxufTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcnZhbFByb3ZpZGVyLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9pbnRlcnZhbFByb3ZpZGVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvcGVyZm9ybWFuY2VUaW1lc3RhbXBQcm92aWRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL3BlcmZvcm1hbmNlVGltZXN0YW1wUHJvdmlkZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnBlcmZvcm1hbmNlVGltZXN0YW1wUHJvdmlkZXIgPSB2b2lkIDA7XFxuZXhwb3J0cy5wZXJmb3JtYW5jZVRpbWVzdGFtcFByb3ZpZGVyID0ge1xcbiAgICBub3c6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiAoZXhwb3J0cy5wZXJmb3JtYW5jZVRpbWVzdGFtcFByb3ZpZGVyLmRlbGVnYXRlIHx8IHBlcmZvcm1hbmNlKS5ub3coKTtcXG4gICAgfSxcXG4gICAgZGVsZWdhdGU6IHVuZGVmaW5lZCxcXG59O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcmZvcm1hbmNlVGltZXN0YW1wUHJvdmlkZXIuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL3BlcmZvcm1hbmNlVGltZXN0YW1wUHJvdmlkZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9xdWV1ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9xdWV1ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnF1ZXVlID0gZXhwb3J0cy5xdWV1ZVNjaGVkdWxlciA9IHZvaWQgMDtcXG52YXIgUXVldWVBY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vUXVldWVBY3Rpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL1F1ZXVlQWN0aW9uLmpzXFxcIik7XFxudmFyIFF1ZXVlU2NoZWR1bGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1F1ZXVlU2NoZWR1bGVyICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci9RdWV1ZVNjaGVkdWxlci5qc1xcXCIpO1xcbmV4cG9ydHMucXVldWVTY2hlZHVsZXIgPSBuZXcgUXVldWVTY2hlZHVsZXJfMS5RdWV1ZVNjaGVkdWxlcihRdWV1ZUFjdGlvbl8xLlF1ZXVlQWN0aW9uKTtcXG5leHBvcnRzLnF1ZXVlID0gZXhwb3J0cy5xdWV1ZVNjaGVkdWxlcjtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWV1ZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvcXVldWUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3NjaGVkdWxlci90aW1lb3V0UHJvdmlkZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL3RpbWVvdXRQcm92aWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIlxcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcXG4gICAgaWYgKCFtKSByZXR1cm4gbztcXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XFxuICAgIHRyeSB7XFxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcXG4gICAgfVxcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cXG4gICAgZmluYWxseSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1xcXCJyZXR1cm5cXFwiXSkpIG0uY2FsbChpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxcbiAgICB9XFxuICAgIHJldHVybiBhcjtcXG59O1xcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXFxuICAgICAgICB0b1tqXSA9IGZyb21baV07XFxuICAgIHJldHVybiB0bztcXG59O1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnRpbWVvdXRQcm92aWRlciA9IHZvaWQgMDtcXG5leHBvcnRzLnRpbWVvdXRQcm92aWRlciA9IHtcXG4gICAgc2V0VGltZW91dDogZnVuY3Rpb24gKGhhbmRsZXIsIHRpbWVvdXQpIHtcXG4gICAgICAgIHZhciBhcmdzID0gW107XFxuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgZGVsZWdhdGUgPSBleHBvcnRzLnRpbWVvdXRQcm92aWRlci5kZWxlZ2F0ZTtcXG4gICAgICAgIGlmIChkZWxlZ2F0ZSA9PT0gbnVsbCB8fCBkZWxlZ2F0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVsZWdhdGUuc2V0VGltZW91dCkge1xcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5zZXRUaW1lb3V0LmFwcGx5KGRlbGVnYXRlLCBfX3NwcmVhZEFycmF5KFtoYW5kbGVyLCB0aW1lb3V0XSwgX19yZWFkKGFyZ3MpKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gc2V0VGltZW91dC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW2hhbmRsZXIsIHRpbWVvdXRdLCBfX3JlYWQoYXJncykpKTtcXG4gICAgfSxcXG4gICAgY2xlYXJUaW1lb3V0OiBmdW5jdGlvbiAoaGFuZGxlKSB7XFxuICAgICAgICB2YXIgZGVsZWdhdGUgPSBleHBvcnRzLnRpbWVvdXRQcm92aWRlci5kZWxlZ2F0ZTtcXG4gICAgICAgIHJldHVybiAoKGRlbGVnYXRlID09PSBudWxsIHx8IGRlbGVnYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWxlZ2F0ZS5jbGVhclRpbWVvdXQpIHx8IGNsZWFyVGltZW91dCkoaGFuZGxlKTtcXG4gICAgfSxcXG4gICAgZGVsZWdhdGU6IHVuZGVmaW5lZCxcXG59O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVvdXRQcm92aWRlci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zY2hlZHVsZXIvdGltZW91dFByb3ZpZGVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zeW1ib2wvaXRlcmF0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zeW1ib2wvaXRlcmF0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5pdGVyYXRvciA9IGV4cG9ydHMuZ2V0U3ltYm9sSXRlcmF0b3IgPSB2b2lkIDA7XFxuZnVuY3Rpb24gZ2V0U3ltYm9sSXRlcmF0b3IoKSB7XFxuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8ICFTeW1ib2wuaXRlcmF0b3IpIHtcXG4gICAgICAgIHJldHVybiAnQEBpdGVyYXRvcic7XFxuICAgIH1cXG4gICAgcmV0dXJuIFN5bWJvbC5pdGVyYXRvcjtcXG59XFxuZXhwb3J0cy5nZXRTeW1ib2xJdGVyYXRvciA9IGdldFN5bWJvbEl0ZXJhdG9yO1xcbmV4cG9ydHMuaXRlcmF0b3IgPSBnZXRTeW1ib2xJdGVyYXRvcigpO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZXJhdG9yLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3N5bWJvbC9pdGVyYXRvci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc3ltYm9sL29ic2VydmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3N5bWJvbC9vYnNlcnZhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5vYnNlcnZhYmxlID0gdm9pZCAwO1xcbmV4cG9ydHMub2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7IHJldHVybiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wub2JzZXJ2YWJsZSkgfHwgJ0BAb2JzZXJ2YWJsZSc7IH0pKCk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2YWJsZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9zeW1ib2wvb2JzZXJ2YWJsZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdHlwZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3R5cGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdHlwZXMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvciA9IHZvaWQgMDtcXG52YXIgY3JlYXRlRXJyb3JDbGFzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jcmVhdGVFcnJvckNsYXNzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvY3JlYXRlRXJyb3JDbGFzcy5qc1xcXCIpO1xcbmV4cG9ydHMuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSBjcmVhdGVFcnJvckNsYXNzXzEuY3JlYXRlRXJyb3JDbGFzcyhmdW5jdGlvbiAoX3N1cGVyKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiBBcmd1bWVudE91dE9mUmFuZ2VFcnJvckltcGwoKSB7XFxuICAgICAgICBfc3VwZXIodGhpcyk7XFxuICAgICAgICB0aGlzLm5hbWUgPSAnQXJndW1lbnRPdXRPZlJhbmdlRXJyb3InO1xcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gJ2FyZ3VtZW50IG91dCBvZiByYW5nZSc7XFxuICAgIH07XFxufSk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJndW1lbnRPdXRPZlJhbmdlRXJyb3IuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9FbXB0eUVycm9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9FbXB0eUVycm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuRW1wdHlFcnJvciA9IHZvaWQgMDtcXG52YXIgY3JlYXRlRXJyb3JDbGFzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jcmVhdGVFcnJvckNsYXNzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvY3JlYXRlRXJyb3JDbGFzcy5qc1xcXCIpO1xcbmV4cG9ydHMuRW1wdHlFcnJvciA9IGNyZWF0ZUVycm9yQ2xhc3NfMS5jcmVhdGVFcnJvckNsYXNzKGZ1bmN0aW9uIChfc3VwZXIpIHsgcmV0dXJuIGZ1bmN0aW9uIEVtcHR5RXJyb3JJbXBsKCkge1xcbiAgICBfc3VwZXIodGhpcyk7XFxuICAgIHRoaXMubmFtZSA9ICdFbXB0eUVycm9yJztcXG4gICAgdGhpcy5tZXNzYWdlID0gJ25vIGVsZW1lbnRzIGluIHNlcXVlbmNlJztcXG59OyB9KTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbXB0eUVycm9yLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvRW1wdHlFcnJvci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9JbW1lZGlhdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvSW1tZWRpYXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5UZXN0VG9vbHMgPSBleHBvcnRzLkltbWVkaWF0ZSA9IHZvaWQgMDtcXG52YXIgbmV4dEhhbmRsZSA9IDE7XFxudmFyIHJlc29sdmVkO1xcbnZhciBhY3RpdmVIYW5kbGVzID0ge307XFxuZnVuY3Rpb24gZmluZEFuZENsZWFySGFuZGxlKGhhbmRsZSkge1xcbiAgICBpZiAoaGFuZGxlIGluIGFjdGl2ZUhhbmRsZXMpIHtcXG4gICAgICAgIGRlbGV0ZSBhY3RpdmVIYW5kbGVzW2hhbmRsZV07XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgICByZXR1cm4gZmFsc2U7XFxufVxcbmV4cG9ydHMuSW1tZWRpYXRlID0ge1xcbiAgICBzZXRJbW1lZGlhdGU6IGZ1bmN0aW9uIChjYikge1xcbiAgICAgICAgdmFyIGhhbmRsZSA9IG5leHRIYW5kbGUrKztcXG4gICAgICAgIGFjdGl2ZUhhbmRsZXNbaGFuZGxlXSA9IHRydWU7XFxuICAgICAgICBpZiAoIXJlc29sdmVkKSB7XFxuICAgICAgICAgICAgcmVzb2x2ZWQgPSBQcm9taXNlLnJlc29sdmUoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJlc29sdmVkLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZmluZEFuZENsZWFySGFuZGxlKGhhbmRsZSkgJiYgY2IoKTsgfSk7XFxuICAgICAgICByZXR1cm4gaGFuZGxlO1xcbiAgICB9LFxcbiAgICBjbGVhckltbWVkaWF0ZTogZnVuY3Rpb24gKGhhbmRsZSkge1xcbiAgICAgICAgZmluZEFuZENsZWFySGFuZGxlKGhhbmRsZSk7XFxuICAgIH0sXFxufTtcXG5leHBvcnRzLlRlc3RUb29scyA9IHtcXG4gICAgcGVuZGluZzogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGFjdGl2ZUhhbmRsZXMpLmxlbmd0aDtcXG4gICAgfVxcbn07XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1tZWRpYXRlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvSW1tZWRpYXRlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL05vdEZvdW5kRXJyb3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL05vdEZvdW5kRXJyb3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5Ob3RGb3VuZEVycm9yID0gdm9pZCAwO1xcbnZhciBjcmVhdGVFcnJvckNsYXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NyZWF0ZUVycm9yQ2xhc3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9jcmVhdGVFcnJvckNsYXNzLmpzXFxcIik7XFxuZXhwb3J0cy5Ob3RGb3VuZEVycm9yID0gY3JlYXRlRXJyb3JDbGFzc18xLmNyZWF0ZUVycm9yQ2xhc3MoZnVuY3Rpb24gKF9zdXBlcikge1xcbiAgICByZXR1cm4gZnVuY3Rpb24gTm90Rm91bmRFcnJvckltcGwobWVzc2FnZSkge1xcbiAgICAgICAgX3N1cGVyKHRoaXMpO1xcbiAgICAgICAgdGhpcy5uYW1lID0gJ05vdEZvdW5kRXJyb3InO1xcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcXG4gICAgfTtcXG59KTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob3RGb3VuZEVycm9yLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvTm90Rm91bmRFcnJvci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yID0gdm9pZCAwO1xcbnZhciBjcmVhdGVFcnJvckNsYXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NyZWF0ZUVycm9yQ2xhc3MgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9jcmVhdGVFcnJvckNsYXNzLmpzXFxcIik7XFxuZXhwb3J0cy5PYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IGNyZWF0ZUVycm9yQ2xhc3NfMS5jcmVhdGVFcnJvckNsYXNzKGZ1bmN0aW9uIChfc3VwZXIpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIE9iamVjdFVuc3Vic2NyaWJlZEVycm9ySW1wbCgpIHtcXG4gICAgICAgIF9zdXBlcih0aGlzKTtcXG4gICAgICAgIHRoaXMubmFtZSA9ICdPYmplY3RVbnN1YnNjcmliZWRFcnJvcic7XFxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnb2JqZWN0IHVuc3Vic2NyaWJlZCc7XFxuICAgIH07XFxufSk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9TZXF1ZW5jZUVycm9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9TZXF1ZW5jZUVycm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuU2VxdWVuY2VFcnJvciA9IHZvaWQgMDtcXG52YXIgY3JlYXRlRXJyb3JDbGFzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jcmVhdGVFcnJvckNsYXNzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvY3JlYXRlRXJyb3JDbGFzcy5qc1xcXCIpO1xcbmV4cG9ydHMuU2VxdWVuY2VFcnJvciA9IGNyZWF0ZUVycm9yQ2xhc3NfMS5jcmVhdGVFcnJvckNsYXNzKGZ1bmN0aW9uIChfc3VwZXIpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIFNlcXVlbmNlRXJyb3JJbXBsKG1lc3NhZ2UpIHtcXG4gICAgICAgIF9zdXBlcih0aGlzKTtcXG4gICAgICAgIHRoaXMubmFtZSA9ICdTZXF1ZW5jZUVycm9yJztcXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XFxuICAgIH07XFxufSk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VxdWVuY2VFcnJvci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL1NlcXVlbmNlRXJyb3IuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLlVuc3Vic2NyaXB0aW9uRXJyb3IgPSB2b2lkIDA7XFxudmFyIGNyZWF0ZUVycm9yQ2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY3JlYXRlRXJyb3JDbGFzcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2NyZWF0ZUVycm9yQ2xhc3MuanNcXFwiKTtcXG5leHBvcnRzLlVuc3Vic2NyaXB0aW9uRXJyb3IgPSBjcmVhdGVFcnJvckNsYXNzXzEuY3JlYXRlRXJyb3JDbGFzcyhmdW5jdGlvbiAoX3N1cGVyKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbChlcnJvcnMpIHtcXG4gICAgICAgIF9zdXBlcih0aGlzKTtcXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVycm9yc1xcbiAgICAgICAgICAgID8gZXJyb3JzLmxlbmd0aCArIFxcXCIgZXJyb3JzIG9jY3VycmVkIGR1cmluZyB1bnN1YnNjcmlwdGlvbjpcXFxcblxcXCIgKyBlcnJvcnMubWFwKGZ1bmN0aW9uIChlcnIsIGkpIHsgcmV0dXJuIGkgKyAxICsgXFxcIikgXFxcIiArIGVyci50b1N0cmluZygpOyB9KS5qb2luKCdcXFxcbiAgJylcXG4gICAgICAgICAgICA6ICcnO1xcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Vuc3Vic2NyaXB0aW9uRXJyb3InO1xcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XFxuICAgIH07XFxufSk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5zdWJzY3JpcHRpb25FcnJvci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJncy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJncy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnBvcE51bWJlciA9IGV4cG9ydHMucG9wU2NoZWR1bGVyID0gZXhwb3J0cy5wb3BSZXN1bHRTZWxlY3RvciA9IHZvaWQgMDtcXG52YXIgaXNGdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0Z1bmN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNGdW5jdGlvbi5qc1xcXCIpO1xcbnZhciBpc1NjaGVkdWxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1NjaGVkdWxlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzU2NoZWR1bGVyLmpzXFxcIik7XFxuZnVuY3Rpb24gbGFzdChhcnIpIHtcXG4gICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XFxufVxcbmZ1bmN0aW9uIHBvcFJlc3VsdFNlbGVjdG9yKGFyZ3MpIHtcXG4gICAgcmV0dXJuIGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKGxhc3QoYXJncykpID8gYXJncy5wb3AoKSA6IHVuZGVmaW5lZDtcXG59XFxuZXhwb3J0cy5wb3BSZXN1bHRTZWxlY3RvciA9IHBvcFJlc3VsdFNlbGVjdG9yO1xcbmZ1bmN0aW9uIHBvcFNjaGVkdWxlcihhcmdzKSB7XFxuICAgIHJldHVybiBpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKGxhc3QoYXJncykpID8gYXJncy5wb3AoKSA6IHVuZGVmaW5lZDtcXG59XFxuZXhwb3J0cy5wb3BTY2hlZHVsZXIgPSBwb3BTY2hlZHVsZXI7XFxuZnVuY3Rpb24gcG9wTnVtYmVyKGFyZ3MsIGRlZmF1bHRWYWx1ZSkge1xcbiAgICByZXR1cm4gdHlwZW9mIGxhc3QoYXJncykgPT09ICdudW1iZXInID8gYXJncy5wb3AoKSA6IGRlZmF1bHRWYWx1ZTtcXG59XFxuZXhwb3J0cy5wb3BOdW1iZXIgPSBwb3BOdW1iZXI7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJncy5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2FyZ3MuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJnc0FyZ0FycmF5T3JPYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9hcmdzQXJnQXJyYXlPck9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5hcmdzQXJnQXJyYXlPck9iamVjdCA9IHZvaWQgMDtcXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XFxudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIGdldEtleXMgPSBPYmplY3Qua2V5cztcXG5mdW5jdGlvbiBhcmdzQXJnQXJyYXlPck9iamVjdChhcmdzKSB7XFxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xcbiAgICAgICAgdmFyIGZpcnN0XzEgPSBhcmdzWzBdO1xcbiAgICAgICAgaWYgKGlzQXJyYXkoZmlyc3RfMSkpIHtcXG4gICAgICAgICAgICByZXR1cm4geyBhcmdzOiBmaXJzdF8xLCBrZXlzOiBudWxsIH07XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaXNQT0pPKGZpcnN0XzEpKSB7XFxuICAgICAgICAgICAgdmFyIGtleXMgPSBnZXRLZXlzKGZpcnN0XzEpO1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIGFyZ3M6IGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZpcnN0XzFba2V5XTsgfSksXFxuICAgICAgICAgICAgICAgIGtleXM6IGtleXMsXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4geyBhcmdzOiBhcmdzLCBrZXlzOiBudWxsIH07XFxufVxcbmV4cG9ydHMuYXJnc0FyZ0FycmF5T3JPYmplY3QgPSBhcmdzQXJnQXJyYXlPck9iamVjdDtcXG5mdW5jdGlvbiBpc1BPSk8ob2JqKSB7XFxuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gb2JqZWN0UHJvdG87XFxufVxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyZ3NBcmdBcnJheU9yT2JqZWN0LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJnc0FyZ0FycmF5T3JPYmplY3QuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJnc09yQXJnQXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9hcmdzT3JBcmdBcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5hcmdzT3JBcmdBcnJheSA9IHZvaWQgMDtcXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XFxuZnVuY3Rpb24gYXJnc09yQXJnQXJyYXkoYXJncykge1xcbiAgICByZXR1cm4gYXJncy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xcbn1cXG5leHBvcnRzLmFyZ3NPckFyZ0FycmF5ID0gYXJnc09yQXJnQXJyYXk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJnc09yQXJnQXJyYXkuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9hcmdzT3JBcmdBcnJheS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9hcnJSZW1vdmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJyUmVtb3ZlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5hcnJSZW1vdmUgPSB2b2lkIDA7XFxuZnVuY3Rpb24gYXJyUmVtb3ZlKGFyciwgaXRlbSkge1xcbiAgICBpZiAoYXJyKSB7XFxuICAgICAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcXG4gICAgICAgIDAgPD0gaW5kZXggJiYgYXJyLnNwbGljZShpbmRleCwgMSk7XFxuICAgIH1cXG59XFxuZXhwb3J0cy5hcnJSZW1vdmUgPSBhcnJSZW1vdmU7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyUmVtb3ZlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvYXJyUmVtb3ZlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2NyZWF0ZUVycm9yQ2xhc3MuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2NyZWF0ZUVycm9yQ2xhc3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5jcmVhdGVFcnJvckNsYXNzID0gdm9pZCAwO1xcbmZ1bmN0aW9uIGNyZWF0ZUVycm9yQ2xhc3MoY3JlYXRlSW1wbCkge1xcbiAgICB2YXIgX3N1cGVyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XFxuICAgICAgICBFcnJvci5jYWxsKGluc3RhbmNlKTtcXG4gICAgICAgIGluc3RhbmNlLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XFxuICAgIH07XFxuICAgIHZhciBjdG9yRnVuYyA9IGNyZWF0ZUltcGwoX3N1cGVyKTtcXG4gICAgY3RvckZ1bmMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xcbiAgICBjdG9yRnVuYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yRnVuYztcXG4gICAgcmV0dXJuIGN0b3JGdW5jO1xcbn1cXG5leHBvcnRzLmNyZWF0ZUVycm9yQ2xhc3MgPSBjcmVhdGVFcnJvckNsYXNzO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUVycm9yQ2xhc3MuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9jcmVhdGVFcnJvckNsYXNzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2NyZWF0ZU9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9jcmVhdGVPYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmNyZWF0ZU9iamVjdCA9IHZvaWQgMDtcXG5mdW5jdGlvbiBjcmVhdGVPYmplY3Qoa2V5cywgdmFsdWVzKSB7XFxuICAgIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXksIGkpIHsgcmV0dXJuICgocmVzdWx0W2tleV0gPSB2YWx1ZXNbaV0pLCByZXN1bHQpOyB9LCB7fSk7XFxufVxcbmV4cG9ydHMuY3JlYXRlT2JqZWN0ID0gY3JlYXRlT2JqZWN0O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZU9iamVjdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2NyZWF0ZU9iamVjdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9lcnJvckNvbnRleHQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvZXJyb3JDb250ZXh0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5jYXB0dXJlRXJyb3IgPSBleHBvcnRzLmVycm9yQ29udGV4dCA9IHZvaWQgMDtcXG52YXIgY29uZmlnXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jb25maWcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvY29uZmlnLmpzXFxcIik7XFxudmFyIGNvbnRleHQgPSBudWxsO1xcbmZ1bmN0aW9uIGVycm9yQ29udGV4dChjYikge1xcbiAgICBpZiAoY29uZmlnXzEuY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcXG4gICAgICAgIHZhciBpc1Jvb3QgPSAhY29udGV4dDtcXG4gICAgICAgIGlmIChpc1Jvb3QpIHtcXG4gICAgICAgICAgICBjb250ZXh0ID0geyBlcnJvclRocm93bjogZmFsc2UsIGVycm9yOiBudWxsIH07XFxuICAgICAgICB9XFxuICAgICAgICBjYigpO1xcbiAgICAgICAgaWYgKGlzUm9vdCkge1xcbiAgICAgICAgICAgIHZhciBfYSA9IGNvbnRleHQsIGVycm9yVGhyb3duID0gX2EuZXJyb3JUaHJvd24sIGVycm9yID0gX2EuZXJyb3I7XFxuICAgICAgICAgICAgY29udGV4dCA9IG51bGw7XFxuICAgICAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBlbHNlIHtcXG4gICAgICAgIGNiKCk7XFxuICAgIH1cXG59XFxuZXhwb3J0cy5lcnJvckNvbnRleHQgPSBlcnJvckNvbnRleHQ7XFxuZnVuY3Rpb24gY2FwdHVyZUVycm9yKGVycikge1xcbiAgICBpZiAoY29uZmlnXzEuY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgJiYgY29udGV4dCkge1xcbiAgICAgICAgY29udGV4dC5lcnJvclRocm93biA9IHRydWU7XFxuICAgICAgICBjb250ZXh0LmVycm9yID0gZXJyO1xcbiAgICB9XFxufVxcbmV4cG9ydHMuY2FwdHVyZUVycm9yID0gY2FwdHVyZUVycm9yO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yQ29udGV4dC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2Vycm9yQ29udGV4dC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9leGVjdXRlU2NoZWR1bGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvZXhlY3V0ZVNjaGVkdWxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5leGVjdXRlU2NoZWR1bGUgPSB2b2lkIDA7XFxuZnVuY3Rpb24gZXhlY3V0ZVNjaGVkdWxlKHBhcmVudFN1YnNjcmlwdGlvbiwgc2NoZWR1bGVyLCB3b3JrLCBkZWxheSwgcmVwZWF0KSB7XFxuICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxcbiAgICBpZiAocmVwZWF0ID09PSB2b2lkIDApIHsgcmVwZWF0ID0gZmFsc2U7IH1cXG4gICAgdmFyIHNjaGVkdWxlU3Vic2NyaXB0aW9uID0gc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHdvcmsoKTtcXG4gICAgICAgIGlmIChyZXBlYXQpIHtcXG4gICAgICAgICAgICBwYXJlbnRTdWJzY3JpcHRpb24uYWRkKHRoaXMuc2NoZWR1bGUobnVsbCwgZGVsYXkpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcXG4gICAgICAgIH1cXG4gICAgfSwgZGVsYXkpO1xcbiAgICBwYXJlbnRTdWJzY3JpcHRpb24uYWRkKHNjaGVkdWxlU3Vic2NyaXB0aW9uKTtcXG4gICAgaWYgKCFyZXBlYXQpIHtcXG4gICAgICAgIHJldHVybiBzY2hlZHVsZVN1YnNjcmlwdGlvbjtcXG4gICAgfVxcbn1cXG5leHBvcnRzLmV4ZWN1dGVTY2hlZHVsZSA9IGV4ZWN1dGVTY2hlZHVsZTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGVjdXRlU2NoZWR1bGUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9leGVjdXRlU2NoZWR1bGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaWRlbnRpdHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pZGVudGl0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5pZGVudGl0eSA9IHZvaWQgMDtcXG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XFxuICAgIHJldHVybiB4O1xcbn1cXG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWRlbnRpdHkuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pZGVudGl0eS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0FycmF5TGlrZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzQXJyYXlMaWtlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmlzQXJyYXlMaWtlID0gdm9pZCAwO1xcbmV4cG9ydHMuaXNBcnJheUxpa2UgPSAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgdHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeCAhPT0gJ2Z1bmN0aW9uJzsgfSk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBcnJheUxpa2UuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0FycmF5TGlrZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0FzeW5jSXRlcmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNBc3luY0l0ZXJhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5pc0FzeW5jSXRlcmFibGUgPSB2b2lkIDA7XFxudmFyIGlzRnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG5mdW5jdGlvbiBpc0FzeW5jSXRlcmFibGUob2JqKSB7XFxuICAgIHJldHVybiBTeW1ib2wuYXN5bmNJdGVyYXRvciAmJiBpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKTtcXG59XFxuZXhwb3J0cy5pc0FzeW5jSXRlcmFibGUgPSBpc0FzeW5jSXRlcmFibGU7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBc3luY0l0ZXJhYmxlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNBc3luY0l0ZXJhYmxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRGF0ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0RhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmlzVmFsaWREYXRlID0gdm9pZCAwO1xcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKHZhbHVlKSB7XFxuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKHZhbHVlKTtcXG59XFxuZXhwb3J0cy5pc1ZhbGlkRGF0ZSA9IGlzVmFsaWREYXRlO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzRGF0ZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRGF0ZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IHZvaWQgMDtcXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XFxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XFxufVxcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNGdW5jdGlvbi5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNJbnRlcm9wT2JzZXJ2YWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNJbnRlcm9wT2JzZXJ2YWJsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmlzSW50ZXJvcE9ic2VydmFibGUgPSB2b2lkIDA7XFxudmFyIG9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3N5bWJvbC9vYnNlcnZhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3N5bWJvbC9vYnNlcnZhYmxlLmpzXFxcIik7XFxudmFyIGlzRnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG5mdW5jdGlvbiBpc0ludGVyb3BPYnNlcnZhYmxlKGlucHV0KSB7XFxuICAgIHJldHVybiBpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihpbnB1dFtvYnNlcnZhYmxlXzEub2JzZXJ2YWJsZV0pO1xcbn1cXG5leHBvcnRzLmlzSW50ZXJvcE9ic2VydmFibGUgPSBpc0ludGVyb3BPYnNlcnZhYmxlO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzSW50ZXJvcE9ic2VydmFibGUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0ludGVyb3BPYnNlcnZhYmxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzSXRlcmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzSXRlcmFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5pc0l0ZXJhYmxlID0gdm9pZCAwO1xcbnZhciBpdGVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc3ltYm9sL2l0ZXJhdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3N5bWJvbC9pdGVyYXRvci5qc1xcXCIpO1xcbnZhciBpc0Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzRnVuY3Rpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxuZnVuY3Rpb24gaXNJdGVyYWJsZShpbnB1dCkge1xcbiAgICByZXR1cm4gaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0W2l0ZXJhdG9yXzEuaXRlcmF0b3JdKTtcXG59XFxuZXhwb3J0cy5pc0l0ZXJhYmxlID0gaXNJdGVyYWJsZTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0l0ZXJhYmxlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNJdGVyYWJsZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc09ic2VydmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNPYnNlcnZhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5pc09ic2VydmFibGUgPSB2b2lkIDA7XFxudmFyIE9ic2VydmFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL09ic2VydmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qc1xcXCIpO1xcbnZhciBpc0Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzRnVuY3Rpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzXFxcIik7XFxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlKG9iaikge1xcbiAgICByZXR1cm4gISFvYmogJiYgKG9iaiBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlIHx8IChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihvYmoubGlmdCkgJiYgaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24ob2JqLnN1YnNjcmliZSkpKTtcXG59XFxuZXhwb3J0cy5pc09ic2VydmFibGUgPSBpc09ic2VydmFibGU7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNPYnNlcnZhYmxlLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNPYnNlcnZhYmxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzUHJvbWlzZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc1Byb21pc2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmlzUHJvbWlzZSA9IHZvaWQgMDtcXG52YXIgaXNGdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0Z1bmN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNGdW5jdGlvbi5qc1xcXCIpO1xcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xcbiAgICByZXR1cm4gaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24odmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnRoZW4pO1xcbn1cXG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1Byb21pc2UuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc1Byb21pc2UuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNSZWFkYWJsZVN0cmVhbUxpa2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc1JlYWRhYmxlU3RyZWFtTGlrZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XFxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XFxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcXFwidGhyb3dcXFwiOiB2ZXJiKDEpLCBcXFwicmV0dXJuXFxcIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cXFwiKTtcXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXFxcInJldHVyblxcXCJdIDogb3BbMF0gPyB5W1xcXCJ0aHJvd1xcXCJdIHx8ICgodCA9IHlbXFxcInJldHVyblxcXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XFxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XFxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XFxuICAgIH1cXG59O1xcbnZhciBfX2F3YWl0ID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0KSB8fCBmdW5jdGlvbiAodikgeyByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTsgfVxcbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jR2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XFxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlxcXCIpO1xcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFxcXCJuZXh0XFxcIiksIHZlcmIoXFxcInRocm93XFxcIiksIHZlcmIoXFxcInJldHVyblxcXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XFxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XFxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcXFwibmV4dFxcXCIsIHZhbHVlKTsgfVxcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFxcXCJ0aHJvd1xcXCIsIHZhbHVlKTsgfVxcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XFxufTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5pc1JlYWRhYmxlU3RyZWFtTGlrZSA9IGV4cG9ydHMucmVhZGFibGVTdHJlYW1MaWtlVG9Bc3luY0dlbmVyYXRvciA9IHZvaWQgMDtcXG52YXIgaXNGdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0Z1bmN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNGdW5jdGlvbi5qc1xcXCIpO1xcbmZ1bmN0aW9uIHJlYWRhYmxlU3RyZWFtTGlrZVRvQXN5bmNHZW5lcmF0b3IocmVhZGFibGVTdHJlYW0pIHtcXG4gICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiByZWFkYWJsZVN0cmVhbUxpa2VUb0FzeW5jR2VuZXJhdG9yXzEoKSB7XFxuICAgICAgICB2YXIgcmVhZGVyLCBfYSwgdmFsdWUsIGRvbmU7XFxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xcbiAgICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcXG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxLCAsIDksIDEwXSk7XFxuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XFxuICAgICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSkge31cXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgX19hd2FpdChyZWFkZXIucmVhZCgpKV07XFxuICAgICAgICAgICAgICAgIGNhc2UgMzpcXG4gICAgICAgICAgICAgICAgICAgIF9hID0gX2Iuc2VudCgpLCB2YWx1ZSA9IF9hLnZhbHVlLCBkb25lID0gX2EuZG9uZTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9uZSkgcmV0dXJuIFszLCA1XTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgX19hd2FpdCh2b2lkIDApXTtcXG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIsIF9iLnNlbnQoKV07XFxuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFs0LCBfX2F3YWl0KHZhbHVlKV07XFxuICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFs0LCBfYi5zZW50KCldO1xcbiAgICAgICAgICAgICAgICBjYXNlIDc6XFxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDJdO1xcbiAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMywgMTBdO1xcbiAgICAgICAgICAgICAgICBjYXNlIDk6XFxuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbN107XFxuICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMl07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLnJlYWRhYmxlU3RyZWFtTGlrZVRvQXN5bmNHZW5lcmF0b3IgPSByZWFkYWJsZVN0cmVhbUxpa2VUb0FzeW5jR2VuZXJhdG9yO1xcbmZ1bmN0aW9uIGlzUmVhZGFibGVTdHJlYW1MaWtlKG9iaikge1xcbiAgICByZXR1cm4gaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24ob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLmdldFJlYWRlcik7XFxufVxcbmV4cG9ydHMuaXNSZWFkYWJsZVN0cmVhbUxpa2UgPSBpc1JlYWRhYmxlU3RyZWFtTGlrZTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1JlYWRhYmxlU3RyZWFtTGlrZS5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzUmVhZGFibGVTdHJlYW1MaWtlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzU2NoZWR1bGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNTY2hlZHVsZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuaXNTY2hlZHVsZXIgPSB2b2lkIDA7XFxudmFyIGlzRnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNGdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanNcXFwiKTtcXG5mdW5jdGlvbiBpc1NjaGVkdWxlcih2YWx1ZSkge1xcbiAgICByZXR1cm4gdmFsdWUgJiYgaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24odmFsdWUuc2NoZWR1bGUpO1xcbn1cXG5leHBvcnRzLmlzU2NoZWR1bGVyID0gaXNTY2hlZHVsZXI7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNTY2hlZHVsZXIuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pc1NjaGVkdWxlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMub3BlcmF0ZSA9IGV4cG9ydHMuaGFzTGlmdCA9IHZvaWQgMDtcXG52YXIgaXNGdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0Z1bmN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvaXNGdW5jdGlvbi5qc1xcXCIpO1xcbmZ1bmN0aW9uIGhhc0xpZnQoc291cmNlKSB7XFxuICAgIHJldHVybiBpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2UubGlmdCk7XFxufVxcbmV4cG9ydHMuaGFzTGlmdCA9IGhhc0xpZnQ7XFxuZnVuY3Rpb24gb3BlcmF0ZShpbml0KSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XFxuICAgICAgICBpZiAoaGFzTGlmdChzb3VyY2UpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KGZ1bmN0aW9uIChsaWZ0ZWRTb3VyY2UpIHtcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0KGxpZnRlZFNvdXJjZSwgdGhpcyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmFibGUgdG8gbGlmdCB1bmtub3duIE9ic2VydmFibGUgdHlwZScpO1xcbiAgICB9O1xcbn1cXG5leHBvcnRzLm9wZXJhdGUgPSBvcGVyYXRlO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpZnQuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9saWZ0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL21hcE9uZU9yTWFueUFyZ3MuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL21hcE9uZU9yTWFueUFyZ3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIlxcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcXG4gICAgaWYgKCFtKSByZXR1cm4gbztcXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XFxuICAgIHRyeSB7XFxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcXG4gICAgfVxcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cXG4gICAgZmluYWxseSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1xcXCJyZXR1cm5cXFwiXSkpIG0uY2FsbChpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxcbiAgICB9XFxuICAgIHJldHVybiBhcjtcXG59O1xcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXFxuICAgICAgICB0b1tqXSA9IGZyb21baV07XFxuICAgIHJldHVybiB0bztcXG59O1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLm1hcE9uZU9yTWFueUFyZ3MgPSB2b2lkIDA7XFxudmFyIG1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vb3BlcmF0b3JzL21hcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWFwLmpzXFxcIik7XFxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xcbmZ1bmN0aW9uIGNhbGxPckFwcGx5KGZuLCBhcmdzKSB7XFxuICAgIHJldHVybiBpc0FycmF5KGFyZ3MpID8gZm4uYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncykpKSA6IGZuKGFyZ3MpO1xcbn1cXG5mdW5jdGlvbiBtYXBPbmVPck1hbnlBcmdzKGZuKSB7XFxuICAgIHJldHVybiBtYXBfMS5tYXAoZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGNhbGxPckFwcGx5KGZuLCBhcmdzKTsgfSk7XFxufVxcbmV4cG9ydHMubWFwT25lT3JNYW55QXJncyA9IG1hcE9uZU9yTWFueUFyZ3M7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwT25lT3JNYW55QXJncy5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL21hcE9uZU9yTWFueUFyZ3MuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbm9vcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbm9vcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLm5vb3AgPSB2b2lkIDA7XFxuZnVuY3Rpb24gbm9vcCgpIHsgfVxcbmV4cG9ydHMubm9vcCA9IG5vb3A7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9vcC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL25vb3AuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvbm90LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL25vdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMubm90ID0gdm9pZCAwO1xcbmZ1bmN0aW9uIG5vdChwcmVkLCB0aGlzQXJnKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7IHJldHVybiAhcHJlZC5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCk7IH07XFxufVxcbmV4cG9ydHMubm90ID0gbm90O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdC5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL25vdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9waXBlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9waXBlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMucGlwZUZyb21BcnJheSA9IGV4cG9ydHMucGlwZSA9IHZvaWQgMDtcXG52YXIgaWRlbnRpdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaWRlbnRpdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9pZGVudGl0eS5qc1xcXCIpO1xcbmZ1bmN0aW9uIHBpcGUoKSB7XFxuICAgIHZhciBmbnMgPSBbXTtcXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIGZuc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xcbiAgICB9XFxuICAgIHJldHVybiBwaXBlRnJvbUFycmF5KGZucyk7XFxufVxcbmV4cG9ydHMucGlwZSA9IHBpcGU7XFxuZnVuY3Rpb24gcGlwZUZyb21BcnJheShmbnMpIHtcXG4gICAgaWYgKGZucy5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIHJldHVybiBpZGVudGl0eV8xLmlkZW50aXR5O1xcbiAgICB9XFxuICAgIGlmIChmbnMubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICByZXR1cm4gZm5zWzBdO1xcbiAgICB9XFxuICAgIHJldHVybiBmdW5jdGlvbiBwaXBlZChpbnB1dCkge1xcbiAgICAgICAgcmV0dXJuIGZucy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGZuKSB7IHJldHVybiBmbihwcmV2KTsgfSwgaW5wdXQpO1xcbiAgICB9O1xcbn1cXG5leHBvcnRzLnBpcGVGcm9tQXJyYXkgPSBwaXBlRnJvbUFycmF5O1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBpcGUuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9waXBlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL3JlcG9ydFVuaGFuZGxlZEVycm9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL3V0aWwvcmVwb3J0VW5oYW5kbGVkRXJyb3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMucmVwb3J0VW5oYW5kbGVkRXJyb3IgPSB2b2lkIDA7XFxudmFyIGNvbmZpZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY29uZmlnICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL2NvbmZpZy5qc1xcXCIpO1xcbnZhciB0aW1lb3V0UHJvdmlkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3NjaGVkdWxlci90aW1lb3V0UHJvdmlkZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvc2NoZWR1bGVyL3RpbWVvdXRQcm92aWRlci5qc1xcXCIpO1xcbmZ1bmN0aW9uIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycikge1xcbiAgICB0aW1lb3V0UHJvdmlkZXJfMS50aW1lb3V0UHJvdmlkZXIuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgb25VbmhhbmRsZWRFcnJvciA9IGNvbmZpZ18xLmNvbmZpZy5vblVuaGFuZGxlZEVycm9yO1xcbiAgICAgICAgaWYgKG9uVW5oYW5kbGVkRXJyb3IpIHtcXG4gICAgICAgICAgICBvblVuaGFuZGxlZEVycm9yKGVycik7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICB0aHJvdyBlcnI7XFxuICAgICAgICB9XFxuICAgIH0pO1xcbn1cXG5leHBvcnRzLnJlcG9ydFVuaGFuZGxlZEVycm9yID0gcmVwb3J0VW5oYW5kbGVkRXJyb3I7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwb3J0VW5oYW5kbGVkRXJyb3IuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC9yZXBvcnRVbmhhbmRsZWRFcnJvci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC90aHJvd1Vub2JzZXJ2YWJsZUVycm9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvdXRpbC90aHJvd1Vub2JzZXJ2YWJsZUVycm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuY3JlYXRlSW52YWxpZE9ic2VydmFibGVUeXBlRXJyb3IgPSB2b2lkIDA7XFxuZnVuY3Rpb24gY3JlYXRlSW52YWxpZE9ic2VydmFibGVUeXBlRXJyb3IoaW5wdXQpIHtcXG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXFxcIllvdSBwcm92aWRlZCBcXFwiICsgKGlucHV0ICE9PSBudWxsICYmIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgPyAnYW4gaW52YWxpZCBvYmplY3QnIDogXFxcIidcXFwiICsgaW5wdXQgKyBcXFwiJ1xcXCIpICsgXFxcIiB3aGVyZSBhIHN0cmVhbSB3YXMgZXhwZWN0ZWQuIFlvdSBjYW4gcHJvdmlkZSBhbiBPYnNlcnZhYmxlLCBQcm9taXNlLCBSZWFkYWJsZVN0cmVhbSwgQXJyYXksIEFzeW5jSXRlcmFibGUsIG9yIEl0ZXJhYmxlLlxcXCIpO1xcbn1cXG5leHBvcnRzLmNyZWF0ZUludmFsaWRPYnNlcnZhYmxlVHlwZUVycm9yID0gY3JlYXRlSW52YWxpZE9ic2VydmFibGVUeXBlRXJyb3I7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3dVbm9ic2VydmFibGVFcnJvci5qcy5tYXBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC91dGlsL3Rocm93VW5vYnNlcnZhYmxlRXJyb3IuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL29wZXJhdG9ycy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL29wZXJhdG9ycy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLm1lcmdlQWxsID0gZXhwb3J0cy5tZXJnZSA9IGV4cG9ydHMubWF4ID0gZXhwb3J0cy5tYXRlcmlhbGl6ZSA9IGV4cG9ydHMubWFwVG8gPSBleHBvcnRzLm1hcCA9IGV4cG9ydHMubGFzdCA9IGV4cG9ydHMuaXNFbXB0eSA9IGV4cG9ydHMuaWdub3JlRWxlbWVudHMgPSBleHBvcnRzLmdyb3VwQnkgPSBleHBvcnRzLmZpcnN0ID0gZXhwb3J0cy5maW5kSW5kZXggPSBleHBvcnRzLmZpbmQgPSBleHBvcnRzLmZpbmFsaXplID0gZXhwb3J0cy5maWx0ZXIgPSBleHBvcnRzLmV4cGFuZCA9IGV4cG9ydHMuZXhoYXVzdE1hcCA9IGV4cG9ydHMuZXhoYXVzdEFsbCA9IGV4cG9ydHMuZXhoYXVzdCA9IGV4cG9ydHMuZXZlcnkgPSBleHBvcnRzLmVuZFdpdGggPSBleHBvcnRzLmVsZW1lbnRBdCA9IGV4cG9ydHMuZGlzdGluY3RVbnRpbEtleUNoYW5nZWQgPSBleHBvcnRzLmRpc3RpbmN0VW50aWxDaGFuZ2VkID0gZXhwb3J0cy5kaXN0aW5jdCA9IGV4cG9ydHMuZGVtYXRlcmlhbGl6ZSA9IGV4cG9ydHMuZGVsYXlXaGVuID0gZXhwb3J0cy5kZWxheSA9IGV4cG9ydHMuZGVmYXVsdElmRW1wdHkgPSBleHBvcnRzLmRlYm91bmNlVGltZSA9IGV4cG9ydHMuZGVib3VuY2UgPSBleHBvcnRzLmNvdW50ID0gZXhwb3J0cy5jb25uZWN0ID0gZXhwb3J0cy5jb25jYXRXaXRoID0gZXhwb3J0cy5jb25jYXRNYXBUbyA9IGV4cG9ydHMuY29uY2F0TWFwID0gZXhwb3J0cy5jb25jYXRBbGwgPSBleHBvcnRzLmNvbmNhdCA9IGV4cG9ydHMuY29tYmluZUxhdGVzdFdpdGggPSBleHBvcnRzLmNvbWJpbmVMYXRlc3QgPSBleHBvcnRzLmNvbWJpbmVMYXRlc3RBbGwgPSBleHBvcnRzLmNvbWJpbmVBbGwgPSBleHBvcnRzLmNhdGNoRXJyb3IgPSBleHBvcnRzLmJ1ZmZlcldoZW4gPSBleHBvcnRzLmJ1ZmZlclRvZ2dsZSA9IGV4cG9ydHMuYnVmZmVyVGltZSA9IGV4cG9ydHMuYnVmZmVyQ291bnQgPSBleHBvcnRzLmJ1ZmZlciA9IGV4cG9ydHMuYXVkaXRUaW1lID0gZXhwb3J0cy5hdWRpdCA9IHZvaWQgMDtcXG5leHBvcnRzLnRpbWVJbnRlcnZhbCA9IGV4cG9ydHMudGhyb3dJZkVtcHR5ID0gZXhwb3J0cy50aHJvdHRsZVRpbWUgPSBleHBvcnRzLnRocm90dGxlID0gZXhwb3J0cy50YXAgPSBleHBvcnRzLnRha2VXaGlsZSA9IGV4cG9ydHMudGFrZVVudGlsID0gZXhwb3J0cy50YWtlTGFzdCA9IGV4cG9ydHMudGFrZSA9IGV4cG9ydHMuc3dpdGNoU2NhbiA9IGV4cG9ydHMuc3dpdGNoTWFwVG8gPSBleHBvcnRzLnN3aXRjaE1hcCA9IGV4cG9ydHMuc3dpdGNoQWxsID0gZXhwb3J0cy5zdWJzY3JpYmVPbiA9IGV4cG9ydHMuc3RhcnRXaXRoID0gZXhwb3J0cy5za2lwV2hpbGUgPSBleHBvcnRzLnNraXBVbnRpbCA9IGV4cG9ydHMuc2tpcExhc3QgPSBleHBvcnRzLnNraXAgPSBleHBvcnRzLnNpbmdsZSA9IGV4cG9ydHMuc2hhcmVSZXBsYXkgPSBleHBvcnRzLnNoYXJlID0gZXhwb3J0cy5zZXF1ZW5jZUVxdWFsID0gZXhwb3J0cy5zY2FuID0gZXhwb3J0cy5zYW1wbGVUaW1lID0gZXhwb3J0cy5zYW1wbGUgPSBleHBvcnRzLnJlZkNvdW50ID0gZXhwb3J0cy5yZXRyeVdoZW4gPSBleHBvcnRzLnJldHJ5ID0gZXhwb3J0cy5yZXBlYXRXaGVuID0gZXhwb3J0cy5yZXBlYXQgPSBleHBvcnRzLnJlZHVjZSA9IGV4cG9ydHMucmFjZVdpdGggPSBleHBvcnRzLnJhY2UgPSBleHBvcnRzLnB1Ymxpc2hSZXBsYXkgPSBleHBvcnRzLnB1Ymxpc2hMYXN0ID0gZXhwb3J0cy5wdWJsaXNoQmVoYXZpb3IgPSBleHBvcnRzLnB1Ymxpc2ggPSBleHBvcnRzLnBsdWNrID0gZXhwb3J0cy5wYXJ0aXRpb24gPSBleHBvcnRzLnBhaXJ3aXNlID0gZXhwb3J0cy5vbkVycm9yUmVzdW1lTmV4dCA9IGV4cG9ydHMub2JzZXJ2ZU9uID0gZXhwb3J0cy5tdWx0aWNhc3QgPSBleHBvcnRzLm1pbiA9IGV4cG9ydHMubWVyZ2VXaXRoID0gZXhwb3J0cy5tZXJnZVNjYW4gPSBleHBvcnRzLm1lcmdlTWFwVG8gPSBleHBvcnRzLm1lcmdlTWFwID0gZXhwb3J0cy5mbGF0TWFwID0gdm9pZCAwO1xcbmV4cG9ydHMuemlwV2l0aCA9IGV4cG9ydHMuemlwQWxsID0gZXhwb3J0cy56aXAgPSBleHBvcnRzLndpdGhMYXRlc3RGcm9tID0gZXhwb3J0cy53aW5kb3dXaGVuID0gZXhwb3J0cy53aW5kb3dUb2dnbGUgPSBleHBvcnRzLndpbmRvd1RpbWUgPSBleHBvcnRzLndpbmRvd0NvdW50ID0gZXhwb3J0cy53aW5kb3cgPSBleHBvcnRzLnRvQXJyYXkgPSBleHBvcnRzLnRpbWVzdGFtcCA9IGV4cG9ydHMudGltZW91dFdpdGggPSBleHBvcnRzLnRpbWVvdXQgPSB2b2lkIDA7XFxudmFyIGF1ZGl0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvYXVkaXQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2F1ZGl0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJhdWRpdFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXVkaXRfMS5hdWRpdDsgfSB9KSk7XFxudmFyIGF1ZGl0VGltZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL2F1ZGl0VGltZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvYXVkaXRUaW1lLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJhdWRpdFRpbWVcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGF1ZGl0VGltZV8xLmF1ZGl0VGltZTsgfSB9KSk7XFxudmFyIGJ1ZmZlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL2J1ZmZlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJidWZmZXJcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ1ZmZlcl8xLmJ1ZmZlcjsgfSB9KSk7XFxudmFyIGJ1ZmZlckNvdW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyQ291bnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2J1ZmZlckNvdW50LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJidWZmZXJDb3VudFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVmZmVyQ291bnRfMS5idWZmZXJDb3VudDsgfSB9KSk7XFxudmFyIGJ1ZmZlclRpbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJUaW1lICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJUaW1lLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJidWZmZXJUaW1lXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJUaW1lXzEuYnVmZmVyVGltZTsgfSB9KSk7XFxudmFyIGJ1ZmZlclRvZ2dsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL2J1ZmZlclRvZ2dsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyVG9nZ2xlLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJidWZmZXJUb2dnbGVcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ1ZmZlclRvZ2dsZV8xLmJ1ZmZlclRvZ2dsZTsgfSB9KSk7XFxudmFyIGJ1ZmZlcldoZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJXaGVuICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9idWZmZXJXaGVuLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJidWZmZXJXaGVuXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJXaGVuXzEuYnVmZmVyV2hlbjsgfSB9KSk7XFxudmFyIGNhdGNoRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9jYXRjaEVycm9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jYXRjaEVycm9yLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjYXRjaEVycm9yXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYXRjaEVycm9yXzEuY2F0Y2hFcnJvcjsgfSB9KSk7XFxudmFyIGNvbWJpbmVBbGxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9jb21iaW5lQWxsICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb21iaW5lQWxsLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb21iaW5lQWxsXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21iaW5lQWxsXzEuY29tYmluZUFsbDsgfSB9KSk7XFxudmFyIGNvbWJpbmVMYXRlc3RBbGxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9jb21iaW5lTGF0ZXN0QWxsICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb21iaW5lTGF0ZXN0QWxsLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb21iaW5lTGF0ZXN0QWxsXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21iaW5lTGF0ZXN0QWxsXzEuY29tYmluZUxhdGVzdEFsbDsgfSB9KSk7XFxudmFyIGNvbWJpbmVMYXRlc3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9jb21iaW5lTGF0ZXN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb21iaW5lTGF0ZXN0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb21iaW5lTGF0ZXN0XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21iaW5lTGF0ZXN0XzEuY29tYmluZUxhdGVzdDsgfSB9KSk7XFxudmFyIGNvbWJpbmVMYXRlc3RXaXRoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvY29tYmluZUxhdGVzdFdpdGggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbWJpbmVMYXRlc3RXaXRoLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb21iaW5lTGF0ZXN0V2l0aFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tYmluZUxhdGVzdFdpdGhfMS5jb21iaW5lTGF0ZXN0V2l0aDsgfSB9KSk7XFxudmFyIGNvbmNhdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL2NvbmNhdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb25jYXRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmNhdF8xLmNvbmNhdDsgfSB9KSk7XFxudmFyIGNvbmNhdEFsbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL2NvbmNhdEFsbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0QWxsLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb25jYXRBbGxcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmNhdEFsbF8xLmNvbmNhdEFsbDsgfSB9KSk7XFxudmFyIGNvbmNhdE1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL2NvbmNhdE1hcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0TWFwLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb25jYXRNYXBcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmNhdE1hcF8xLmNvbmNhdE1hcDsgfSB9KSk7XFxudmFyIGNvbmNhdE1hcFRvXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0TWFwVG8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbmNhdE1hcFRvLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb25jYXRNYXBUb1xcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uY2F0TWFwVG9fMS5jb25jYXRNYXBUbzsgfSB9KSk7XFxudmFyIGNvbmNhdFdpdGhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9jb25jYXRXaXRoICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb25jYXRXaXRoLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb25jYXRXaXRoXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25jYXRXaXRoXzEuY29uY2F0V2l0aDsgfSB9KSk7XFxudmFyIGNvbm5lY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9jb25uZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9jb25uZWN0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb25uZWN0XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0XzEuY29ubmVjdDsgfSB9KSk7XFxudmFyIGNvdW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvY291bnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2NvdW50LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJjb3VudFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY291bnRfMS5jb3VudDsgfSB9KSk7XFxudmFyIGRlYm91bmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvZGVib3VuY2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlYm91bmNlLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJkZWJvdW5jZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVib3VuY2VfMS5kZWJvdW5jZTsgfSB9KSk7XFxudmFyIGRlYm91bmNlVGltZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL2RlYm91bmNlVGltZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVib3VuY2VUaW1lLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJkZWJvdW5jZVRpbWVcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlYm91bmNlVGltZV8xLmRlYm91bmNlVGltZTsgfSB9KSk7XFxudmFyIGRlZmF1bHRJZkVtcHR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvZGVmYXVsdElmRW1wdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlZmF1bHRJZkVtcHR5LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJkZWZhdWx0SWZFbXB0eVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVmYXVsdElmRW1wdHlfMS5kZWZhdWx0SWZFbXB0eTsgfSB9KSk7XFxudmFyIGRlbGF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvZGVsYXkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2RlbGF5LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJkZWxheVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVsYXlfMS5kZWxheTsgfSB9KSk7XFxudmFyIGRlbGF5V2hlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL2RlbGF5V2hlbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZGVsYXlXaGVuLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJkZWxheVdoZW5cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlbGF5V2hlbl8xLmRlbGF5V2hlbjsgfSB9KSk7XFxudmFyIGRlbWF0ZXJpYWxpemVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9kZW1hdGVyaWFsaXplICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9kZW1hdGVyaWFsaXplLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJkZW1hdGVyaWFsaXplXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZW1hdGVyaWFsaXplXzEuZGVtYXRlcmlhbGl6ZTsgfSB9KSk7XFxudmFyIGRpc3RpbmN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvZGlzdGluY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2Rpc3RpbmN0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJkaXN0aW5jdFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzdGluY3RfMS5kaXN0aW5jdDsgfSB9KSk7XFxudmFyIGRpc3RpbmN0VW50aWxDaGFuZ2VkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvZGlzdGluY3RVbnRpbENoYW5nZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2Rpc3RpbmN0VW50aWxDaGFuZ2VkLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJkaXN0aW5jdFVudGlsQ2hhbmdlZFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzdGluY3RVbnRpbENoYW5nZWRfMS5kaXN0aW5jdFVudGlsQ2hhbmdlZDsgfSB9KSk7XFxudmFyIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvZGlzdGluY3RVbnRpbEtleUNoYW5nZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzdGluY3RVbnRpbEtleUNoYW5nZWRfMS5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZDsgfSB9KSk7XFxudmFyIGVsZW1lbnRBdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL2VsZW1lbnRBdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZWxlbWVudEF0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJlbGVtZW50QXRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnRBdF8xLmVsZW1lbnRBdDsgfSB9KSk7XFxudmFyIGVuZFdpdGhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9lbmRXaXRoICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9lbmRXaXRoLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJlbmRXaXRoXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmRXaXRoXzEuZW5kV2l0aDsgfSB9KSk7XFxudmFyIGV2ZXJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvZXZlcnkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2V2ZXJ5LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJldmVyeVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlcnlfMS5ldmVyeTsgfSB9KSk7XFxudmFyIGV4aGF1c3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9leGhhdXN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9leGhhdXN0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJleGhhdXN0XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGhhdXN0XzEuZXhoYXVzdDsgfSB9KSk7XFxudmFyIGV4aGF1c3RBbGxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9leGhhdXN0QWxsICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9leGhhdXN0QWxsLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJleGhhdXN0QWxsXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGhhdXN0QWxsXzEuZXhoYXVzdEFsbDsgfSB9KSk7XFxudmFyIGV4aGF1c3RNYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9leGhhdXN0TWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9leGhhdXN0TWFwLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJleGhhdXN0TWFwXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGhhdXN0TWFwXzEuZXhoYXVzdE1hcDsgfSB9KSk7XFxudmFyIGV4cGFuZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL2V4cGFuZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZXhwYW5kLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJleHBhbmRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4cGFuZF8xLmV4cGFuZDsgfSB9KSk7XFxudmFyIGZpbHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbHRlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZmlsdGVyLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJmaWx0ZXJcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpbHRlcl8xLmZpbHRlcjsgfSB9KSk7XFxudmFyIGZpbmFsaXplXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvZmluYWxpemUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbmFsaXplLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJmaW5hbGl6ZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmluYWxpemVfMS5maW5hbGl6ZTsgfSB9KSk7XFxudmFyIGZpbmRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9maW5kICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9maW5kLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJmaW5kXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaW5kXzEuZmluZDsgfSB9KSk7XFxudmFyIGZpbmRJbmRleF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL2ZpbmRJbmRleCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvZmluZEluZGV4LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJmaW5kSW5kZXhcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpbmRJbmRleF8xLmZpbmRJbmRleDsgfSB9KSk7XFxudmFyIGZpcnN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvZmlyc3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpcnN0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJmaXJzdFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlyc3RfMS5maXJzdDsgfSB9KSk7XFxudmFyIGdyb3VwQnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9ncm91cEJ5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9ncm91cEJ5LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJncm91cEJ5XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBncm91cEJ5XzEuZ3JvdXBCeTsgfSB9KSk7XFxudmFyIGlnbm9yZUVsZW1lbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvaWdub3JlRWxlbWVudHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL2lnbm9yZUVsZW1lbnRzLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJpZ25vcmVFbGVtZW50c1xcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaWdub3JlRWxlbWVudHNfMS5pZ25vcmVFbGVtZW50czsgfSB9KSk7XFxudmFyIGlzRW1wdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9pc0VtcHR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9pc0VtcHR5LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJpc0VtcHR5XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc0VtcHR5XzEuaXNFbXB0eTsgfSB9KSk7XFxudmFyIGxhc3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9sYXN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9sYXN0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJsYXN0XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYXN0XzEubGFzdDsgfSB9KSk7XFxudmFyIG1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL21hcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWFwLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtYXBcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hcF8xLm1hcDsgfSB9KSk7XFxudmFyIG1hcFRvXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvbWFwVG8gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21hcFRvLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtYXBUb1xcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFwVG9fMS5tYXBUbzsgfSB9KSk7XFxudmFyIG1hdGVyaWFsaXplXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvbWF0ZXJpYWxpemUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21hdGVyaWFsaXplLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtYXRlcmlhbGl6ZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0ZXJpYWxpemVfMS5tYXRlcmlhbGl6ZTsgfSB9KSk7XFxudmFyIG1heF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL21heCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWF4LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtYXhcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heF8xLm1heDsgfSB9KSk7XFxudmFyIG1lcmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtZXJnZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVyZ2VfMS5tZXJnZTsgfSB9KSk7XFxudmFyIG1lcmdlQWxsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VBbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlQWxsLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtZXJnZUFsbFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVyZ2VBbGxfMS5tZXJnZUFsbDsgfSB9KSk7XFxudmFyIGZsYXRNYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9mbGF0TWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9mbGF0TWFwLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJmbGF0TWFwXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmbGF0TWFwXzEuZmxhdE1hcDsgfSB9KSk7XFxudmFyIG1lcmdlTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VNYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlTWFwLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtZXJnZU1hcFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVyZ2VNYXBfMS5tZXJnZU1hcDsgfSB9KSk7XFxudmFyIG1lcmdlTWFwVG9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZU1hcFRvICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9tZXJnZU1hcFRvLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtZXJnZU1hcFRvXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXJnZU1hcFRvXzEubWVyZ2VNYXBUbzsgfSB9KSk7XFxudmFyIG1lcmdlU2Nhbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlU2NhbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VTY2FuLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtZXJnZVNjYW5cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lcmdlU2Nhbl8xLm1lcmdlU2NhbjsgfSB9KSk7XFxudmFyIG1lcmdlV2l0aF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlV2l0aCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VXaXRoLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtZXJnZVdpdGhcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lcmdlV2l0aF8xLm1lcmdlV2l0aDsgfSB9KSk7XFxudmFyIG1pbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL21pbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbWluLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtaW5cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pbl8xLm1pbjsgfSB9KSk7XFxudmFyIG11bHRpY2FzdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL211bHRpY2FzdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvbXVsdGljYXN0LmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJtdWx0aWNhc3RcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG11bHRpY2FzdF8xLm11bHRpY2FzdDsgfSB9KSk7XFxudmFyIG9ic2VydmVPbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL29ic2VydmVPbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvb2JzZXJ2ZU9uLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJvYnNlcnZlT25cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmVPbl8xLm9ic2VydmVPbjsgfSB9KSk7XFxudmFyIG9uRXJyb3JSZXN1bWVOZXh0V2l0aF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL29uRXJyb3JSZXN1bWVOZXh0V2l0aCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvb25FcnJvclJlc3VtZU5leHRXaXRoLmpzXFxcIik7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJvbkVycm9yUmVzdW1lTmV4dFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb25FcnJvclJlc3VtZU5leHRXaXRoXzEub25FcnJvclJlc3VtZU5leHQ7IH0gfSkpO1xcbnZhciBwYWlyd2lzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3BhaXJ3aXNlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9wYWlyd2lzZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicGFpcndpc2VcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhaXJ3aXNlXzEucGFpcndpc2U7IH0gfSkpO1xcbnZhciBwYXJ0aXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9wYXJ0aXRpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3BhcnRpdGlvbi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicGFydGl0aW9uXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJ0aXRpb25fMS5wYXJ0aXRpb247IH0gfSkpO1xcbnZhciBwbHVja18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3BsdWNrICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9wbHVjay5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicGx1Y2tcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBsdWNrXzEucGx1Y2s7IH0gfSkpO1xcbnZhciBwdWJsaXNoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvcHVibGlzaCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcHVibGlzaC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicHVibGlzaFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHVibGlzaF8xLnB1Ymxpc2g7IH0gfSkpO1xcbnZhciBwdWJsaXNoQmVoYXZpb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9wdWJsaXNoQmVoYXZpb3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3B1Ymxpc2hCZWhhdmlvci5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicHVibGlzaEJlaGF2aW9yXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwdWJsaXNoQmVoYXZpb3JfMS5wdWJsaXNoQmVoYXZpb3I7IH0gfSkpO1xcbnZhciBwdWJsaXNoTGFzdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3B1Ymxpc2hMYXN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9wdWJsaXNoTGFzdC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicHVibGlzaExhc3RcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHB1Ymxpc2hMYXN0XzEucHVibGlzaExhc3Q7IH0gfSkpO1xcbnZhciBwdWJsaXNoUmVwbGF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvcHVibGlzaFJlcGxheSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcHVibGlzaFJlcGxheS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicHVibGlzaFJlcGxheVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHVibGlzaFJlcGxheV8xLnB1Ymxpc2hSZXBsYXk7IH0gfSkpO1xcbnZhciByYWNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvcmFjZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmFjZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicmFjZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmFjZV8xLnJhY2U7IH0gfSkpO1xcbnZhciByYWNlV2l0aF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3JhY2VXaXRoICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yYWNlV2l0aC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicmFjZVdpdGhcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhY2VXaXRoXzEucmFjZVdpdGg7IH0gfSkpO1xcbnZhciByZWR1Y2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9yZWR1Y2UgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3JlZHVjZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicmVkdWNlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWR1Y2VfMS5yZWR1Y2U7IH0gfSkpO1xcbnZhciByZXBlYXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9yZXBlYXQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3JlcGVhdC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicmVwZWF0XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXBlYXRfMS5yZXBlYXQ7IH0gfSkpO1xcbnZhciByZXBlYXRXaGVuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvcmVwZWF0V2hlbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvcmVwZWF0V2hlbi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicmVwZWF0V2hlblxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVwZWF0V2hlbl8xLnJlcGVhdFdoZW47IH0gfSkpO1xcbnZhciByZXRyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3JldHJ5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yZXRyeS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicmV0cnlcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJldHJ5XzEucmV0cnk7IH0gfSkpO1xcbnZhciByZXRyeVdoZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9yZXRyeVdoZW4gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3JldHJ5V2hlbi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicmV0cnlXaGVuXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXRyeVdoZW5fMS5yZXRyeVdoZW47IH0gfSkpO1xcbnZhciByZWZDb3VudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3JlZkNvdW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9yZWZDb3VudC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwicmVmQ291bnRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZkNvdW50XzEucmVmQ291bnQ7IH0gfSkpO1xcbnZhciBzYW1wbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9zYW1wbGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NhbXBsZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2FtcGxlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzYW1wbGVfMS5zYW1wbGU7IH0gfSkpO1xcbnZhciBzYW1wbGVUaW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvc2FtcGxlVGltZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2FtcGxlVGltZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2FtcGxlVGltZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2FtcGxlVGltZV8xLnNhbXBsZVRpbWU7IH0gfSkpO1xcbnZhciBzY2FuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvc2NhbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2Nhbi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2NhblxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2Nhbl8xLnNjYW47IH0gfSkpO1xcbnZhciBzZXF1ZW5jZUVxdWFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvc2VxdWVuY2VFcXVhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2VxdWVuY2VFcXVhbC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2VxdWVuY2VFcXVhbFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VxdWVuY2VFcXVhbF8xLnNlcXVlbmNlRXF1YWw7IH0gfSkpO1xcbnZhciBzaGFyZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3NoYXJlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zaGFyZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2hhcmVcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlXzEuc2hhcmU7IH0gfSkpO1xcbnZhciBzaGFyZVJlcGxheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3NoYXJlUmVwbGF5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zaGFyZVJlcGxheS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2hhcmVSZXBsYXlcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlUmVwbGF5XzEuc2hhcmVSZXBsYXk7IH0gfSkpO1xcbnZhciBzaW5nbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9zaW5nbGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NpbmdsZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2luZ2xlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaW5nbGVfMS5zaW5nbGU7IH0gfSkpO1xcbnZhciBza2lwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvc2tpcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc2tpcC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2tpcFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2tpcF8xLnNraXA7IH0gfSkpO1xcbnZhciBza2lwTGFzdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3NraXBMYXN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9za2lwTGFzdC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2tpcExhc3RcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNraXBMYXN0XzEuc2tpcExhc3Q7IH0gfSkpO1xcbnZhciBza2lwVW50aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9za2lwVW50aWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NraXBVbnRpbC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2tpcFVudGlsXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBza2lwVW50aWxfMS5za2lwVW50aWw7IH0gfSkpO1xcbnZhciBza2lwV2hpbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9za2lwV2hpbGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3NraXBXaGlsZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic2tpcFdoaWxlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBza2lwV2hpbGVfMS5za2lwV2hpbGU7IH0gfSkpO1xcbnZhciBzdGFydFdpdGhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9zdGFydFdpdGggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3N0YXJ0V2l0aC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic3RhcnRXaXRoXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGFydFdpdGhfMS5zdGFydFdpdGg7IH0gfSkpO1xcbnZhciBzdWJzY3JpYmVPbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3N1YnNjcmliZU9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zdWJzY3JpYmVPbi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic3Vic2NyaWJlT25cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmliZU9uXzEuc3Vic2NyaWJlT247IH0gfSkpO1xcbnZhciBzd2l0Y2hBbGxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9zd2l0Y2hBbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3N3aXRjaEFsbC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic3dpdGNoQWxsXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzd2l0Y2hBbGxfMS5zd2l0Y2hBbGw7IH0gfSkpO1xcbnZhciBzd2l0Y2hNYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy9zd2l0Y2hNYXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3N3aXRjaE1hcC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic3dpdGNoTWFwXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzd2l0Y2hNYXBfMS5zd2l0Y2hNYXA7IH0gfSkpO1xcbnZhciBzd2l0Y2hNYXBUb18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3N3aXRjaE1hcFRvICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy9zd2l0Y2hNYXBUby5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic3dpdGNoTWFwVG9cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN3aXRjaE1hcFRvXzEuc3dpdGNoTWFwVG87IH0gfSkpO1xcbnZhciBzd2l0Y2hTY2FuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoU2NhbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvc3dpdGNoU2Nhbi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwic3dpdGNoU2NhblxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3dpdGNoU2Nhbl8xLnN3aXRjaFNjYW47IH0gfSkpO1xcbnZhciB0YWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGFrZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGFrZV8xLnRha2U7IH0gfSkpO1xcbnZhciB0YWtlTGFzdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2VMYXN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90YWtlTGFzdC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGFrZUxhc3RcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRha2VMYXN0XzEudGFrZUxhc3Q7IH0gfSkpO1xcbnZhciB0YWtlVW50aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy90YWtlVW50aWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2VVbnRpbC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGFrZVVudGlsXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0YWtlVW50aWxfMS50YWtlVW50aWw7IH0gfSkpO1xcbnZhciB0YWtlV2hpbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy90YWtlV2hpbGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2VXaGlsZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGFrZVdoaWxlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0YWtlV2hpbGVfMS50YWtlV2hpbGU7IH0gfSkpO1xcbnZhciB0YXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy90YXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3RhcC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGFwXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0YXBfMS50YXA7IH0gfSkpO1xcbnZhciB0aHJvdHRsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm90dGxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90aHJvdHRsZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGhyb3R0bGVcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRocm90dGxlXzEudGhyb3R0bGU7IH0gfSkpO1xcbnZhciB0aHJvdHRsZVRpbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy90aHJvdHRsZVRpbWUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm90dGxlVGltZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGhyb3R0bGVUaW1lXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aHJvdHRsZVRpbWVfMS50aHJvdHRsZVRpbWU7IH0gfSkpO1xcbnZhciB0aHJvd0lmRW1wdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy90aHJvd0lmRW1wdHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm93SWZFbXB0eS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGhyb3dJZkVtcHR5XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aHJvd0lmRW1wdHlfMS50aHJvd0lmRW1wdHk7IH0gfSkpO1xcbnZhciB0aW1lSW50ZXJ2YWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy90aW1lSW50ZXJ2YWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3RpbWVJbnRlcnZhbC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGltZUludGVydmFsXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aW1lSW50ZXJ2YWxfMS50aW1lSW50ZXJ2YWw7IH0gfSkpO1xcbnZhciB0aW1lb3V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvdGltZW91dCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdGltZW91dC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGltZW91dFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGltZW91dF8xLnRpbWVvdXQ7IH0gfSkpO1xcbnZhciB0aW1lb3V0V2l0aF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3RpbWVvdXRXaXRoICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy90aW1lb3V0V2l0aC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGltZW91dFdpdGhcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRpbWVvdXRXaXRoXzEudGltZW91dFdpdGg7IH0gfSkpO1xcbnZhciB0aW1lc3RhbXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy90aW1lc3RhbXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3RpbWVzdGFtcC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidGltZXN0YW1wXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aW1lc3RhbXBfMS50aW1lc3RhbXA7IH0gfSkpO1xcbnZhciB0b0FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvdG9BcnJheSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvdG9BcnJheS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidG9BcnJheVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdG9BcnJheV8xLnRvQXJyYXk7IH0gfSkpO1xcbnZhciB3aW5kb3dfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3cgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvdy5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwid2luZG93XFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3dfMS53aW5kb3c7IH0gfSkpO1xcbnZhciB3aW5kb3dDb3VudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvd0NvdW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3dDb3VudC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwid2luZG93Q291bnRcXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvd0NvdW50XzEud2luZG93Q291bnQ7IH0gfSkpO1xcbnZhciB3aW5kb3dUaW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvd2luZG93VGltZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvd2luZG93VGltZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwid2luZG93VGltZVxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93VGltZV8xLndpbmRvd1RpbWU7IH0gfSkpO1xcbnZhciB3aW5kb3dUb2dnbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy93aW5kb3dUb2dnbGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3dpbmRvd1RvZ2dsZS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwid2luZG93VG9nZ2xlXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3dUb2dnbGVfMS53aW5kb3dUb2dnbGU7IH0gfSkpO1xcbnZhciB3aW5kb3dXaGVuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvd2luZG93V2hlbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvd2luZG93V2hlbi5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwid2luZG93V2hlblxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93V2hlbl8xLndpbmRvd1doZW47IH0gfSkpO1xcbnZhciB3aXRoTGF0ZXN0RnJvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWwvb3BlcmF0b3JzL3dpdGhMYXRlc3RGcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2ludGVybmFsL29wZXJhdG9ycy93aXRoTGF0ZXN0RnJvbS5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwid2l0aExhdGVzdEZyb21cXFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpdGhMYXRlc3RGcm9tXzEud2l0aExhdGVzdEZyb207IH0gfSkpO1xcbnZhciB6aXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy96aXAgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3ppcC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiemlwXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB6aXBfMS56aXA7IH0gfSkpO1xcbnZhciB6aXBBbGxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFsL29wZXJhdG9ycy96aXBBbGwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW50ZXJuYWwvb3BlcmF0b3JzL3ppcEFsbC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiemlwQWxsXFxcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB6aXBBbGxfMS56aXBBbGw7IH0gfSkpO1xcbnZhciB6aXBXaXRoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbC9vcGVyYXRvcnMvemlwV2l0aCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2Nqcy9pbnRlcm5hbC9vcGVyYXRvcnMvemlwV2l0aC5qc1xcXCIpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiemlwV2l0aFxcXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gemlwV2l0aF8xLnppcFdpdGg7IH0gfSkpO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL29wZXJhdG9ycy9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2F1dGhSZXF1ZXN0LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2F1dGhSZXF1ZXN0LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcXFwiZGVmYXVsdFxcXCI6IG1vZCB9O1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuYXV0aFJlcXVlc3QgPSB2b2lkIDA7XFxudmFyIHJ4anNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJ4anMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW5kZXguanNcXFwiKTtcXG52YXIgaHR0cENsaWVudF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaHR0cENsaWVudCAqLyBcXFwiLi9zcmMvaHR0cENsaWVudC50c1xcXCIpKTtcXG52YXIgdXNlckluZm9EdG9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZHRvL3VzZXJJbmZvRHRvICovIFxcXCIuL3NyYy9kdG8vdXNlckluZm9EdG8udHNcXFwiKTtcXG52YXIgand0VXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL2p3dFV0aWwgKi8gXFxcIi4vc3JjL3V0aWwvand0VXRpbC50c1xcXCIpO1xcbnZhciByZXN1bHREdG9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZHRvL3Jlc3VsdER0byAqLyBcXFwiLi9zcmMvZHRvL3Jlc3VsdER0by50c1xcXCIpO1xcbnZhciBhdXRoUmVxdWVzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gYXV0aFJlcXVlc3QoKSB7XFxuICAgICAgICB0aGlzLmhjID0gbmV3IGh0dHBDbGllbnRfMS5kZWZhdWx0KFxcXCIvYXBpXFxcIik7XFxuICAgIH1cXG4gICAgYXV0aFJlcXVlc3QucHJvdG90eXBlLmdldFRva2VuID0gZnVuY3Rpb24gKG5hbWUsIHBhc3N3b3JkKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5oYy5wb3N0KFxcXCIvR2V0VG9rZW5cXFwiLCB7IG5hbWU6IG5hbWUsIHBhc3N3b3JkOiBwYXNzd29yZCB9KTtcXG4gICAgfTtcXG4gICAgYXV0aFJlcXVlc3QucHJvdG90eXBlLnZhbGlkYXRlVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmhjLmdldChcXFwiL1ZlcmlmeVRva2VuXFxcIiwgeyBwYXJhbXM6IHsgdG9rZW46IHRva2VuIH0gfSk7XFxuICAgIH07XFxuICAgIGF1dGhSZXF1ZXN0LnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uIChuYW1lLCBwYXNzd29yZCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIHZhciBvYnMgPSBuZXcgcnhqc18xLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XFxuICAgICAgICAgICAgX3RoaXMuZ2V0VG9rZW4obmFtZSwgcGFzc3dvcmQpLnN1YnNjcmliZSh7XFxuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChyKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoci5zdWNjZXNzICYmIHIuZGF0YSAhPSBudWxsKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gci5kYXRhO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFxcXCJ0b2tlblxcXCIsIHRva2VuKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQocik7XFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yKTtcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIG9icztcXG4gICAgfTtcXG4gICAgYXV0aFJlcXVlc3QucHJvdG90eXBlLmlzTG9naW4gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmdldExvY2FsVG9rZW4oKTtcXG4gICAgICAgIGlmICghdG9rZW4pIHtcXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IHJlc3VsdER0b18xLnJlc3VsdER0bygpO1xcbiAgICAgICAgICAgIHJlc3VsdC5zdWNjZXNzID0gZmFsc2U7XFxuICAgICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBcXFwibm90IGxvZ2luXFxcIjtcXG4gICAgICAgICAgICByZXR1cm4gKDAsIHJ4anNfMS5vZikocmVzdWx0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlVG9rZW4odG9rZW4pO1xcbiAgICB9O1xcbiAgICBhdXRoUmVxdWVzdC5wcm90b3R5cGUuZ2V0TG9jYWxUb2tlbiA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcXFwidG9rZW5cXFwiKSB8fCBcXFwiXFxcIjtcXG4gICAgfTtcXG4gICAgYXV0aFJlcXVlc3QucHJvdG90eXBlLmdldFVzZXJJbmZvID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIHVzZXJJbmZvID0gbmV3IHVzZXJJbmZvRHRvXzEudXNlckluZm9EdG8oKTtcXG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMuZ2V0TG9jYWxUb2tlbigpO1xcbiAgICAgICAgdmFyIFBheWxvYWQgPSBqd3RVdGlsXzEuand0VXRpbC5wYXJzZUpXVCh0b2tlbik7XFxuICAgICAgICB1c2VySW5mby5uYW1lID0gUGF5bG9hZC5uYW1lO1xcbiAgICAgICAgcmV0dXJuIHVzZXJJbmZvO1xcbiAgICB9O1xcbiAgICByZXR1cm4gYXV0aFJlcXVlc3Q7XFxufSgpKTtcXG5leHBvcnRzLmF1dGhSZXF1ZXN0ID0gYXV0aFJlcXVlc3Q7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vc3JjL2F1dGhSZXF1ZXN0LnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29yZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvcmUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmF1dGggPSBleHBvcnRzLmZvbGRlciA9IGV4cG9ydHMuZmlsZSA9IGV4cG9ydHMuZ3YgPSB2b2lkIDA7XFxudmFyIGF1dGhSZXF1ZXN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2F1dGhSZXF1ZXN0ICovIFxcXCIuL3NyYy9hdXRoUmVxdWVzdC50c1xcXCIpO1xcbnZhciBmaWxlSGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9maWxlSGFuZGxlciAqLyBcXFwiLi9zcmMvZmlsZUhhbmRsZXIudHNcXFwiKTtcXG52YXIgZm9sZGVySGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb2xkZXJIYW5kbGVyICovIFxcXCIuL3NyYy9mb2xkZXJIYW5kbGVyLnRzXFxcIik7XFxudmFyIGNmZyA9IHtcXG4gICAgZGVmYXVsdFdlYlNvY2tldFVybDogXFxcIi93cy9kZWZhdWx0XFxcIlxcbn07XFxuZXhwb3J0cy5ndiA9IHtcXG4gICAgdG9rZW46IFxcXCJcXFwiLFxcbiAgICBpbmZvOiAxLFxcbiAgICBjZmc6IGNmZyxcXG59O1xcbmV4cG9ydHMuZmlsZSA9IG5ldyBmaWxlSGFuZGxlcl8xLmZpbGVIYW5kbGVyKCk7XFxuZXhwb3J0cy5mb2xkZXIgPSBuZXcgZm9sZGVySGFuZGxlcl8xLmZvbGRlckhhbmRsZXIoKTtcXG5leHBvcnRzLmF1dGggPSBuZXcgYXV0aFJlcXVlc3RfMS5hdXRoUmVxdWVzdCgpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL3NyYy9jb3JlLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZHRvL3Jlc3VsdER0by50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2R0by9yZXN1bHREdG8udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLnJlc3VsdER0byA9IHZvaWQgMDtcXG52YXIgcmVzdWx0RHRvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiByZXN1bHREdG8oKSB7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdER0bztcXG59KCkpO1xcbmV4cG9ydHMucmVzdWx0RHRvID0gcmVzdWx0RHRvO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL3NyYy9kdG8vcmVzdWx0RHRvLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZHRvL3VzZXJJbmZvRHRvLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kdG8vdXNlckluZm9EdG8udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMudXNlckluZm9EdG8gPSB2b2lkIDA7XFxudmFyIHVzZXJJbmZvRHRvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiB1c2VySW5mb0R0bygpIHtcXG4gICAgfVxcbiAgICByZXR1cm4gdXNlckluZm9EdG87XFxufSgpKTtcXG5leHBvcnRzLnVzZXJJbmZvRHRvID0gdXNlckluZm9EdG87XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vc3JjL2R0by91c2VySW5mb0R0by50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2R0by93c1JlcXVlc3REdG8udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kdG8vd3NSZXF1ZXN0RHRvLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy53c1JlcXVlc3RIZWFkZXJEdG8gPSBleHBvcnRzLndzUmVxdWVzdER0byA9IHZvaWQgMDtcXG52YXIgd3NSZXF1ZXN0RHRvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiB3c1JlcXVlc3REdG8oKSB7XFxuICAgICAgICB0aGlzLmhlYWRlciA9IG5ldyB3c1JlcXVlc3RIZWFkZXJEdG8oKTtcXG4gICAgfVxcbiAgICByZXR1cm4gd3NSZXF1ZXN0RHRvO1xcbn0oKSk7XFxuZXhwb3J0cy53c1JlcXVlc3REdG8gPSB3c1JlcXVlc3REdG87XFxudmFyIHdzUmVxdWVzdEhlYWRlckR0byA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gd3NSZXF1ZXN0SGVhZGVyRHRvKCkge1xcbiAgICB9XFxuICAgIHJldHVybiB3c1JlcXVlc3RIZWFkZXJEdG87XFxufSgpKTtcXG5leHBvcnRzLndzUmVxdWVzdEhlYWRlckR0byA9IHdzUmVxdWVzdEhlYWRlckR0bztcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9zcmMvZHRvL3dzUmVxdWVzdER0by50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2ZpbGVIYW5kbGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2ZpbGVIYW5kbGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuZmlsZUhhbmRsZXIgPSB2b2lkIDA7XFxudmFyIHJ4anNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJ4anMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW5kZXguanNcXFwiKTtcXG52YXIgaXNwYWNlV2ViU29ja2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzcGFjZVdlYlNvY2tldCAqLyBcXFwiLi9zcmMvaXNwYWNlV2ViU29ja2V0LnRzXFxcIik7XFxudmFyIHdzUmVxdWVzdER0b18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kdG8vd3NSZXF1ZXN0RHRvICovIFxcXCIuL3NyYy9kdG8vd3NSZXF1ZXN0RHRvLnRzXFxcIik7XFxudmFyIGZpbGVIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBmaWxlSGFuZGxlcigpIHtcXG4gICAgICAgIC8vIHN0ZXAgMjogYnVpbGQgd3NcXG4gICAgICAgIHRoaXMud3MgPSBpc3BhY2VXZWJTb2NrZXRfMS5pc3BhY2VXZWJTb2NrZXQuZ2V0U2luZ2xlKCk7XFxuICAgICAgICB0aGlzLndzLmNvbm5lY3QoKTtcXG4gICAgfVxcbiAgICBmaWxlSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGZvbGRlclBhdGgsIG5hbWUpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICB2YXIgb2IgPSBuZXcgcnhqc18xLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XFxuICAgICAgICAgICAgLy8gc3RlcCBpbml0OlxcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gXFxcImZpbGUvY3JlYXRlXFxcIjtcXG4gICAgICAgICAgICAvLyBzdGVwIDE6IGJ1aWxkIHJlcXVlc3RcXG4gICAgICAgICAgICB2YXIgcmVxID0gbmV3IHdzUmVxdWVzdER0b18xLndzUmVxdWVzdER0bygpO1xcbiAgICAgICAgICAgIHJlcS5oZWFkZXIgPSBuZXcgd3NSZXF1ZXN0RHRvXzEud3NSZXF1ZXN0SGVhZGVyRHRvKCk7XFxuICAgICAgICAgICAgcmVxLmhlYWRlci5oYW5kbGVyID0gaGFuZGxlcjtcXG4gICAgICAgICAgICByZXEuYm9keSA9IHtcXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcXG4gICAgICAgICAgICAgICAgZm9sZGVyUGF0aDogZm9sZGVyUGF0aFxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgLy8gc3RlcCAzOiBzZW5kIG1zXFxuICAgICAgICAgICAgX3RoaXMud3MucmVxdWVzdChyZXEpLnN1YnNjcmliZSh7XFxuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2EgPSByZXNwb25zZS5oZWFkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0KSA9PSAyMDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHRydWUpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IocmVzcG9uc2UuYm9keSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBvYjtcXG4gICAgfTtcXG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHJlbmFtZVxcbiAgICBmaWxlSGFuZGxlci5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24gKGZvbGRlclBhdGgsIG9sZE5hbWUsIG5ld05hbWUpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICB2YXIgb2IgPSBuZXcgcnhqc18xLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XFxuICAgICAgICAgICAgLy8gc3RlcCBpbml0OlxcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gXFxcImZpbGUvcmVuYW1lXFxcIjtcXG4gICAgICAgICAgICAvLyBzdGVwIDE6IGJ1aWxkIHJlcXVlc3RcXG4gICAgICAgICAgICB2YXIgcmVxID0gbmV3IHdzUmVxdWVzdER0b18xLndzUmVxdWVzdER0bygpO1xcbiAgICAgICAgICAgIHJlcS5oZWFkZXIgPSBuZXcgd3NSZXF1ZXN0RHRvXzEud3NSZXF1ZXN0SGVhZGVyRHRvKCk7XFxuICAgICAgICAgICAgcmVxLmhlYWRlci5oYW5kbGVyID0gaGFuZGxlcjtcXG4gICAgICAgICAgICByZXEuYm9keSA9IHtcXG4gICAgICAgICAgICAgICAgZm9sZGVyUGF0aDogZm9sZGVyUGF0aCxcXG4gICAgICAgICAgICAgICAgb2xkTmFtZTogb2xkTmFtZSxcXG4gICAgICAgICAgICAgICAgbmV3TmFtZTogbmV3TmFtZVxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgLy8gc3RlcCAzOiBzZW5kIG1zXFxuICAgICAgICAgICAgX3RoaXMud3MucmVxdWVzdChyZXEpLnN1YnNjcmliZSh7XFxuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2EgPSByZXNwb25zZS5oZWFkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0KSA9PSAyMDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHRydWUpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IocmVzcG9uc2UuYm9keSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBvYjtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIFJlbW92ZSBhIGZpbGVcXG4gICAgICogQHBhcmFtIGZvbGRlclBhdGggdGhlIHBhdGggd2hlcmUgdGhlIGZpbGUgaXMgbG9jYXRlZFxcbiAgICAgKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byByZW1vdmVcXG4gICAgICogQHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBmaWxlIHdhcyBzdWNjZXNzZnVsbHkgcmVtb3ZlZFxcbiAgICAgKi9cXG4gICAgZmlsZUhhbmRsZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChmb2xkZXJQYXRoLCBuYW1lKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdmFyIG9iID0gbmV3IHJ4anNfMS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xcbiAgICAgICAgICAgIC8vIHN0ZXAgaW5pdDpcXG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IFxcXCJmaWxlL3JlbW92ZVxcXCI7XFxuICAgICAgICAgICAgLy8gc3RlcCAxOiBidWlsZCByZXF1ZXN0XFxuICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyB3c1JlcXVlc3REdG9fMS53c1JlcXVlc3REdG8oKTtcXG4gICAgICAgICAgICByZXEuaGVhZGVyID0gbmV3IHdzUmVxdWVzdER0b18xLndzUmVxdWVzdEhlYWRlckR0bygpO1xcbiAgICAgICAgICAgIHJlcS5oZWFkZXIuaGFuZGxlciA9IGhhbmRsZXI7XFxuICAgICAgICAgICAgcmVxLmJvZHkgPSB7XFxuICAgICAgICAgICAgICAgIGZvbGRlclBhdGg6IGZvbGRlclBhdGgsXFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIC8vIHN0ZXAgMzogc2VuZCBtc1xcbiAgICAgICAgICAgIF90aGlzLndzLnJlcXVlc3QocmVxKS5zdWJzY3JpYmUoe1xcbiAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKF9hID0gcmVzcG9uc2UuaGVhZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdCkgPT0gMjAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh0cnVlKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHJlc3BvbnNlLmJvZHkpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gb2I7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgYSBmaWxlLlxcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggdGhlIHBhdGggb2YgdGhlIGZpbGUgdG8gcmV0cmlldmUgaW5mb3JtYXRpb24gYWJvdXRcXG4gICAgICogQHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgZmlsZUluZm9EdG8gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGZpbGVcXG4gICAgICovXFxuICAgIGZpbGVIYW5kbGVyLnByb3RvdHlwZS5zdGF0ZiA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIHZhciBvYiA9IG5ldyByeGpzXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcXG4gICAgICAgICAgICAvLyBzdGVwIGluaXQ6XFxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBcXFwiZmlsZS9zdGF0XFxcIjtcXG4gICAgICAgICAgICAvLyBzdGVwIDE6IGJ1aWxkIHJlcXVlc3RcXG4gICAgICAgICAgICB2YXIgcmVxID0gbmV3IHdzUmVxdWVzdER0b18xLndzUmVxdWVzdER0bygpO1xcbiAgICAgICAgICAgIHJlcS5oZWFkZXIgPSBuZXcgd3NSZXF1ZXN0RHRvXzEud3NSZXF1ZXN0SGVhZGVyRHRvKCk7XFxuICAgICAgICAgICAgcmVxLmhlYWRlci5oYW5kbGVyID0gaGFuZGxlcjtcXG4gICAgICAgICAgICByZXEuYm9keSA9IHtcXG4gICAgICAgICAgICAgICAgZmlsZVBhdGg6IGZpbGVQYXRoXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAvLyBzdGVwIDM6IHNlbmQgbXNcXG4gICAgICAgICAgICBfdGhpcy53cy5yZXF1ZXN0KHJlcSkuc3Vic2NyaWJlKHtcXG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHJlc3BvbnNlLmhlYWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXQpID09IDIwMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQocmVzcG9uc2UuYm9keSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihyZXNwb25zZS5ib2R5KTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yKTtcXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIG9iO1xcbiAgICB9O1xcbiAgICByZXR1cm4gZmlsZUhhbmRsZXI7XFxufSgpKTtcXG5leHBvcnRzLmZpbGVIYW5kbGVyID0gZmlsZUhhbmRsZXI7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vc3JjL2ZpbGVIYW5kbGVyLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZm9sZGVySGFuZGxlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2ZvbGRlckhhbmRsZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLmZvbGRlckhhbmRsZXIgPSB2b2lkIDA7XFxudmFyIHJ4anNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJ4anMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvaW5kZXguanNcXFwiKTtcXG52YXIgaXNwYWNlV2ViU29ja2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzcGFjZVdlYlNvY2tldCAqLyBcXFwiLi9zcmMvaXNwYWNlV2ViU29ja2V0LnRzXFxcIik7XFxudmFyIHdzUmVxdWVzdER0b18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kdG8vd3NSZXF1ZXN0RHRvICovIFxcXCIuL3NyYy9kdG8vd3NSZXF1ZXN0RHRvLnRzXFxcIik7XFxudmFyIGZvbGRlckhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIGZvbGRlckhhbmRsZXIoKSB7XFxuICAgICAgICAvLyBzdGVwIDI6IGJ1aWxkIHdzXFxuICAgICAgICB0aGlzLndzID0gaXNwYWNlV2ViU29ja2V0XzEuaXNwYWNlV2ViU29ja2V0LmdldFNpbmdsZSgpO1xcbiAgICAgICAgdGhpcy53cy5jb25uZWN0KCk7XFxuICAgIH1cXG4gICAgZm9sZGVySGFuZGxlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGZvbGRlclBhdGgsIG5hbWUpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICB2YXIgb2IgPSBuZXcgcnhqc18xLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XFxuICAgICAgICAgICAgLy8gc3RlcCBpbml0OlxcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gXFxcImZvbGRlci9jcmVhdGVcXFwiO1xcbiAgICAgICAgICAgIC8vIHN0ZXAgMTogYnVpbGQgcmVxdWVzdFxcbiAgICAgICAgICAgIHZhciByZXEgPSBuZXcgd3NSZXF1ZXN0RHRvXzEud3NSZXF1ZXN0RHRvKCk7XFxuICAgICAgICAgICAgcmVxLmhlYWRlciA9IG5ldyB3c1JlcXVlc3REdG9fMS53c1JlcXVlc3RIZWFkZXJEdG8oKTtcXG4gICAgICAgICAgICByZXEuaGVhZGVyLmhhbmRsZXIgPSBoYW5kbGVyO1xcbiAgICAgICAgICAgIHJlcS5ib2R5ID0ge1xcbiAgICAgICAgICAgICAgICBmb2xkZXJQYXRoOiBmb2xkZXJQYXRoLFxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAvLyBzdGVwIDM6IHNlbmQgbXNcXG4gICAgICAgICAgICBfdGhpcy53cy5yZXF1ZXN0KHJlcSkuc3Vic2NyaWJlKHtcXG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHJlc3BvbnNlLmhlYWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXQpID09IDIwMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQodHJ1ZSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihyZXNwb25zZS5ib2R5KTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yKTtcXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIG9iO1xcbiAgICB9O1xcbiAgICBmb2xkZXJIYW5kbGVyLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbiAoZm9sZGVyUGF0aCwgb2xkTmFtZSwgbmV3TmFtZSkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIHZhciBvYiA9IG5ldyByeGpzXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcXG4gICAgICAgICAgICAvLyBzdGVwIGluaXQ6XFxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBcXFwiZm9sZGVyL3JlbmFtZVxcXCI7XFxuICAgICAgICAgICAgLy8gc3RlcCAxOiBidWlsZCByZXF1ZXN0XFxuICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyB3c1JlcXVlc3REdG9fMS53c1JlcXVlc3REdG8oKTtcXG4gICAgICAgICAgICByZXEuaGVhZGVyID0gbmV3IHdzUmVxdWVzdER0b18xLndzUmVxdWVzdEhlYWRlckR0bygpO1xcbiAgICAgICAgICAgIHJlcS5oZWFkZXIuaGFuZGxlciA9IGhhbmRsZXI7XFxuICAgICAgICAgICAgcmVxLmJvZHkgPSB7XFxuICAgICAgICAgICAgICAgIGZvbGRlclBhdGg6IGZvbGRlclBhdGgsXFxuICAgICAgICAgICAgICAgIG9sZE5hbWU6IG9sZE5hbWUsXFxuICAgICAgICAgICAgICAgIG5ld05hbWU6IG5ld05hbWVcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIC8vIHN0ZXAgMzogc2VuZCBtc1xcbiAgICAgICAgICAgIF90aGlzLndzLnJlcXVlc3QocmVxKS5zdWJzY3JpYmUoe1xcbiAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKF9hID0gcmVzcG9uc2UuaGVhZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdCkgPT0gMjAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh0cnVlKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHJlc3BvbnNlLmJvZHkpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gb2I7XFxuICAgIH07XFxuICAgIGZvbGRlckhhbmRsZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChmb2xkZXJQYXRoLCBuYW1lKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdmFyIG9iID0gbmV3IHJ4anNfMS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xcbiAgICAgICAgICAgIC8vIHN0ZXAgaW5pdDpcXG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IFxcXCJmb2xkZXIvcmVtb3ZlXFxcIjtcXG4gICAgICAgICAgICAvLyBzdGVwIDE6IGJ1aWxkIHJlcXVlc3RcXG4gICAgICAgICAgICB2YXIgcmVxID0gbmV3IHdzUmVxdWVzdER0b18xLndzUmVxdWVzdER0bygpO1xcbiAgICAgICAgICAgIHJlcS5oZWFkZXIgPSBuZXcgd3NSZXF1ZXN0RHRvXzEud3NSZXF1ZXN0SGVhZGVyRHRvKCk7XFxuICAgICAgICAgICAgcmVxLmhlYWRlci5oYW5kbGVyID0gaGFuZGxlcjtcXG4gICAgICAgICAgICByZXEuYm9keSA9IHtcXG4gICAgICAgICAgICAgICAgZm9sZGVyUGF0aDogZm9sZGVyUGF0aCxcXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZVxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgLy8gc3RlcCAzOiBzZW5kIG1zXFxuICAgICAgICAgICAgX3RoaXMud3MucmVxdWVzdChyZXEpLnN1YnNjcmliZSh7XFxuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2EgPSByZXNwb25zZS5oZWFkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0KSA9PSAyMDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHRydWUpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IocmVzcG9uc2UuYm9keSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBvYjtcXG4gICAgfTtcXG4gICAgZm9sZGVySGFuZGxlci5wcm90b3R5cGUuc3RhdGYgPSBmdW5jdGlvbiAoZm9sZGVyUGF0aCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIHZhciBvYiA9IG5ldyByeGpzXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcXG4gICAgICAgICAgICAvLyBzdGVwIGluaXQ6XFxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBcXFwiZm9sZGVyL3N0YXRcXFwiO1xcbiAgICAgICAgICAgIC8vIHN0ZXAgMTogYnVpbGQgcmVxdWVzdFxcbiAgICAgICAgICAgIHZhciByZXEgPSBuZXcgd3NSZXF1ZXN0RHRvXzEud3NSZXF1ZXN0RHRvKCk7XFxuICAgICAgICAgICAgcmVxLmhlYWRlciA9IG5ldyB3c1JlcXVlc3REdG9fMS53c1JlcXVlc3RIZWFkZXJEdG8oKTtcXG4gICAgICAgICAgICByZXEuaGVhZGVyLmhhbmRsZXIgPSBoYW5kbGVyO1xcbiAgICAgICAgICAgIHJlcS5ib2R5ID0ge1xcbiAgICAgICAgICAgICAgICBmb2xkZXJQYXRoOiBmb2xkZXJQYXRoXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAvLyBzdGVwIDM6IHNlbmQgbXNcXG4gICAgICAgICAgICBfdGhpcy53cy5yZXF1ZXN0KHJlcSkuc3Vic2NyaWJlKHtcXG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHJlc3BvbnNlLmhlYWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXQpID09IDIwMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQocmVzcG9uc2UuYm9keSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihyZXNwb25zZS5ib2R5KTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yKTtcXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIG9iO1xcbiAgICB9O1xcbiAgICBmb2xkZXJIYW5kbGVyLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uIChmb2xkZXJQYXRoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdmFyIG9iID0gbmV3IHJ4anNfMS5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xcbiAgICAgICAgICAgIC8vIHN0ZXAgaW5pdDpcXG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IFxcXCJmb2xkZXIvY2hpbGRyZW5cXFwiO1xcbiAgICAgICAgICAgIC8vIHN0ZXAgMTogYnVpbGQgcmVxdWVzdFxcbiAgICAgICAgICAgIHZhciByZXEgPSBuZXcgd3NSZXF1ZXN0RHRvXzEud3NSZXF1ZXN0RHRvKCk7XFxuICAgICAgICAgICAgcmVxLmhlYWRlciA9IG5ldyB3c1JlcXVlc3REdG9fMS53c1JlcXVlc3RIZWFkZXJEdG8oKTtcXG4gICAgICAgICAgICByZXEuaGVhZGVyLmhhbmRsZXIgPSBoYW5kbGVyO1xcbiAgICAgICAgICAgIHJlcS5ib2R5ID0ge1xcbiAgICAgICAgICAgICAgICBmb2xkZXJQYXRoOiBmb2xkZXJQYXRoXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAvLyBzdGVwIDM6IHNlbmQgbXNcXG4gICAgICAgICAgICBfdGhpcy53cy5yZXF1ZXN0KHJlcSkuc3Vic2NyaWJlKHtcXG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHJlc3BvbnNlLmhlYWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXQpID09IDIwMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQocmVzcG9uc2UuYm9keSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihyZXNwb25zZS5ib2R5KTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yKTtcXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIG9iO1xcbiAgICB9O1xcbiAgICByZXR1cm4gZm9sZGVySGFuZGxlcjtcXG59KCkpO1xcbmV4cG9ydHMuZm9sZGVySGFuZGxlciA9IGZvbGRlckhhbmRsZXI7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vc3JjL2ZvbGRlckhhbmRsZXIudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9odHRwQ2xpZW50LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaHR0cENsaWVudC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcXFwiZGVmYXVsdFxcXCI6IG1vZCB9O1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbnZhciBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIGF4aW9zICovIFxcXCIuL25vZGVfbW9kdWxlcy9heGlvcy9kaXN0L2Jyb3dzZXIvYXhpb3MuY2pzXFxcIikpO1xcbnZhciByeGpzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByeGpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2luZGV4LmpzXFxcIik7XFxudmFyIG9wZXJhdG9yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcnhqcy9vcGVyYXRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9janMvb3BlcmF0b3JzL2luZGV4LmpzXFxcIik7XFxudmFyIEh0dHBDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIEh0dHBDbGllbnQoYmFzZVVSTCkge1xcbiAgICAgICAgdGhpcy5heGlvc0luc3RhbmNlID0gYXhpb3NfMS5kZWZhdWx0LmNyZWF0ZSh7XFxuICAgICAgICAgICAgYmFzZVVSTDogYmFzZVVSTFxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgSHR0cENsaWVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCwgY29uZmlnKSB7XFxuICAgICAgICByZXR1cm4gKDAsIHJ4anNfMS5mcm9tKSh0aGlzLmF4aW9zSW5zdGFuY2UuZ2V0KHVybCwgY29uZmlnKSkucGlwZSgoMCwgb3BlcmF0b3JzXzEubWFwKShmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIHJlc3BvbnNlLmRhdGE7IH0pLCAoMCwgb3BlcmF0b3JzXzEuY2F0Y2hFcnJvcikoZnVuY3Rpb24gKGVycm9yKSB7IHRocm93IGVycm9yOyB9KSk7XFxuICAgIH07XFxuICAgIEh0dHBDbGllbnQucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBjb25maWcpIHtcXG4gICAgICAgIHJldHVybiAoMCwgcnhqc18xLmZyb20pKHRoaXMuYXhpb3NJbnN0YW5jZS5wb3N0KHVybCwgZGF0YSwgY29uZmlnKSkucGlwZSgoMCwgb3BlcmF0b3JzXzEubWFwKShmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIHJlc3BvbnNlLmRhdGE7IH0pLCAoMCwgb3BlcmF0b3JzXzEuY2F0Y2hFcnJvcikoZnVuY3Rpb24gKGVycm9yKSB7IHRocm93IGVycm9yOyB9KSk7XFxuICAgIH07XFxuICAgIEh0dHBDbGllbnQucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNvbmZpZykge1xcbiAgICAgICAgcmV0dXJuICgwLCByeGpzXzEuZnJvbSkodGhpcy5heGlvc0luc3RhbmNlLnB1dCh1cmwsIGRhdGEsIGNvbmZpZykpLnBpcGUoKDAsIG9wZXJhdG9yc18xLm1hcCkoZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiByZXNwb25zZS5kYXRhOyB9KSwgKDAsIG9wZXJhdG9yc18xLmNhdGNoRXJyb3IpKGZ1bmN0aW9uIChlcnJvcikgeyB0aHJvdyBlcnJvcjsgfSkpO1xcbiAgICB9O1xcbiAgICBIdHRwQ2xpZW50LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodXJsLCBjb25maWcpIHtcXG4gICAgICAgIHJldHVybiAoMCwgcnhqc18xLmZyb20pKHRoaXMuYXhpb3NJbnN0YW5jZS5kZWxldGUodXJsLCBjb25maWcpKS5waXBlKCgwLCBvcGVyYXRvcnNfMS5tYXApKGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gcmVzcG9uc2UuZGF0YTsgfSksICgwLCBvcGVyYXRvcnNfMS5jYXRjaEVycm9yKShmdW5jdGlvbiAoZXJyb3IpIHsgdGhyb3cgZXJyb3I7IH0pKTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIEh0dHBDbGllbnQ7XFxufSgpKTtcXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSBIdHRwQ2xpZW50O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL3NyYy9odHRwQ2xpZW50LnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvaXNwYWNlV2ViU29ja2V0LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pc3BhY2VXZWJTb2NrZXQudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuaXNwYWNlV2ViU29ja2V0ID0gdm9pZCAwO1xcbnZhciByeGpzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByeGpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvY2pzL2luZGV4LmpzXFxcIik7XFxudmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZSAqLyBcXFwiLi9zcmMvY29yZS50c1xcXCIpO1xcbnZhciB1dWlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB1dWlkICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9pbmRleC5qc1xcXCIpO1xcbnZhciBpc3BhY2VXZWJTb2NrZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIGlzcGFjZVdlYlNvY2tldCgpIHtcXG4gICAgfVxcbiAgICBpc3BhY2VXZWJTb2NrZXQuZ2V0U2luZ2xlID0gZnVuY3Rpb24gKHRhZywgdXJsKSB7XFxuICAgICAgICBpZiAodGFnID09PSB2b2lkIDApIHsgdGFnID0gXFxcIlxcXCI7IH1cXG4gICAgICAgIGlmICh1cmwgPT09IHZvaWQgMCkgeyB1cmwgPSBjb3JlXzEuZ3YuY2ZnLmRlZmF1bHRXZWJTb2NrZXRVcmw7IH1cXG4gICAgICAgIHZhciBpd3MgPSB0aGlzLndzTWFwLmdldCh0YWcpO1xcbiAgICAgICAgaWYgKGl3cykge1xcbiAgICAgICAgICAgIHJldHVybiBpd3M7XFxuICAgICAgICB9XFxuICAgICAgICBpd3MgPSBuZXcgaXNwYWNlV2ViU29ja2V0KCk7XFxuICAgICAgICBpd3MudXJsID0gdXJsO1xcbiAgICAgICAgdGhpcy53c01hcC5zZXQodGFnLCBpd3MpO1xcbiAgICAgICAgcmV0dXJuIGl3cztcXG4gICAgfTtcXG4gICAgaXNwYWNlV2ViU29ja2V0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcXG4gICAgICAgIGlmICgoKF9hID0gdGhpcy53cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGUpICE9PSBXZWJTb2NrZXQuT1BFTikge1xcbiAgICAgICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHRoaXMudXJsKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gKF9iID0gdGhpcy5vbm9wZW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChmdW5jdGlvbiAoKSB7IH0pO1xcbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSAoX2MgPSB0aGlzLm9ubWVzc2FnZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogKGZ1bmN0aW9uICgpIHsgfSk7XFxuICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSAoX2QgPSB0aGlzLm9uY2xvc2UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IChmdW5jdGlvbiAoKSB7IH0pO1xcbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gKF9lID0gdGhpcy5vbmVycm9yKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAoZnVuY3Rpb24gKCkgeyB9KTtcXG4gICAgfTtcXG4gICAgaXNwYWNlV2ViU29ja2V0LnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcSkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgIHZhciBvYiA9IG5ldyByeGpzXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcXG4gICAgICAgICAgICB2YXIgX2E7XFxuICAgICAgICAgICAgLy8gc3RlcCAxOiDooaXlhYVoZWFkZXLvvIznlJ/miJBzdHJpbmcgZGF0YVxcbiAgICAgICAgICAgIHJlcS5oZWFkZXIuaWQgPSAoMCwgdXVpZF8xLnY0KSgpO1xcbiAgICAgICAgICAgIHJlcS5oZWFkZXIudG9rZW4gPSBjb3JlXzEuZ3YudG9rZW47XFxuICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeShyZXEpO1xcbiAgICAgICAgICAgIC8vIHN0ZXAgMjogc2VuZCBcXG4gICAgICAgICAgICBpZiAoX3RoaXMud3MgJiYgX3RoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMud3Muc2VuZChkYXRhKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3QoKTtcXG4gICAgICAgICAgICAgICAgdmFyIHNpXzEgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMud3MgJiYgX3RoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy53cy5zZW5kKGRhdGEpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoc2lfMSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0sIDEwKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy8gc3RlcCAzOiBkZWFsIHJlc3BvbnNlXFxuICAgICAgICAgICAgdmFyIHJlY2VpdmUgPSBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgICAgICB2YXIgX2E7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBKU09OLnBhcnNlKGUuZGF0YSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVyLmlkID09IHJlcS5oZWFkZXIuaWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHJlc3BvbnNlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLndzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHJlY2VpdmUpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAoX2EgPSBfdGhpcy53cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCByZWNlaXZlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIG9iO1xcbiAgICB9O1xcbiAgICBpc3BhY2VXZWJTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcXG4gICAgICAgICAgICB0aGlzLndzLmNsb3NlKCk7XFxuICAgICAgICB9XFxuICAgIH07XFxuICAgIGlzcGFjZVdlYlNvY2tldC53c01hcCA9IG5ldyBNYXAoKTtcXG4gICAgcmV0dXJuIGlzcGFjZVdlYlNvY2tldDtcXG59KCkpO1xcbmV4cG9ydHMuaXNwYWNlV2ViU29ja2V0ID0gaXNwYWNlV2ViU29ja2V0O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL3NyYy9pc3BhY2VXZWJTb2NrZXQudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL2p3dFV0aWwudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvand0VXRpbC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5qd3RVdGlsID0gdm9pZCAwO1xcbnZhciBqd3RVdGlsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBqd3RVdGlsKCkge1xcbiAgICB9XFxuICAgIGp3dFV0aWwucGFyc2VKV1QgPSBmdW5jdGlvbiAodG9rZW4pIHtcXG4gICAgICAgIHZhciBiYXNlNjRVcmwgPSB0b2tlbi5zcGxpdCgnLicpWzFdO1xcbiAgICAgICAgdmFyIGJhc2U2NCA9IGJhc2U2NFVybC5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvXy9nLCAnLycpO1xcbiAgICAgICAgdmFyIGpzb25QYXlsb2FkID0gZGVjb2RlVVJJQ29tcG9uZW50KGF0b2IoYmFzZTY0KS5zcGxpdCgnJykubWFwKGZ1bmN0aW9uIChjKSB7XFxuICAgICAgICAgICAgcmV0dXJuICclJyArICgnMDAnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xcbiAgICAgICAgfSkuam9pbignJykpO1xcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvblBheWxvYWQpO1xcbiAgICB9O1xcbiAgICByZXR1cm4gand0VXRpbDtcXG59KCkpO1xcbmV4cG9ydHMuand0VXRpbCA9IGp3dFV0aWw7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vc3JjL3V0aWwvand0VXRpbC50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHtcXG4gIHZhbHVlOiB0cnVlXFxufSkpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiTUFYXFxcIiwgKHtcXG4gIGVudW1lcmFibGU6IHRydWUsXFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgcmV0dXJuIF9tYXguZGVmYXVsdDtcXG4gIH1cXG59KSk7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJOSUxcXFwiLCAoe1xcbiAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICByZXR1cm4gX25pbC5kZWZhdWx0O1xcbiAgfVxcbn0pKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInBhcnNlXFxcIiwgKHtcXG4gIGVudW1lcmFibGU6IHRydWUsXFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgcmV0dXJuIF9wYXJzZS5kZWZhdWx0O1xcbiAgfVxcbn0pKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInN0cmluZ2lmeVxcXCIsICh7XFxuICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgIHJldHVybiBfc3RyaW5naWZ5LmRlZmF1bHQ7XFxuICB9XFxufSkpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidjFcXFwiLCAoe1xcbiAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICByZXR1cm4gX3YuZGVmYXVsdDtcXG4gIH1cXG59KSk7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJ2MVRvVjZcXFwiLCAoe1xcbiAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICByZXR1cm4gX3YxVG9WLmRlZmF1bHQ7XFxuICB9XFxufSkpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidjNcXFwiLCAoe1xcbiAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICByZXR1cm4gX3YyLmRlZmF1bHQ7XFxuICB9XFxufSkpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidjRcXFwiLCAoe1xcbiAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICByZXR1cm4gX3YzLmRlZmF1bHQ7XFxuICB9XFxufSkpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidjVcXFwiLCAoe1xcbiAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICByZXR1cm4gX3Y0LmRlZmF1bHQ7XFxuICB9XFxufSkpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidjZcXFwiLCAoe1xcbiAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICByZXR1cm4gX3Y1LmRlZmF1bHQ7XFxuICB9XFxufSkpO1xcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwidjZUb1YxXFxcIiwgKHtcXG4gIGVudW1lcmFibGU6IHRydWUsXFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgcmV0dXJuIF92NlRvVi5kZWZhdWx0O1xcbiAgfVxcbn0pKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInY3XFxcIiwgKHtcXG4gIGVudW1lcmFibGU6IHRydWUsXFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgcmV0dXJuIF92Ni5kZWZhdWx0O1xcbiAgfVxcbn0pKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInZhbGlkYXRlXFxcIiwgKHtcXG4gIGVudW1lcmFibGU6IHRydWUsXFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgcmV0dXJuIF92YWxpZGF0ZS5kZWZhdWx0O1xcbiAgfVxcbn0pKTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcInZlcnNpb25cXFwiLCAoe1xcbiAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICByZXR1cm4gX3ZlcnNpb24uZGVmYXVsdDtcXG4gIH1cXG59KSk7XFxudmFyIF9tYXggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWF4LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9tYXguanNcXFwiKSk7XFxudmFyIF9uaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbmlsLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9uaWwuanNcXFwiKSk7XFxudmFyIF9wYXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wYXJzZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvcGFyc2UuanNcXFwiKSk7XFxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3RyaW5naWZ5LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9zdHJpbmdpZnkuanNcXFwiKSk7XFxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3YxLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92MS5qc1xcXCIpKTtcXG52YXIgX3YxVG9WID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3YxVG9WNi5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvdjFUb1Y2LmpzXFxcIikpO1xcbnZhciBfdjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdjMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3YzLmpzXFxcIikpO1xcbnZhciBfdjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdjQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3Y0LmpzXFxcIikpO1xcbnZhciBfdjQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdjUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3Y1LmpzXFxcIikpO1xcbnZhciBfdjUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdjYuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3Y2LmpzXFxcIikpO1xcbnZhciBfdjZUb1YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdjZUb1YxLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92NlRvVjEuanNcXFwiKSk7XFxudmFyIF92NiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92Ny5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvdjcuanNcXFwiKSk7XFxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92YWxpZGF0ZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvdmFsaWRhdGUuanNcXFwiKSk7XFxudmFyIF92ZXJzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ZlcnNpb24uanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3ZlcnNpb24uanNcXFwiKSk7XFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL21heC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvbWF4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pKTtcXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSB2b2lkIDA7XFxudmFyIF9kZWZhdWx0ID0gZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gJ2ZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZic7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL21heC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL21kNS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvbWQ1LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pKTtcXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSB2b2lkIDA7XFxuLypcXG4gKiBCcm93c2VyLWNvbXBhdGlibGUgSmF2YVNjcmlwdCBNRDVcXG4gKlxcbiAqIE1vZGlmaWNhdGlvbiBvZiBKYXZhU2NyaXB0IE1ENVxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTUQ1XFxuICpcXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxcbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcXG4gKlxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcXG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxcbiAqXFxuICogQmFzZWQgb25cXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXFxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXFxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cXG4gKi9cXG5mdW5jdGlvbiBtZDUoYnl0ZXMpIHtcXG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XFxuICAgIHZhciBtc2cgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYnl0ZXMpKTsgLy8gVVRGOCBlc2NhcGVcXG5cXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShtc2cubGVuZ3RoKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcXG4gICAgICBieXRlc1tpXSA9IG1zZy5jaGFyQ29kZUF0KGkpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbWQ1VG9IZXhFbmNvZGVkQXJyYXkod29yZHNUb01kNShieXRlc1RvV29yZHMoYnl0ZXMpLCBieXRlcy5sZW5ndGggKiA4KSk7XFxufVxcblxcbi8qXFxuICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGFuIGFycmF5IG9mIGJ5dGVzXFxuICovXFxuZnVuY3Rpb24gbWQ1VG9IZXhFbmNvZGVkQXJyYXkoaW5wdXQpIHtcXG4gIHZhciBvdXRwdXQgPSBbXTtcXG4gIHZhciBsZW5ndGgzMiA9IGlucHV0Lmxlbmd0aCAqIDMyO1xcbiAgdmFyIGhleFRhYiA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMzI7IGkgKz0gOCkge1xcbiAgICB2YXIgeCA9IGlucHV0W2kgPj4gNV0gPj4+IGkgJSAzMiAmIDB4ZmY7XFxuICAgIHZhciBoZXggPSBwYXJzZUludChoZXhUYWIuY2hhckF0KHggPj4+IDQgJiAweDBmKSArIGhleFRhYi5jaGFyQXQoeCAmIDB4MGYpLCAxNik7XFxuICAgIG91dHB1dC5wdXNoKGhleCk7XFxuICB9XFxuICByZXR1cm4gb3V0cHV0O1xcbn1cXG5cXG4vKipcXG4gKiBDYWxjdWxhdGUgb3V0cHV0IGxlbmd0aCB3aXRoIHBhZGRpbmcgYW5kIGJpdCBsZW5ndGhcXG4gKi9cXG5mdW5jdGlvbiBnZXRPdXRwdXRMZW5ndGgoaW5wdXRMZW5ndGg4KSB7XFxuICByZXR1cm4gKGlucHV0TGVuZ3RoOCArIDY0ID4+PiA5IDw8IDQpICsgMTQgKyAxO1xcbn1cXG5cXG4vKlxcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXFxuICovXFxuZnVuY3Rpb24gd29yZHNUb01kNSh4LCBsZW4pIHtcXG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXFxuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8IGxlbiAlIDMyO1xcbiAgeFtnZXRPdXRwdXRMZW5ndGgobGVuKSAtIDFdID0gbGVuO1xcbiAgdmFyIGEgPSAxNzMyNTg0MTkzO1xcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcXG4gIHZhciBkID0gMjcxNzMzODc4O1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xcbiAgICB2YXIgb2xkYSA9IGE7XFxuICAgIHZhciBvbGRiID0gYjtcXG4gICAgdmFyIG9sZGMgPSBjO1xcbiAgICB2YXIgb2xkZCA9IGQ7XFxuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2ldLCA3LCAtNjgwODc2OTM2KTtcXG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDFdLCAxMiwgLTM4OTU2NDU4Nik7XFxuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XFxuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcXG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA3LCAtMTc2NDE4ODk3KTtcXG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XFxuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcXG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDddLCAyMiwgLTQ1NzA1OTgzKTtcXG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcXG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNywgLTQyMDYzKTtcXG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcXG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNywgMTgwNDYwMzY4Mik7XFxuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxM10sIDEyLCAtNDAzNDExMDEpO1xcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTVdLCAyMiwgMTIzNjUzNTMyOSk7XFxuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNSwgLTE2NTc5NjUxMCk7XFxuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpO1xcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNCwgNjQzNzE3NzEzKTtcXG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaV0sIDIwLCAtMzczODk3MzAyKTtcXG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKTtcXG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDEwXSwgOSwgMzgwMTYwODMpO1xcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XFxuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgOV0sIDUsIDU2ODQ0NjQzOCk7XFxuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxNF0sIDksIC0xMDE5ODAzNjkwKTtcXG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XFxuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA4XSwgMjAsIDExNjM1MzE1MDEpO1xcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMTNdLCA1LCAtMTQ0NDY4MTQ2Nyk7XFxuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KTtcXG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNCwgMTczNTMyODQ3Myk7XFxuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyAxMl0sIDIwLCAtMTkyNjYwNzczNCk7XFxuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNCwgLTM3ODU1OCk7XFxuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcXG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTYsIDE4MzkwMzA1NjIpO1xcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KTtcXG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA0LCAtMTUzMDk5MjA2MCk7XFxuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA0XSwgMTEsIDEyNzI4OTMzNTMpO1xcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgN10sIDE2LCAtMTU1NDk3NjMyKTtcXG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcXG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNCwgNjgxMjc5MTc0KTtcXG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaV0sIDExLCAtMzU4NTM3MjIyKTtcXG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNiwgLTcyMjUyMTk3OSk7XFxuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyA2XSwgMjMsIDc2MDI5MTg5KTtcXG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KTtcXG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDEyXSwgMTEsIC00MjE4MTU4MzUpO1xcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNiwgNTMwNzQyNTIwKTtcXG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSk7XFxuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2ldLCA2LCAtMTk4NjMwODQ0KTtcXG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDddLCAxMCwgMTEyNjg5MTQxNSk7XFxuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XFxuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA1XSwgMjEsIC01NzQzNDA1NSk7XFxuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDYsIDE3MDA0ODU1NzEpO1xcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XFxuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE1LCAtMTA1MTUyMyk7XFxuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcXG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcXG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDE1XSwgMTAsIC0zMDYxMTc0NCk7XFxuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcXG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgNF0sIDYsIC0xNDU1MjMwNzApO1xcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcXG4gICAgYSA9IHNhZmVBZGQoYSwgb2xkYSk7XFxuICAgIGIgPSBzYWZlQWRkKGIsIG9sZGIpO1xcbiAgICBjID0gc2FmZUFkZChjLCBvbGRjKTtcXG4gICAgZCA9IHNhZmVBZGQoZCwgb2xkZCk7XFxuICB9XFxuICByZXR1cm4gW2EsIGIsIGMsIGRdO1xcbn1cXG5cXG4vKlxcbiAqIENvbnZlcnQgYW4gYXJyYXkgYnl0ZXMgdG8gYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3Jkc1xcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxcbiAqL1xcbmZ1bmN0aW9uIGJ5dGVzVG9Xb3JkcyhpbnB1dCkge1xcbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xcbiAgICByZXR1cm4gW107XFxuICB9XFxuICB2YXIgbGVuZ3RoOCA9IGlucHV0Lmxlbmd0aCAqIDg7XFxuICB2YXIgb3V0cHV0ID0gbmV3IFVpbnQzMkFycmF5KGdldE91dHB1dExlbmd0aChsZW5ndGg4KSk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDg7IGkgKz0gOCkge1xcbiAgICBvdXRwdXRbaSA+PiA1XSB8PSAoaW5wdXRbaSAvIDhdICYgMHhmZikgPDwgaSAlIDMyO1xcbiAgfVxcbiAgcmV0dXJuIG91dHB1dDtcXG59XFxuXFxuLypcXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XFxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cXG4gKi9cXG5mdW5jdGlvbiBzYWZlQWRkKHgsIHkpIHtcXG4gIHZhciBsc3cgPSAoeCAmIDB4ZmZmZikgKyAoeSAmIDB4ZmZmZik7XFxuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XFxuICByZXR1cm4gbXN3IDw8IDE2IHwgbHN3ICYgMHhmZmZmO1xcbn1cXG5cXG4vKlxcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cXG4gKi9cXG5mdW5jdGlvbiBiaXRSb3RhdGVMZWZ0KG51bSwgY250KSB7XFxuICByZXR1cm4gbnVtIDw8IGNudCB8IG51bSA+Pj4gMzIgLSBjbnQ7XFxufVxcblxcbi8qXFxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cXG4gKi9cXG5mdW5jdGlvbiBtZDVjbW4ocSwgYSwgYiwgeCwgcywgdCkge1xcbiAgcmV0dXJuIHNhZmVBZGQoYml0Um90YXRlTGVmdChzYWZlQWRkKHNhZmVBZGQoYSwgcSksIHNhZmVBZGQoeCwgdCkpLCBzKSwgYik7XFxufVxcbmZ1bmN0aW9uIG1kNWZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcXG4gIHJldHVybiBtZDVjbW4oYiAmIGMgfCB+YiAmIGQsIGEsIGIsIHgsIHMsIHQpO1xcbn1cXG5mdW5jdGlvbiBtZDVnZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XFxuICByZXR1cm4gbWQ1Y21uKGIgJiBkIHwgYyAmIH5kLCBhLCBiLCB4LCBzLCB0KTtcXG59XFxuZnVuY3Rpb24gbWQ1aGgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xcbiAgcmV0dXJuIG1kNWNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xcbn1cXG5mdW5jdGlvbiBtZDVpaShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XFxuICByZXR1cm4gbWQ1Y21uKGMgXiAoYiB8IH5kKSwgYSwgYiwgeCwgcywgdCk7XFxufVxcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IG1kNTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvbWQ1LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvbmF0aXZlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9uYXRpdmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHtcXG4gIHZhbHVlOiB0cnVlXFxufSkpO1xcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IHZvaWQgMDtcXG52YXIgcmFuZG9tVVVJRCA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEICYmIGNyeXB0by5yYW5kb21VVUlELmJpbmQoY3J5cHRvKTtcXG52YXIgX2RlZmF1bHQgPSBleHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSB7XFxuICByYW5kb21VVUlEXFxufTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvbmF0aXZlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvbmlsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9uaWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHtcXG4gIHZhbHVlOiB0cnVlXFxufSkpO1xcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IHZvaWQgMDtcXG52YXIgX2RlZmF1bHQgPSBleHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJztcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvbmlsLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvcGFyc2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvcGFyc2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoe1xcbiAgdmFsdWU6IHRydWVcXG59KSk7XFxuZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gdm9pZCAwO1xcbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdmFsaWRhdGUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3ZhbGlkYXRlLmpzXFxcIikpO1xcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XFxuICBpZiAoISgwLCBfdmFsaWRhdGUuZGVmYXVsdCkodXVpZCkpIHtcXG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcXG4gIH1cXG4gIHZhciB2O1xcbiAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDE2KTtcXG5cXG4gIC8vIFBhcnNlICMjIyMjIyMjLS4uLi4tLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxcbiAgYXJyWzBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNDtcXG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcXG4gIGFyclsyXSA9IHYgPj4+IDggJiAweGZmO1xcbiAgYXJyWzNdID0gdiAmIDB4ZmY7XFxuXFxuICAvLyBQYXJzZSAuLi4uLi4uLi0jIyMjLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cXG4gIGFycls0XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSg5LCAxMyksIDE2KSkgPj4+IDg7XFxuICBhcnJbNV0gPSB2ICYgMHhmZjtcXG5cXG4gIC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxcbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XFxuICBhcnJbN10gPSB2ICYgMHhmZjtcXG5cXG4gIC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0jIyMjLS4uLi4uLi4uLi4uLlxcbiAgYXJyWzhdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE5LCAyMyksIDE2KSkgPj4+IDg7XFxuICBhcnJbOV0gPSB2ICYgMHhmZjtcXG5cXG4gIC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0uLi4uLSMjIyMjIyMjIyMjI1xcbiAgLy8gKFVzZSBcXFwiL1xcXCIgdG8gYXZvaWQgMzItYml0IHRydW5jYXRpb24gd2hlbiBiaXQtc2hpZnRpbmcgaGlnaC1vcmRlciBieXRlcylcXG4gIGFyclsxMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xcbiAgYXJyWzExXSA9IHYgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XFxuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xcbiAgYXJyWzEzXSA9IHYgPj4+IDE2ICYgMHhmZjtcXG4gIGFyclsxNF0gPSB2ID4+PiA4ICYgMHhmZjtcXG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcXG4gIHJldHVybiBhcnI7XFxufVxcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IHBhcnNlO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9wYXJzZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3JlZ2V4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3JlZ2V4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHtcXG4gIHZhbHVlOiB0cnVlXFxufSkpO1xcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IHZvaWQgMDtcXG52YXIgX2RlZmF1bHQgPSBleHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLThdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMHxmZmZmZmZmZi1mZmZmLWZmZmYtZmZmZi1mZmZmZmZmZmZmZmYpJC9pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9yZWdleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3JuZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvcm5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pKTtcXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSBybmc7XFxuLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXFxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXFxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cXG5cXG52YXIgZ2V0UmFuZG9tVmFsdWVzO1xcbnZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcXG5mdW5jdGlvbiBybmcoKSB7XFxuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XFxuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcXFwidGhpc1xcXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uXFxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0byk7XFxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3JuZy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3NoYTEuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9zaGExLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbmV2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoe1xcbiAgdmFsdWU6IHRydWVcXG59KSk7XFxuZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gdm9pZCAwO1xcbi8vIEFkYXB0ZWQgZnJvbSBDaHJpcyBWZW5lc3MnIFNIQTEgY29kZSBhdFxcbi8vIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvc2hhMS5odG1sXFxuZnVuY3Rpb24gZihzLCB4LCB5LCB6KSB7XFxuICBzd2l0Y2ggKHMpIHtcXG4gICAgY2FzZSAwOlxcbiAgICAgIHJldHVybiB4ICYgeSBeIH54ICYgejtcXG4gICAgY2FzZSAxOlxcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XFxuICAgIGNhc2UgMjpcXG4gICAgICByZXR1cm4geCAmIHkgXiB4ICYgeiBeIHkgJiB6O1xcbiAgICBjYXNlIDM6XFxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcXG4gIH1cXG59XFxuZnVuY3Rpb24gUk9UTCh4LCBuKSB7XFxuICByZXR1cm4geCA8PCBuIHwgeCA+Pj4gMzIgLSBuO1xcbn1cXG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XFxuICB2YXIgSyA9IFsweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGNhNjJjMWQ2XTtcXG4gIHZhciBIID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdO1xcbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgdmFyIG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxcblxcbiAgICBieXRlcyA9IFtdO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7ICsraSkge1xcbiAgICAgIGJ5dGVzLnB1c2gobXNnLmNoYXJDb2RlQXQoaSkpO1xcbiAgICB9XFxuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xcbiAgICAvLyBDb252ZXJ0IEFycmF5LWxpa2UgdG8gQXJyYXlcXG4gICAgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcyk7XFxuICB9XFxuICBieXRlcy5wdXNoKDB4ODApO1xcbiAgdmFyIGwgPSBieXRlcy5sZW5ndGggLyA0ICsgMjtcXG4gIHZhciBOID0gTWF0aC5jZWlsKGwgLyAxNik7XFxuICB2YXIgTSA9IG5ldyBBcnJheShOKTtcXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBOOyArK19pKSB7XFxuICAgIHZhciBhcnIgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcXG4gICAgICBhcnJbal0gPSBieXRlc1tfaSAqIDY0ICsgaiAqIDRdIDw8IDI0IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgMV0gPDwgMTYgfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAyXSA8PCA4IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgM107XFxuICAgIH1cXG4gICAgTVtfaV0gPSBhcnI7XFxuICB9XFxuICBNW04gLSAxXVsxNF0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4IC8gTWF0aC5wb3coMiwgMzIpO1xcbiAgTVtOIC0gMV1bMTRdID0gTWF0aC5mbG9vcihNW04gLSAxXVsxNF0pO1xcbiAgTVtOIC0gMV1bMTVdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAmIDB4ZmZmZmZmZmY7XFxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBOOyArK19pMikge1xcbiAgICB2YXIgVyA9IG5ldyBVaW50MzJBcnJheSg4MCk7XFxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgMTY7ICsrdCkge1xcbiAgICAgIFdbdF0gPSBNW19pMl1bdF07XFxuICAgIH1cXG4gICAgZm9yICh2YXIgX3QgPSAxNjsgX3QgPCA4MDsgKytfdCkge1xcbiAgICAgIFdbX3RdID0gUk9UTChXW190IC0gM10gXiBXW190IC0gOF0gXiBXW190IC0gMTRdIF4gV1tfdCAtIDE2XSwgMSk7XFxuICAgIH1cXG4gICAgdmFyIGEgPSBIWzBdO1xcbiAgICB2YXIgYiA9IEhbMV07XFxuICAgIHZhciBjID0gSFsyXTtcXG4gICAgdmFyIGQgPSBIWzNdO1xcbiAgICB2YXIgZSA9IEhbNF07XFxuICAgIGZvciAodmFyIF90MiA9IDA7IF90MiA8IDgwOyArK190Mikge1xcbiAgICAgIHZhciBzID0gTWF0aC5mbG9vcihfdDIgLyAyMCk7XFxuICAgICAgdmFyIFQgPSBST1RMKGEsIDUpICsgZihzLCBiLCBjLCBkKSArIGUgKyBLW3NdICsgV1tfdDJdID4+PiAwO1xcbiAgICAgIGUgPSBkO1xcbiAgICAgIGQgPSBjO1xcbiAgICAgIGMgPSBST1RMKGIsIDMwKSA+Pj4gMDtcXG4gICAgICBiID0gYTtcXG4gICAgICBhID0gVDtcXG4gICAgfVxcbiAgICBIWzBdID0gSFswXSArIGEgPj4+IDA7XFxuICAgIEhbMV0gPSBIWzFdICsgYiA+Pj4gMDtcXG4gICAgSFsyXSA9IEhbMl0gKyBjID4+PiAwO1xcbiAgICBIWzNdID0gSFszXSArIGQgPj4+IDA7XFxuICAgIEhbNF0gPSBIWzRdICsgZSA+Pj4gMDtcXG4gIH1cXG4gIHJldHVybiBbSFswXSA+PiAyNCAmIDB4ZmYsIEhbMF0gPj4gMTYgJiAweGZmLCBIWzBdID4+IDggJiAweGZmLCBIWzBdICYgMHhmZiwgSFsxXSA+PiAyNCAmIDB4ZmYsIEhbMV0gPj4gMTYgJiAweGZmLCBIWzFdID4+IDggJiAweGZmLCBIWzFdICYgMHhmZiwgSFsyXSA+PiAyNCAmIDB4ZmYsIEhbMl0gPj4gMTYgJiAweGZmLCBIWzJdID4+IDggJiAweGZmLCBIWzJdICYgMHhmZiwgSFszXSA+PiAyNCAmIDB4ZmYsIEhbM10gPj4gMTYgJiAweGZmLCBIWzNdID4+IDggJiAweGZmLCBIWzNdICYgMHhmZiwgSFs0XSA+PiAyNCAmIDB4ZmYsIEhbNF0gPj4gMTYgJiAweGZmLCBIWzRdID4+IDggJiAweGZmLCBIWzRdICYgMHhmZl07XFxufVxcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IHNoYTE7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3NoYTEuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9zdHJpbmdpZnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3N0cmluZ2lmeS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoe1xcbiAgdmFsdWU6IHRydWVcXG59KSk7XFxuZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gdm9pZCAwO1xcbmV4cG9ydHMudW5zYWZlU3RyaW5naWZ5ID0gdW5zYWZlU3RyaW5naWZ5O1xcbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdmFsaWRhdGUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3ZhbGlkYXRlLmpzXFxcIikpO1xcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cXG4vKipcXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcXG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcXG4gKi9cXG52YXIgYnl0ZVRvSGV4ID0gW107XFxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcXG59XFxuZnVuY3Rpb24gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxcbiAgLy9cXG4gIC8vIE5vdGUgdG8gZnV0dXJlLXNlbGY6IE5vLCB5b3UgY2FuJ3QgcmVtb3ZlIHRoZSBgdG9Mb3dlckNhc2UoKWAgY2FsbC5cXG4gIC8vIFJFRjogaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNjc3I2lzc3VlY29tbWVudC0xNzU3MzUxMzUxXFxuICByZXR1cm4gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpO1xcbn1cXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XFxuICB2YXIgdXVpZCA9IHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCk7XFxuICAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXFxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXFxuICAvLyBcXFwidW5kZWZpbmVkXFxcIiBpbiB0aGUgdXVpZClcXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcXG4gIGlmICghKDAsIF92YWxpZGF0ZS5kZWZhdWx0KSh1dWlkKSkge1xcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xcbiAgfVxcbiAgcmV0dXJuIHV1aWQ7XFxufVxcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IHN0cmluZ2lmeTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvc3RyaW5naWZ5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvdjEuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvdjEuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoe1xcbiAgdmFsdWU6IHRydWVcXG59KSk7XFxuZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gdm9pZCAwO1xcbnZhciBfcm5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JuZy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvcm5nLmpzXFxcIikpO1xcbnZhciBfc3RyaW5naWZ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdHJpbmdpZnkuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3N0cmluZ2lmeS5qc1xcXCIpO1xcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXFxuLy9cXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXFxuXFxudmFyIF9ub2RlSWQ7XFxudmFyIF9jbG9ja3NlcTtcXG5cXG4vLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcXG52YXIgX2xhc3RNU2VjcyA9IDA7XFxudmFyIF9sYXN0TlNlY3MgPSAwO1xcblxcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXFxuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcXG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xcbiAgdmFyIGIgPSBidWYgfHwgbmV3IEFycmF5KDE2KTtcXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGU7XFxuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxO1xcblxcbiAgLy8gdjEgb25seTogVXNlIGNhY2hlZCBgbm9kZWAgYW5kIGBjbG9ja3NlcWAgdmFsdWVzXFxuICBpZiAoIW9wdGlvbnMuX3Y2KSB7XFxuICAgIGlmICghbm9kZSkge1xcbiAgICAgIG5vZGUgPSBfbm9kZUlkO1xcbiAgICB9XFxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XFxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXE7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB3ZSBuZWVkIGVudHJvcHkuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXNcXG4gIC8vIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50IHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcXG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xcbiAgICB2YXIgc2VlZEJ5dGVzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcuZGVmYXVsdCkoKTtcXG5cXG4gICAgLy8gUmFuZG9taXplIG5vZGVcXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xcbiAgICAgIG5vZGUgPSBbc2VlZEJ5dGVzWzBdLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XFxuXFxuICAgICAgLy8gdjEgb25seTogY2FjaGUgbm9kZSB2YWx1ZSBmb3IgcmV1c2VcXG4gICAgICBpZiAoIV9ub2RlSWQgJiYgIW9wdGlvbnMuX3Y2KSB7XFxuICAgICAgICAvLyBwZXIgUkZDNDEyMiA0LjU6IFNldCBNQUMgbXVsdGljYXN0IGJpdCAodjEgb25seSlcXG4gICAgICAgIG5vZGVbMF0gfD0gMHgwMTsgLy8gU2V0IG11bHRpY2FzdCBiaXRcXG5cXG4gICAgICAgIF9ub2RlSWQgPSBub2RlO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBSYW5kb21pemUgY2xvY2tzZXFcXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcXG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxcbiAgICAgIGNsb2Nrc2VxID0gKHNlZWRCeXRlc1s2XSA8PCA4IHwgc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcXG4gICAgICBpZiAoX2Nsb2Nrc2VxID09PSB1bmRlZmluZWQgJiYgIW9wdGlvbnMuX3Y2KSB7XFxuICAgICAgICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIHYxICYgdjYgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzbyB0aW1lIGlzXFxuICAvLyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXFxuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxcbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7XFxuXFxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXFxuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xcbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xcblxcbiAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxcbiAgdmFyIGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDtcXG5cXG4gIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xcbiAgfVxcblxcbiAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcXG4gIC8vIHRpbWUgaW50ZXJ2YWxcXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIG5zZWNzID0gMDtcXG4gIH1cXG5cXG4gIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXFxcIik7XFxuICB9XFxuICBfbGFzdE1TZWNzID0gbXNlY3M7XFxuICBfbGFzdE5TZWNzID0gbnNlY3M7XFxuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcXG5cXG4gIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxcbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XFxuXFxuICAvLyBgdGltZV9sb3dgXFxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XFxuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcXG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcXG4gIGJbaSsrXSA9IHRsICYgMHhmZjtcXG5cXG4gIC8vIGB0aW1lX21pZGBcXG4gIHZhciB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XFxuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xcbiAgYltpKytdID0gdG1oICYgMHhmZjtcXG5cXG4gIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXFxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcXG5cXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxcbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xcblxcbiAgLy8gYGNsb2NrX3NlcV9sb3dgXFxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XFxuXFxuICAvLyBgbm9kZWBcXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgKytuKSB7XFxuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcXG4gIH1cXG4gIHJldHVybiBidWYgfHwgKDAsIF9zdHJpbmdpZnkudW5zYWZlU3RyaW5naWZ5KShiKTtcXG59XFxudmFyIF9kZWZhdWx0ID0gZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gdjE7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3YxLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvdjFUb1Y2LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92MVRvVjYuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHtcXG4gIHZhbHVlOiB0cnVlXFxufSkpO1xcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IHYxVG9WNjtcXG52YXIgX3BhcnNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BhcnNlLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9wYXJzZS5qc1xcXCIpKTtcXG52YXIgX3N0cmluZ2lmeSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3RyaW5naWZ5LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9zdHJpbmdpZnkuanNcXFwiKTtcXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XFxuLyoqXFxuICogQ29udmVydCBhIHYxIFVVSUQgdG8gYSB2NiBVVUlEXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ3xVaW50OEFycmF5fSB1dWlkIC0gVGhlIHYxIFVVSUQgdG8gY29udmVydCB0byB2NlxcbiAqIEByZXR1cm5zIHtzdHJpbmd8VWludDhBcnJheX0gVGhlIHY2IFVVSUQgYXMgdGhlIHNhbWUgdHlwZSBhcyB0aGUgYHV1aWRgIGFyZ1xcbiAqIChzdHJpbmcgb3IgVWludDhBcnJheSlcXG4gKi9cXG5mdW5jdGlvbiB2MVRvVjYodXVpZCkge1xcbiAgdmFyIHYxQnl0ZXMgPSB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyAoMCwgX3BhcnNlLmRlZmF1bHQpKHV1aWQpIDogdXVpZDtcXG4gIHZhciB2NkJ5dGVzID0gX3YxVG9WNih2MUJ5dGVzKTtcXG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyAoMCwgX3N0cmluZ2lmeS51bnNhZmVTdHJpbmdpZnkpKHY2Qnl0ZXMpIDogdjZCeXRlcztcXG59XFxuXFxuLy8gRG8gdGhlIGZpZWxkIHRyYW5zZm9ybWF0aW9uIG5lZWRlZCBmb3IgdjEgLT4gdjZcXG5mdW5jdGlvbiBfdjFUb1Y2KHYxQnl0ZXMsIHJhbmRvbWl6ZSA9IGZhbHNlKSB7XFxuICByZXR1cm4gVWludDhBcnJheS5vZigodjFCeXRlc1s2XSAmIDB4MGYpIDw8IDQgfCB2MUJ5dGVzWzddID4+IDQgJiAweDBmLCAodjFCeXRlc1s3XSAmIDB4MGYpIDw8IDQgfCAodjFCeXRlc1s0XSAmIDB4ZjApID4+IDQsICh2MUJ5dGVzWzRdICYgMHgwZikgPDwgNCB8ICh2MUJ5dGVzWzVdICYgMHhmMCkgPj4gNCwgKHYxQnl0ZXNbNV0gJiAweDBmKSA8PCA0IHwgKHYxQnl0ZXNbMF0gJiAweGYwKSA+PiA0LCAodjFCeXRlc1swXSAmIDB4MGYpIDw8IDQgfCAodjFCeXRlc1sxXSAmIDB4ZjApID4+IDQsICh2MUJ5dGVzWzFdICYgMHgwZikgPDwgNCB8ICh2MUJ5dGVzWzJdICYgMHhmMCkgPj4gNCwgMHg2MCB8IHYxQnl0ZXNbMl0gJiAweDBmLCB2MUJ5dGVzWzNdLCB2MUJ5dGVzWzhdLCB2MUJ5dGVzWzldLCB2MUJ5dGVzWzEwXSwgdjFCeXRlc1sxMV0sIHYxQnl0ZXNbMTJdLCB2MUJ5dGVzWzEzXSwgdjFCeXRlc1sxNF0sIHYxQnl0ZXNbMTVdKTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3YxVG9WNi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3YzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3YzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHtcXG4gIHZhbHVlOiB0cnVlXFxufSkpO1xcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IHZvaWQgMDtcXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdjM1LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92MzUuanNcXFwiKSk7XFxudmFyIF9tZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZDUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL21kNS5qc1xcXCIpKTtcXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XFxudmFyIHYzID0gKDAsIF92LmRlZmF1bHQpKCd2MycsIDB4MzAsIF9tZC5kZWZhdWx0KTtcXG52YXIgX2RlZmF1bHQgPSBleHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSB2MztcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvdjMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92MzUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3YzNS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoe1xcbiAgdmFsdWU6IHRydWVcXG59KSk7XFxuZXhwb3J0cy5VUkwgPSBleHBvcnRzLkROUyA9IHZvaWQgMDtcXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSB2MzU7XFxudmFyIF9zdHJpbmdpZnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0cmluZ2lmeS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvc3RyaW5naWZ5LmpzXFxcIik7XFxudmFyIF9wYXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wYXJzZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvcGFyc2UuanNcXFwiKSk7XFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxcbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XFxuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXFxuXFxuICB2YXIgYnl0ZXMgPSBbXTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XFxuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xcbiAgfVxcbiAgcmV0dXJuIGJ5dGVzO1xcbn1cXG52YXIgRE5TID0gZXhwb3J0cy5ETlMgPSAnNmJhN2I4MTAtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcXG52YXIgVVJMID0gZXhwb3J0cy5VUkwgPSAnNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcXG5mdW5jdGlvbiB2MzUobmFtZSwgdmVyc2lvbiwgaGFzaGZ1bmMpIHtcXG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xcbiAgICB2YXIgX25hbWVzcGFjZTtcXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcXG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xcbiAgICB9XFxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xcbiAgICAgIG5hbWVzcGFjZSA9ICgwLCBfcGFyc2UuZGVmYXVsdCkobmFtZXNwYWNlKTtcXG4gICAgfVxcbiAgICBpZiAoKChfbmFtZXNwYWNlID0gbmFtZXNwYWNlKSA9PT0gbnVsbCB8fCBfbmFtZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbmFtZXNwYWNlLmxlbmd0aCkgIT09IDE2KSB7XFxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XFxuICAgIH1cXG5cXG4gICAgLy8gQ29tcHV0ZSBoYXNoIG9mIG5hbWVzcGFjZSBhbmQgdmFsdWUsIFBlciA0LjNcXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XFxuICAgIC8vIGhhc2hmdW5jKFsuLi5uYW1lc3BhY2UsIC4uLiB2YWx1ZV0pYFxcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XFxuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xcbiAgICBieXRlcy5zZXQodmFsdWUsIG5hbWVzcGFjZS5sZW5ndGgpO1xcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcXG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xcbiAgICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgMHgzZiB8IDB4ODA7XFxuICAgIGlmIChidWYpIHtcXG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcXG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYnVmO1xcbiAgICB9XFxuICAgIHJldHVybiAoMCwgX3N0cmluZ2lmeS51bnNhZmVTdHJpbmdpZnkpKGJ5dGVzKTtcXG4gIH1cXG5cXG4gIC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxcbiAgdHJ5IHtcXG4gICAgZ2VuZXJhdGVVVUlELm5hbWUgPSBuYW1lO1xcbiAgfSBjYXRjaCAoZXJyKSB7fVxcblxcbiAgLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcXG4gIGdlbmVyYXRlVVVJRC5ETlMgPSBETlM7XFxuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xcbiAgcmV0dXJuIGdlbmVyYXRlVVVJRDtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3YzNS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3Y0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3Y0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHtcXG4gIHZhbHVlOiB0cnVlXFxufSkpO1xcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IHZvaWQgMDtcXG52YXIgX25hdGl2ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9uYXRpdmUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL25hdGl2ZS5qc1xcXCIpKTtcXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ybmcuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3JuZy5qc1xcXCIpKTtcXG52YXIgX3N0cmluZ2lmeSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3RyaW5naWZ5LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9zdHJpbmdpZnkuanNcXFwiKTtcXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XFxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcXG4gIGlmIChfbmF0aXZlLmRlZmF1bHQucmFuZG9tVVVJRCAmJiAhYnVmICYmICFvcHRpb25zKSB7XFxuICAgIHJldHVybiBfbmF0aXZlLmRlZmF1bHQucmFuZG9tVVVJRCgpO1xcbiAgfVxcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nLmRlZmF1bHQpKCk7XFxuXFxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXFxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDtcXG5cXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxcbiAgaWYgKGJ1Zikge1xcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XFxuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcXG4gICAgfVxcbiAgICByZXR1cm4gYnVmO1xcbiAgfVxcbiAgcmV0dXJuICgwLCBfc3RyaW5naWZ5LnVuc2FmZVN0cmluZ2lmeSkocm5kcyk7XFxufVxcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IHY0O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92NC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3Y1LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3Y1LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHtcXG4gIHZhbHVlOiB0cnVlXFxufSkpO1xcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IHZvaWQgMDtcXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdjM1LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92MzUuanNcXFwiKSk7XFxudmFyIF9zaGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2hhMS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvc2hhMS5qc1xcXCIpKTtcXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XFxudmFyIHY1ID0gKDAsIF92LmRlZmF1bHQpKCd2NScsIDB4NTAsIF9zaGEuZGVmYXVsdCk7XFxudmFyIF9kZWZhdWx0ID0gZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gdjU7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vaXNwYWNlLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3Y1LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvdjYuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvdjYuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoe1xcbiAgdmFsdWU6IHRydWVcXG59KSk7XFxuZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gdjY7XFxudmFyIF9zdHJpbmdpZnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0cmluZ2lmeS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvc3RyaW5naWZ5LmpzXFxcIik7XFxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3YxLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92MS5qc1xcXCIpKTtcXG52YXIgX3YxVG9WID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3YxVG9WNi5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvdjFUb1Y2LmpzXFxcIikpO1xcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XFxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcXFwic3RyaW5nXFxcIik7IHJldHVybiBcXFwic3ltYm9sXFxcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXFxcIlxcXCI7IH1cXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXFxcIm9iamVjdFxcXCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFxcXCJkZWZhdWx0XFxcIik7IGlmIChcXFwib2JqZWN0XFxcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXFxcIik7IH0gcmV0dXJuIChcXFwic3RyaW5nXFxcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cXG4vKipcXG4gKlxcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXFxuICogQHBhcmFtIHtVaW50OEFycmF5PX0gYnVmXFxuICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXRcXG4gKiBAcmV0dXJuc1xcbiAqL1xcbmZ1bmN0aW9uIHY2KG9wdGlvbnMgPSB7fSwgYnVmLCBvZmZzZXQgPSAwKSB7XFxuICAvLyB2NiBpcyB2MSB3aXRoIGRpZmZlcmVudCBmaWVsZCBsYXlvdXQsIHNvIHdlIHN0YXJ0IHdpdGggYSB2MSBVVUlELCBhbGJlaXRcXG4gIC8vIHdpdGggc2xpZ2h0bHkgZGlmZmVyZW50IGJlaGF2aW9yIGFyb3VuZCBob3cgdGhlIGNsb2NrX3NlcSBhbmQgbm9kZSBmaWVsZHNcXG4gIC8vIGFyZSByYW5kb21pemVkLCB3aGljaCBpcyB3aHkgd2UgY2FsbCB2MSB3aXRoIF92NjogdHJ1ZS5cXG4gIHZhciBieXRlcyA9ICgwLCBfdi5kZWZhdWx0KShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xcbiAgICBfdjY6IHRydWVcXG4gIH0pLCBuZXcgVWludDhBcnJheSgxNikpO1xcblxcbiAgLy8gUmVvcmRlciB0aGUgZmllbGRzIHRvIHY2IGxheW91dC5cXG4gIGJ5dGVzID0gKDAsIF92MVRvVi5kZWZhdWx0KShieXRlcyk7XFxuXFxuICAvLyBSZXR1cm4gYXMgYSBieXRlIGFycmF5IGlmIHJlcXVlc3RlZFxcbiAgaWYgKGJ1Zikge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcXG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcXG4gICAgfVxcbiAgICByZXR1cm4gYnVmO1xcbiAgfVxcbiAgcmV0dXJuICgwLCBfc3RyaW5naWZ5LnVuc2FmZVN0cmluZ2lmeSkoYnl0ZXMpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvdjYuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92NlRvVjEuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3Y2VG9WMS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoe1xcbiAgdmFsdWU6IHRydWVcXG59KSk7XFxuZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gdjZUb1YxO1xcbnZhciBfcGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGFyc2UuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3BhcnNlLmpzXFxcIikpO1xcbnZhciBfc3RyaW5naWZ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdHJpbmdpZnkuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3N0cmluZ2lmeS5qc1xcXCIpO1xcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cXG4vKipcXG4gKiBDb252ZXJ0IGEgdjYgVVVJRCB0byBhIHYxIFVVSURcXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IHV1aWQgLSBUaGUgdjYgVVVJRCB0byBjb252ZXJ0IHRvIHY2XFxuICogQHJldHVybnMge3N0cmluZ3xVaW50OEFycmF5fSBUaGUgdjEgVVVJRCBhcyB0aGUgc2FtZSB0eXBlIGFzIHRoZSBgdXVpZGAgYXJnXFxuICogKHN0cmluZyBvciBVaW50OEFycmF5KVxcbiAqL1xcbmZ1bmN0aW9uIHY2VG9WMSh1dWlkKSB7XFxuICB2YXIgdjZCeXRlcyA9IHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyA/ICgwLCBfcGFyc2UuZGVmYXVsdCkodXVpZCkgOiB1dWlkO1xcbiAgdmFyIHYxQnl0ZXMgPSBfdjZUb1YxKHY2Qnl0ZXMpO1xcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyA/ICgwLCBfc3RyaW5naWZ5LnVuc2FmZVN0cmluZ2lmeSkodjFCeXRlcykgOiB2MUJ5dGVzO1xcbn1cXG5cXG4vLyBEbyB0aGUgZmllbGQgdHJhbnNmb3JtYXRpb24gbmVlZGVkIGZvciB2NiAtPiB2MVxcbmZ1bmN0aW9uIF92NlRvVjEodjZCeXRlcykge1xcbiAgcmV0dXJuIFVpbnQ4QXJyYXkub2YoKHY2Qnl0ZXNbM10gJiAweDBmKSA8PCA0IHwgdjZCeXRlc1s0XSA+PiA0ICYgMHgwZiwgKHY2Qnl0ZXNbNF0gJiAweDBmKSA8PCA0IHwgKHY2Qnl0ZXNbNV0gJiAweGYwKSA+PiA0LCAodjZCeXRlc1s1XSAmIDB4MGYpIDw8IDQgfCB2NkJ5dGVzWzZdICYgMHgwZiwgdjZCeXRlc1s3XSwgKHY2Qnl0ZXNbMV0gJiAweDBmKSA8PCA0IHwgKHY2Qnl0ZXNbMl0gJiAweGYwKSA+PiA0LCAodjZCeXRlc1syXSAmIDB4MGYpIDw8IDQgfCAodjZCeXRlc1szXSAmIDB4ZjApID4+IDQsIDB4MTAgfCAodjZCeXRlc1swXSAmIDB4ZjApID4+IDQsICh2NkJ5dGVzWzBdICYgMHgwZikgPDwgNCB8ICh2NkJ5dGVzWzFdICYgMHhmMCkgPj4gNCwgdjZCeXRlc1s4XSwgdjZCeXRlc1s5XSwgdjZCeXRlc1sxMF0sIHY2Qnl0ZXNbMTFdLCB2NkJ5dGVzWzEyXSwgdjZCeXRlc1sxM10sIHY2Qnl0ZXNbMTRdLCB2NkJ5dGVzWzE1XSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92NlRvVjEuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92Ny5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92Ny5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcIlxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pKTtcXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSB2b2lkIDA7XFxudmFyIF9ybmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcm5nLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9ybmcuanNcXFwiKSk7XFxudmFyIF9zdHJpbmdpZnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0cmluZ2lmeS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvc3RyaW5naWZ5LmpzXFxcIik7XFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxcbi8qKlxcbiAqIFVVSUQgVjcgLSBVbml4IEVwb2NoIHRpbWUtYmFzZWQgVVVJRFxcbiAqXFxuICogVGhlIElFVEYgaGFzIHB1Ymxpc2hlZCBSRkM5NTYyLCBpbnRyb2R1Y2luZyAzIG5ldyBVVUlEIHZlcnNpb25zICg2LDcsOCkuIFRoaXNcXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBWNyBpcyBiYXNlZCBvbiB0aGUgYWNjZXB0ZWQsIHRob3VnaCBub3QgeWV0IGFwcHJvdmVkLFxcbiAqIHJldmlzaW9ucy5cXG4gKlxcbiAqIFJGQyA5NTYyOmh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5NTYyLmh0bWwgVW5pdmVyc2FsbHkgVW5pcXVlXFxuICogSURlbnRpZmllcnMgKFVVSURzKVxcblxcbiAqXFxuICogU2FtcGxlIFY3IHZhbHVlOlxcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5NTYyLmh0bWwjbmFtZS1leGFtcGxlLW9mLWEtdXVpZHY3LXZhbHVlXFxuICpcXG4gKiBNb25vdG9uaWMgQml0IExheW91dDogUkZDIHJmYzk1NjIuNi4yIE1ldGhvZCAxLCBEZWRpY2F0ZWQgQ291bnRlciBCaXRzIHJlZjpcXG4gKiAgICAgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzk1NjIuaHRtbCNzZWN0aW9uLTYuMi01LjFcXG4gKlxcbiAqICAgMCAgICAgICAgICAgICAgICAgICAxICAgICAgICAgICAgICAgICAgIDIgICAgICAgICAgICAgICAgICAgMyAwIDEgMiAzIDQgNSA2XFxuICogICA3IDggOSAwIDEgMiAzIDQgNSA2IDcgOCA5IDAgMSAyIDMgNCA1IDYgNyA4IDkgMCAxXFxuICogICstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rXFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXhfdHNfbXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxuICogICstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rXFxuICogIHwgICAgICAgICAgdW5peF90c19tcyAgICAgICAgICAgfCAgdmVyICB8ICAgICAgICBzZXFfaGkgICAgICAgICB8XFxuICogICstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rXFxuICogIHx2YXJ8ICAgICAgICAgICAgICAgc2VxX2xvdyAgICAgICAgICAgICAgIHwgICAgICAgIHJhbmQgICAgICAgICB8XFxuICogICstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rXFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxuICogICstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rXFxuICpcXG4gKiBzZXEgaXMgYSAzMSBiaXQgc2VyaWFsaXplZCBjb3VudGVyOyBjb21wcmlzZWQgb2YgMTIgYml0IHNlcV9oaSBhbmQgMTkgYml0XFxuICogc2VxX2xvdywgYW5kIHJhbmRvbWx5IGluaXRpYWxpemVkIHVwb24gdGltZXN0YW1wIGNoYW5nZS4gMzEgYml0IGNvdW50ZXIgc2l6ZVxcbiAqIHdhcyBzZWxlY3RlZCBhcyBhbnkgYml0d2lzZSBvcGVyYXRpb25zIGluIG5vZGUgYXJlIGRvbmUgYXMgX3NpZ25lZF8gMzIgYml0XFxuICogaW50cy4gd2UgZXhjbHVkZSB0aGUgc2lnbiBiaXQuXFxuICovXFxuXFxudmFyIF9zZXFMb3cgPSBudWxsO1xcbnZhciBfc2VxSGlnaCA9IG51bGw7XFxudmFyIF9tc2VjcyA9IDA7XFxuZnVuY3Rpb24gdjcob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcbiAgLy8gaW5pdGlhbGl6ZSBidWZmZXIgYW5kIHBvaW50ZXJcXG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xcbiAgdmFyIGIgPSBidWYgfHwgbmV3IFVpbnQ4QXJyYXkoMTYpO1xcblxcbiAgLy8gcm5kcyBpcyBVaW50OEFycmF5KDE2KSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXNcXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcuZGVmYXVsdCkoKTtcXG5cXG4gIC8vIG1pbGxpc2Vjb25kcyBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwXFxuICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogRGF0ZS5ub3coKTtcXG5cXG4gIC8vIHNlcSBpcyB1c2VyIHByb3ZpZGVkIDMxIGJpdCBjb3VudGVyXFxuICB2YXIgc2VxID0gb3B0aW9ucy5zZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2VxIDogbnVsbDtcXG5cXG4gIC8vIGluaXRpYWxpemUgbG9jYWwgc2VxIGhpZ2gvbG93IHBhcnRzXFxuICB2YXIgc2VxSGlnaCA9IF9zZXFIaWdoO1xcbiAgdmFyIHNlcUxvdyA9IF9zZXFMb3c7XFxuXFxuICAvLyBjaGVjayBpZiBjbG9jayBoYXMgYWR2YW5jZWQgYW5kIHVzZXIgaGFzIG5vdCBwcm92aWRlZCBtc2Vjc1xcbiAgaWYgKG1zZWNzID4gX21zZWNzICYmIG9wdGlvbnMubXNlY3MgPT09IHVuZGVmaW5lZCkge1xcbiAgICBfbXNlY3MgPSBtc2VjcztcXG5cXG4gICAgLy8gdW5sZXNzIHVzZXIgcHJvdmlkZWQgc2VxLCByZXNldCBzZXEgcGFydHNcXG4gICAgaWYgKHNlcSAhPT0gbnVsbCkge1xcbiAgICAgIHNlcUhpZ2ggPSBudWxsO1xcbiAgICAgIHNlcUxvdyA9IG51bGw7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIGlmIHdlIGhhdmUgYSB1c2VyIHByb3ZpZGVkIHNlcVxcbiAgaWYgKHNlcSAhPT0gbnVsbCkge1xcbiAgICAvLyB0cmltIHByb3ZpZGVkIHNlcSB0byAzMSBiaXRzIG9mIHZhbHVlLCBhdm9pZGluZyBvdmVyZmxvd1xcbiAgICBpZiAoc2VxID4gMHg3ZmZmZmZmZikge1xcbiAgICAgIHNlcSA9IDB4N2ZmZmZmZmY7XFxuICAgIH1cXG5cXG4gICAgLy8gc3BsaXQgcHJvdmlkZWQgc2VxIGludG8gaGlnaC9sb3cgcGFydHNcXG4gICAgc2VxSGlnaCA9IHNlcSA+Pj4gMTkgJiAweGZmZjtcXG4gICAgc2VxTG93ID0gc2VxICYgMHg3ZmZmZjtcXG4gIH1cXG5cXG4gIC8vIHJhbmRvbWx5IGluaXRpYWxpemUgc2VxXFxuICBpZiAoc2VxSGlnaCA9PT0gbnVsbCB8fCBzZXFMb3cgPT09IG51bGwpIHtcXG4gICAgc2VxSGlnaCA9IHJuZHNbNl0gJiAweDdmO1xcbiAgICBzZXFIaWdoID0gc2VxSGlnaCA8PCA4IHwgcm5kc1s3XTtcXG4gICAgc2VxTG93ID0gcm5kc1s4XSAmIDB4M2Y7IC8vIHBhZCBmb3IgdmFyXFxuICAgIHNlcUxvdyA9IHNlcUxvdyA8PCA4IHwgcm5kc1s5XTtcXG4gICAgc2VxTG93ID0gc2VxTG93IDw8IDUgfCBybmRzWzEwXSA+Pj4gMztcXG4gIH1cXG5cXG4gIC8vIGluY3JlbWVudCBzZXEgaWYgd2l0aGluIG1zZWNzIHdpbmRvd1xcbiAgaWYgKG1zZWNzICsgMTAwMDAgPiBfbXNlY3MgJiYgc2VxID09PSBudWxsKSB7XFxuICAgIGlmICgrK3NlcUxvdyA+IDB4N2ZmZmYpIHtcXG4gICAgICBzZXFMb3cgPSAwO1xcbiAgICAgIGlmICgrK3NlcUhpZ2ggPiAweGZmZikge1xcbiAgICAgICAgc2VxSGlnaCA9IDA7XFxuXFxuICAgICAgICAvLyBpbmNyZW1lbnQgaW50ZXJuYWwgX21zZWNzLiB0aGlzIGFsbG93cyB1cyB0byBjb250aW51ZSBpbmNyZW1lbnRpbmdcXG4gICAgICAgIC8vIHdoaWxlIHN0YXlpbmcgbW9ub3RvbmljLiBOb3RlLCBvbmNlIHdlIGhpdCAxMGsgbWlsbGlzZWNvbmRzIGJleW9uZCBzeXN0ZW1cXG4gICAgICAgIC8vIGNsb2NrLCB3ZSB3aWxsIHJlc2V0IGJyZWFraW5nIG1vbm90b25pY2l0eSAoYWZ0ZXIgKDJeMzEpKjEwMDAwIGdlbmVyYXRpb25zKVxcbiAgICAgICAgX21zZWNzKys7XFxuICAgICAgfVxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICAvLyByZXNldHRpbmc7IHdlIGhhdmUgYWR2YW5jZWQgbW9yZSB0aGFuXFxuICAgIC8vIDEwayBtaWxsaXNlY29uZHMgYmV5b25kIHN5c3RlbSBjbG9ja1xcbiAgICBfbXNlY3MgPSBtc2VjcztcXG4gIH1cXG4gIF9zZXFIaWdoID0gc2VxSGlnaDtcXG4gIF9zZXFMb3cgPSBzZXFMb3c7XFxuXFxuICAvLyBbYnl0ZXMgMC01XSA0OCBiaXRzIG9mIGxvY2FsIHRpbWVzdGFtcFxcbiAgYltpKytdID0gX21zZWNzIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XFxuICBiW2krK10gPSBfbXNlY3MgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XFxuICBiW2krK10gPSBfbXNlY3MgLyAweDEwMDAwMDAgJiAweGZmO1xcbiAgYltpKytdID0gX21zZWNzIC8gMHgxMDAwMCAmIDB4ZmY7XFxuICBiW2krK10gPSBfbXNlY3MgLyAweDEwMCAmIDB4ZmY7XFxuICBiW2krK10gPSBfbXNlY3MgJiAweGZmO1xcblxcbiAgLy8gW2J5dGUgNl0gLSBzZXQgNCBiaXRzIG9mIHZlcnNpb24gKDcpIHdpdGggZmlyc3QgNCBiaXRzIHNlcV9oaVxcbiAgYltpKytdID0gc2VxSGlnaCA+Pj4gNCAmIDB4MGYgfCAweDcwO1xcblxcbiAgLy8gW2J5dGUgN10gcmVtYWluaW5nIDggYml0cyBvZiBzZXFfaGlcXG4gIGJbaSsrXSA9IHNlcUhpZ2ggJiAweGZmO1xcblxcbiAgLy8gW2J5dGUgOF0gLSB2YXJpYW50ICgyIGJpdHMpLCBmaXJzdCA2IGJpdHMgc2VxX2xvd1xcbiAgYltpKytdID0gc2VxTG93ID4+PiAxMyAmIDB4M2YgfCAweDgwO1xcblxcbiAgLy8gW2J5dGUgOV0gOCBiaXRzIHNlcV9sb3dcXG4gIGJbaSsrXSA9IHNlcUxvdyA+Pj4gNSAmIDB4ZmY7XFxuXFxuICAvLyBbYnl0ZSAxMF0gcmVtYWluaW5nIDUgYml0cyBzZXFfbG93LCAzIGJpdHMgcmFuZG9tXFxuICBiW2krK10gPSBzZXFMb3cgPDwgMyAmIDB4ZmYgfCBybmRzWzEwXSAmIDB4MDc7XFxuXFxuICAvLyBbYnl0ZXMgMTEtMTVdIGFsd2F5cyByYW5kb21cXG4gIGJbaSsrXSA9IHJuZHNbMTFdO1xcbiAgYltpKytdID0gcm5kc1sxMl07XFxuICBiW2krK10gPSBybmRzWzEzXTtcXG4gIGJbaSsrXSA9IHJuZHNbMTRdO1xcbiAgYltpKytdID0gcm5kc1sxNV07XFxuICByZXR1cm4gYnVmIHx8ICgwLCBfc3RyaW5naWZ5LnVuc2FmZVN0cmluZ2lmeSkoYik7XFxufVxcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IHY3O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92Ny5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3ZhbGlkYXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9jb21tb25qcy1icm93c2VyL3ZhbGlkYXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHtcXG4gIHZhbHVlOiB0cnVlXFxufSkpO1xcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IHZvaWQgMDtcXG52YXIgX3JlZ2V4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JlZ2V4LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci9yZWdleC5qc1xcXCIpKTtcXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XFxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBfcmVnZXguZGVmYXVsdC50ZXN0KHV1aWQpO1xcbn1cXG52YXIgX2RlZmF1bHQgPSBleHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSB2YWxpZGF0ZTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvdmFsaWRhdGUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92ZXJzaW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvdmVyc2lvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHtcXG4gIHZhbHVlOiB0cnVlXFxufSkpO1xcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IHZvaWQgMDtcXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ZhbGlkYXRlLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY29tbW9uanMtYnJvd3Nlci92YWxpZGF0ZS5qc1xcXCIpKTtcXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XFxuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XFxuICBpZiAoISgwLCBfdmFsaWRhdGUuZGVmYXVsdCkodXVpZCkpIHtcXG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcXG4gIH1cXG4gIHJldHVybiBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxNSksIDE2KTtcXG59XFxudmFyIF9kZWZhdWx0ID0gZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gdmVyc2lvbjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9pc3BhY2UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2NvbW1vbmpzLWJyb3dzZXIvdmVyc2lvbi5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2F4aW9zL2Rpc3QvYnJvd3Nlci9heGlvcy5janNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9heGlvcy9kaXN0L2Jyb3dzZXIvYXhpb3MuY2pzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCIvLyBBeGlvcyB2MS43LjIgQ29weXJpZ2h0IChjKSAyMDI0IE1hdHQgWmFicmlza2llIGFuZCBjb250cmlidXRvcnNcXG5cXG5cXG5mdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XFxuICB9O1xcbn1cXG5cXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xcblxcbmNvbnN0IHt0b1N0cmluZ30gPSBPYmplY3QucHJvdG90eXBlO1xcbmNvbnN0IHtnZXRQcm90b3R5cGVPZn0gPSBPYmplY3Q7XFxuXFxuY29uc3Qga2luZE9mID0gKGNhY2hlID0+IHRoaW5nID0+IHtcXG4gICAgY29uc3Qgc3RyID0gdG9TdHJpbmcuY2FsbCh0aGluZyk7XFxuICAgIHJldHVybiBjYWNoZVtzdHJdIHx8IChjYWNoZVtzdHJdID0gc3RyLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpKTtcXG59KShPYmplY3QuY3JlYXRlKG51bGwpKTtcXG5cXG5jb25zdCBraW5kT2ZUZXN0ID0gKHR5cGUpID0+IHtcXG4gIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XFxuICByZXR1cm4gKHRoaW5nKSA9PiBraW5kT2YodGhpbmcpID09PSB0eXBlXFxufTtcXG5cXG5jb25zdCB0eXBlT2ZUZXN0ID0gdHlwZSA9PiB0aGluZyA9PiB0eXBlb2YgdGhpbmcgPT09IHR5cGU7XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcXG4gKlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcXG4gKi9cXG5jb25zdCB7aXNBcnJheX0gPSBBcnJheTtcXG5cXG4vKipcXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcXG4gKlxcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XFxuICpcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcXG4gKi9cXG5jb25zdCBpc1VuZGVmaW5lZCA9IHR5cGVPZlRlc3QoJ3VuZGVmaW5lZCcpO1xcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXFxuICpcXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxcbiAqXFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcXG4gICAgJiYgaXNGdW5jdGlvbih2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIpICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xcbn1cXG5cXG4vKipcXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxcbiAqXFxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcXG4gKlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcXG4gKi9cXG5jb25zdCBpc0FycmF5QnVmZmVyID0ga2luZE9mVGVzdCgnQXJyYXlCdWZmZXInKTtcXG5cXG5cXG4vKipcXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcXG4gKlxcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XFxuICpcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xcbiAgbGV0IHJlc3VsdDtcXG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcXG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XFxuICB9IGVsc2Uge1xcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcXG4gKlxcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XFxuICpcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXFxuICovXFxuY29uc3QgaXNTdHJpbmcgPSB0eXBlT2ZUZXN0KCdzdHJpbmcnKTtcXG5cXG4vKipcXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXFxuICpcXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmNvbnN0IGlzRnVuY3Rpb24gPSB0eXBlT2ZUZXN0KCdmdW5jdGlvbicpO1xcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXFxuICpcXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxcbiAqXFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmNvbnN0IGlzTnVtYmVyID0gdHlwZU9mVGVzdCgnbnVtYmVyJyk7XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XFxuICpcXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XFxuICpcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmNvbnN0IGlzT2JqZWN0ID0gKHRoaW5nKSA9PiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQm9vbGVhblxcbiAqXFxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQm9vbGVhbiwgb3RoZXJ3aXNlIGZhbHNlXFxuICovXFxuY29uc3QgaXNCb29sZWFuID0gdGhpbmcgPT4gdGhpbmcgPT09IHRydWUgfHwgdGhpbmcgPT09IGZhbHNlO1xcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XFxuICpcXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxcbiAqXFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB7XFxuICBpZiAoa2luZE9mKHZhbCkgIT09ICdvYmplY3QnKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIGNvbnN0IHByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKHZhbCk7XFxuICByZXR1cm4gKHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbCkgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gdmFsKTtcXG59O1xcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxcbiAqXFxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcXG4gKlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXFxuICovXFxuY29uc3QgaXNEYXRlID0ga2luZE9mVGVzdCgnRGF0ZScpO1xcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxcbiAqXFxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcXG4gKlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXFxuICovXFxuY29uc3QgaXNGaWxlID0ga2luZE9mVGVzdCgnRmlsZScpO1xcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxcbiAqXFxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcXG4gKlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXFxuICovXFxuY29uc3QgaXNCbG9iID0ga2luZE9mVGVzdCgnQmxvYicpO1xcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZUxpc3RcXG4gKlxcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XFxuICpcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmNvbnN0IGlzRmlsZUxpc3QgPSBraW5kT2ZUZXN0KCdGaWxlTGlzdCcpO1xcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXFxuICpcXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxcbiAqXFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmNvbnN0IGlzU3RyZWFtID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcXG5cXG4vKipcXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXFxuICpcXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XFxuICpcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXFxuICovXFxuY29uc3QgaXNGb3JtRGF0YSA9ICh0aGluZykgPT4ge1xcbiAgbGV0IGtpbmQ7XFxuICByZXR1cm4gdGhpbmcgJiYgKFxcbiAgICAodHlwZW9mIEZvcm1EYXRhID09PSAnZnVuY3Rpb24nICYmIHRoaW5nIGluc3RhbmNlb2YgRm9ybURhdGEpIHx8IChcXG4gICAgICBpc0Z1bmN0aW9uKHRoaW5nLmFwcGVuZCkgJiYgKFxcbiAgICAgICAgKGtpbmQgPSBraW5kT2YodGhpbmcpKSA9PT0gJ2Zvcm1kYXRhJyB8fFxcbiAgICAgICAgLy8gZGV0ZWN0IGZvcm0tZGF0YSBpbnN0YW5jZVxcbiAgICAgICAgKGtpbmQgPT09ICdvYmplY3QnICYmIGlzRnVuY3Rpb24odGhpbmcudG9TdHJpbmcpICYmIHRoaW5nLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IEZvcm1EYXRhXScpXFxuICAgICAgKVxcbiAgICApXFxuICApXFxufTtcXG5cXG4vKipcXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcXG4gKlxcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XFxuICpcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmNvbnN0IGlzVVJMU2VhcmNoUGFyYW1zID0ga2luZE9mVGVzdCgnVVJMU2VhcmNoUGFyYW1zJyk7XFxuXFxuY29uc3QgW2lzUmVhZGFibGVTdHJlYW0sIGlzUmVxdWVzdCwgaXNSZXNwb25zZSwgaXNIZWFkZXJzXSA9IFsnUmVhZGFibGVTdHJlYW0nLCAnUmVxdWVzdCcsICdSZXNwb25zZScsICdIZWFkZXJzJ10ubWFwKGtpbmRPZlRlc3QpO1xcblxcbi8qKlxcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cXG4gKlxcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcXG4gKi9cXG5jb25zdCB0cmltID0gKHN0cikgPT4gc3RyLnRyaW0gP1xcbiAgc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eW1xcXFxzXFxcXHVGRUZGXFxcXHhBMF0rfFtcXFxcc1xcXFx1RkVGRlxcXFx4QTBdKyQvZywgJycpO1xcblxcbi8qKlxcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxcbiAqXFxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxcbiAqXFxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXFxuICpcXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxPd25LZXlzID0gZmFsc2VdXFxuICogQHJldHVybnMge2FueX1cXG4gKi9cXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4sIHthbGxPd25LZXlzID0gZmFsc2V9ID0ge30pIHtcXG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBsZXQgaTtcXG4gIGxldCBsO1xcblxcbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXFxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcXG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXFxuICAgIG9iaiA9IFtvYmpdO1xcbiAgfVxcblxcbiAgaWYgKGlzQXJyYXkob2JqKSkge1xcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXFxuICAgIGZvciAoaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xcbiAgICBjb25zdCBrZXlzID0gYWxsT3duS2V5cyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikgOiBPYmplY3Qua2V5cyhvYmopO1xcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcXG4gICAgbGV0IGtleTtcXG5cXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAga2V5ID0ga2V5c1tpXTtcXG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZmluZEtleShvYmosIGtleSkge1xcbiAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XFxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcXG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XFxuICBsZXQgX2tleTtcXG4gIHdoaWxlIChpLS0gPiAwKSB7XFxuICAgIF9rZXkgPSBrZXlzW2ldO1xcbiAgICBpZiAoa2V5ID09PSBfa2V5LnRvTG93ZXJDYXNlKCkpIHtcXG4gICAgICByZXR1cm4gX2tleTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG51bGw7XFxufVxcblxcbmNvbnN0IF9nbG9iYWwgPSAoKCkgPT4ge1xcbiAgLyplc2xpbnQgbm8tdW5kZWY6MCovXFxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFxcXCJ1bmRlZmluZWRcXFwiKSByZXR1cm4gZ2xvYmFsVGhpcztcXG4gIHJldHVybiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogX193ZWJwYWNrX3JlcXVpcmVfXy5nKVxcbn0pKCk7XFxuXFxuY29uc3QgaXNDb250ZXh0RGVmaW5lZCA9IChjb250ZXh0KSA9PiAhaXNVbmRlZmluZWQoY29udGV4dCkgJiYgY29udGV4dCAhPT0gX2dsb2JhbDtcXG5cXG4vKipcXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXFxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXFxuICpcXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxcbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cXG4gKlxcbiAqIEV4YW1wbGU6XFxuICpcXG4gKiBgYGBqc1xcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcXG4gKiBgYGBcXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxcbiAqXFxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXFxuICovXFxuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XFxuICBjb25zdCB7Y2FzZWxlc3N9ID0gaXNDb250ZXh0RGVmaW5lZCh0aGlzKSAmJiB0aGlzIHx8IHt9O1xcbiAgY29uc3QgcmVzdWx0ID0ge307XFxuICBjb25zdCBhc3NpZ25WYWx1ZSA9ICh2YWwsIGtleSkgPT4ge1xcbiAgICBjb25zdCB0YXJnZXRLZXkgPSBjYXNlbGVzcyAmJiBmaW5kS2V5KHJlc3VsdCwga2V5KSB8fCBrZXk7XFxuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFt0YXJnZXRLZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcXG4gICAgICByZXN1bHRbdGFyZ2V0S2V5XSA9IG1lcmdlKHJlc3VsdFt0YXJnZXRLZXldLCB2YWwpO1xcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xcbiAgICAgIHJlc3VsdFt0YXJnZXRLZXldID0gbWVyZ2Uoe30sIHZhbCk7XFxuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XFxuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSB2YWwuc2xpY2UoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXN1bHRbdGFyZ2V0S2V5XSA9IHZhbDtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBhcmd1bWVudHNbaV0gJiYgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufVxcblxcbi8qKlxcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xcbiAqXFxuICogQHBhcmFtIHtCb29sZWFufSBbYWxsT3duS2V5c11cXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXFxuICovXFxuY29uc3QgZXh0ZW5kID0gKGEsIGIsIHRoaXNBcmcsIHthbGxPd25LZXlzfT0ge30pID0+IHtcXG4gIGZvckVhY2goYiwgKHZhbCwga2V5KSA9PiB7XFxuICAgIGlmICh0aGlzQXJnICYmIGlzRnVuY3Rpb24odmFsKSkge1xcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBhW2tleV0gPSB2YWw7XFxuICAgIH1cXG4gIH0sIHthbGxPd25LZXlzfSk7XFxuICByZXR1cm4gYTtcXG59O1xcblxcbi8qKlxcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cXG4gKlxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cXG4gKi9cXG5jb25zdCBzdHJpcEJPTSA9IChjb250ZW50KSA9PiB7XFxuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcXG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XFxuICB9XFxuICByZXR1cm4gY29udGVudDtcXG59O1xcblxcbi8qKlxcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlclxcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0cnVjdG9yXFxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDb25zdHJ1Y3RvclxcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcHNdXFxuICogQHBhcmFtIHtvYmplY3R9IFtkZXNjcmlwdG9yc11cXG4gKlxcbiAqIEByZXR1cm5zIHt2b2lkfVxcbiAqL1xcbmNvbnN0IGluaGVyaXRzID0gKGNvbnN0cnVjdG9yLCBzdXBlckNvbnN0cnVjdG9yLCBwcm9wcywgZGVzY3JpcHRvcnMpID0+IHtcXG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGRlc2NyaXB0b3JzKTtcXG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnc3VwZXInLCB7XFxuICAgIHZhbHVlOiBzdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZVxcbiAgfSk7XFxuICBwcm9wcyAmJiBPYmplY3QuYXNzaWduKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvcHMpO1xcbn07XFxuXFxuLyoqXFxuICogUmVzb2x2ZSBvYmplY3Qgd2l0aCBkZWVwIHByb3RvdHlwZSBjaGFpbiB0byBhIGZsYXQgb2JqZWN0XFxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZU9iaiBzb3VyY2Ugb2JqZWN0XFxuICogQHBhcmFtIHtPYmplY3R9IFtkZXN0T2JqXVxcbiAqIEBwYXJhbSB7RnVuY3Rpb258Qm9vbGVhbn0gW2ZpbHRlcl1cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcEZpbHRlcl1cXG4gKlxcbiAqIEByZXR1cm5zIHtPYmplY3R9XFxuICovXFxuY29uc3QgdG9GbGF0T2JqZWN0ID0gKHNvdXJjZU9iaiwgZGVzdE9iaiwgZmlsdGVyLCBwcm9wRmlsdGVyKSA9PiB7XFxuICBsZXQgcHJvcHM7XFxuICBsZXQgaTtcXG4gIGxldCBwcm9wO1xcbiAgY29uc3QgbWVyZ2VkID0ge307XFxuXFxuICBkZXN0T2JqID0gZGVzdE9iaiB8fCB7fTtcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLGVxZXFlcVxcbiAgaWYgKHNvdXJjZU9iaiA9PSBudWxsKSByZXR1cm4gZGVzdE9iajtcXG5cXG4gIGRvIHtcXG4gICAgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VPYmopO1xcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xcbiAgICB3aGlsZSAoaS0tID4gMCkge1xcbiAgICAgIHByb3AgPSBwcm9wc1tpXTtcXG4gICAgICBpZiAoKCFwcm9wRmlsdGVyIHx8IHByb3BGaWx0ZXIocHJvcCwgc291cmNlT2JqLCBkZXN0T2JqKSkgJiYgIW1lcmdlZFtwcm9wXSkge1xcbiAgICAgICAgZGVzdE9ialtwcm9wXSA9IHNvdXJjZU9ialtwcm9wXTtcXG4gICAgICAgIG1lcmdlZFtwcm9wXSA9IHRydWU7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHNvdXJjZU9iaiA9IGZpbHRlciAhPT0gZmFsc2UgJiYgZ2V0UHJvdG90eXBlT2Yoc291cmNlT2JqKTtcXG4gIH0gd2hpbGUgKHNvdXJjZU9iaiAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoc291cmNlT2JqLCBkZXN0T2JqKSkgJiYgc291cmNlT2JqICE9PSBPYmplY3QucHJvdG90eXBlKTtcXG5cXG4gIHJldHVybiBkZXN0T2JqO1xcbn07XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGVuZHMgd2l0aCB0aGUgY2hhcmFjdGVycyBvZiBhIHNwZWNpZmllZCBzdHJpbmdcXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoU3RyaW5nXFxuICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbj0gMF1cXG4gKlxcbiAqIEByZXR1cm5zIHtib29sZWFufVxcbiAqL1xcbmNvbnN0IGVuZHNXaXRoID0gKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikgPT4ge1xcbiAgc3RyID0gU3RyaW5nKHN0cik7XFxuICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA+IHN0ci5sZW5ndGgpIHtcXG4gICAgcG9zaXRpb24gPSBzdHIubGVuZ3RoO1xcbiAgfVxcbiAgcG9zaXRpb24gLT0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcXG4gIGNvbnN0IGxhc3RJbmRleCA9IHN0ci5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xcbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcXG59O1xcblxcblxcbi8qKlxcbiAqIFJldHVybnMgbmV3IGFycmF5IGZyb20gYXJyYXkgbGlrZSBvYmplY3Qgb3IgbnVsbCBpZiBmYWlsZWRcXG4gKlxcbiAqIEBwYXJhbSB7Kn0gW3RoaW5nXVxcbiAqXFxuICogQHJldHVybnMgez9BcnJheX1cXG4gKi9cXG5jb25zdCB0b0FycmF5ID0gKHRoaW5nKSA9PiB7XFxuICBpZiAoIXRoaW5nKSByZXR1cm4gbnVsbDtcXG4gIGlmIChpc0FycmF5KHRoaW5nKSkgcmV0dXJuIHRoaW5nO1xcbiAgbGV0IGkgPSB0aGluZy5sZW5ndGg7XFxuICBpZiAoIWlzTnVtYmVyKGkpKSByZXR1cm4gbnVsbDtcXG4gIGNvbnN0IGFyciA9IG5ldyBBcnJheShpKTtcXG4gIHdoaWxlIChpLS0gPiAwKSB7XFxuICAgIGFycltpXSA9IHRoaW5nW2ldO1xcbiAgfVxcbiAgcmV0dXJuIGFycjtcXG59O1xcblxcbi8qKlxcbiAqIENoZWNraW5nIGlmIHRoZSBVaW50OEFycmF5IGV4aXN0cyBhbmQgaWYgaXQgZG9lcywgaXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZVxcbiAqIHRoaW5nIHBhc3NlZCBpbiBpcyBhbiBpbnN0YW5jZSBvZiBVaW50OEFycmF5XFxuICpcXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9XFxuICpcXG4gKiBAcmV0dXJucyB7QXJyYXl9XFxuICovXFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcXG5jb25zdCBpc1R5cGVkQXJyYXkgPSAoVHlwZWRBcnJheSA9PiB7XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xcbiAgcmV0dXJuIHRoaW5nID0+IHtcXG4gICAgcmV0dXJuIFR5cGVkQXJyYXkgJiYgdGhpbmcgaW5zdGFuY2VvZiBUeXBlZEFycmF5O1xcbiAgfTtcXG59KSh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSkpO1xcblxcbi8qKlxcbiAqIEZvciBlYWNoIGVudHJ5IGluIHRoZSBvYmplY3QsIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGtleSBhbmQgdmFsdWUuXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdDxhbnksIGFueT59IG9iaiAtIFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggZW50cnkuXFxuICpcXG4gKiBAcmV0dXJucyB7dm9pZH1cXG4gKi9cXG5jb25zdCBmb3JFYWNoRW50cnkgPSAob2JqLCBmbikgPT4ge1xcbiAgY29uc3QgZ2VuZXJhdG9yID0gb2JqICYmIG9ialtTeW1ib2wuaXRlcmF0b3JdO1xcblxcbiAgY29uc3QgaXRlcmF0b3IgPSBnZW5lcmF0b3IuY2FsbChvYmopO1xcblxcbiAgbGV0IHJlc3VsdDtcXG5cXG4gIHdoaWxlICgocmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpKSAmJiAhcmVzdWx0LmRvbmUpIHtcXG4gICAgY29uc3QgcGFpciA9IHJlc3VsdC52YWx1ZTtcXG4gICAgZm4uY2FsbChvYmosIHBhaXJbMF0sIHBhaXJbMV0pO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogSXQgdGFrZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gYW5kIGEgc3RyaW5nLCBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXNcXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdFeHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFnYWluc3QuXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxcbiAqXFxuICogQHJldHVybnMge0FycmF5PGJvb2xlYW4+fVxcbiAqL1xcbmNvbnN0IG1hdGNoQWxsID0gKHJlZ0V4cCwgc3RyKSA9PiB7XFxuICBsZXQgbWF0Y2hlcztcXG4gIGNvbnN0IGFyciA9IFtdO1xcblxcbiAgd2hpbGUgKChtYXRjaGVzID0gcmVnRXhwLmV4ZWMoc3RyKSkgIT09IG51bGwpIHtcXG4gICAgYXJyLnB1c2gobWF0Y2hlcyk7XFxuICB9XFxuXFxuICByZXR1cm4gYXJyO1xcbn07XFxuXFxuLyogQ2hlY2tpbmcgaWYgdGhlIGtpbmRPZlRlc3QgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHdoZW4gcGFzc2VkIGFuIEhUTUxGb3JtRWxlbWVudC4gKi9cXG5jb25zdCBpc0hUTUxGb3JtID0ga2luZE9mVGVzdCgnSFRNTEZvcm1FbGVtZW50Jyk7XFxuXFxuY29uc3QgdG9DYW1lbENhc2UgPSBzdHIgPT4ge1xcbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX1xcXFxzXShbYS16XFxcXGRdKShcXFxcdyopL2csXFxuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKG0sIHAxLCBwMikge1xcbiAgICAgIHJldHVybiBwMS50b1VwcGVyQ2FzZSgpICsgcDI7XFxuICAgIH1cXG4gICk7XFxufTtcXG5cXG4vKiBDcmVhdGluZyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjaGVjayBpZiBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuICovXFxuY29uc3QgaGFzT3duUHJvcGVydHkgPSAoKHtoYXNPd25Qcm9wZXJ0eX0pID0+IChvYmosIHByb3ApID0+IGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkoT2JqZWN0LnByb3RvdHlwZSk7XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0XFxuICpcXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxcbiAqXFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcXG4gKi9cXG5jb25zdCBpc1JlZ0V4cCA9IGtpbmRPZlRlc3QoJ1JlZ0V4cCcpO1xcblxcbmNvbnN0IHJlZHVjZURlc2NyaXB0b3JzID0gKG9iaiwgcmVkdWNlcikgPT4ge1xcbiAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopO1xcbiAgY29uc3QgcmVkdWNlZERlc2NyaXB0b3JzID0ge307XFxuXFxuICBmb3JFYWNoKGRlc2NyaXB0b3JzLCAoZGVzY3JpcHRvciwgbmFtZSkgPT4ge1xcbiAgICBsZXQgcmV0O1xcbiAgICBpZiAoKHJldCA9IHJlZHVjZXIoZGVzY3JpcHRvciwgbmFtZSwgb2JqKSkgIT09IGZhbHNlKSB7XFxuICAgICAgcmVkdWNlZERlc2NyaXB0b3JzW25hbWVdID0gcmV0IHx8IGRlc2NyaXB0b3I7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCByZWR1Y2VkRGVzY3JpcHRvcnMpO1xcbn07XFxuXFxuLyoqXFxuICogTWFrZXMgYWxsIG1ldGhvZHMgcmVhZC1vbmx5XFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxcbiAqL1xcblxcbmNvbnN0IGZyZWV6ZU1ldGhvZHMgPSAob2JqKSA9PiB7XFxuICByZWR1Y2VEZXNjcmlwdG9ycyhvYmosIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XFxuICAgIC8vIHNraXAgcmVzdHJpY3RlZCBwcm9wcyBpbiBzdHJpY3QgbW9kZVxcbiAgICBpZiAoaXNGdW5jdGlvbihvYmopICYmIFsnYXJndW1lbnRzJywgJ2NhbGxlcicsICdjYWxsZWUnXS5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBjb25zdCB2YWx1ZSA9IG9ialtuYW1lXTtcXG5cXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuO1xcblxcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBmYWxzZTtcXG5cXG4gICAgaWYgKCd3cml0YWJsZScgaW4gZGVzY3JpcHRvcikge1xcbiAgICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSBmYWxzZTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKCFkZXNjcmlwdG9yLnNldCkge1xcbiAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gKCkgPT4ge1xcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0NhbiBub3QgcmV3cml0ZSByZWFkLW9ubHkgbWV0aG9kIFxcXFwnJyArIG5hbWUgKyAnXFxcXCcnKTtcXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG59O1xcblxcbmNvbnN0IHRvT2JqZWN0U2V0ID0gKGFycmF5T3JTdHJpbmcsIGRlbGltaXRlcikgPT4ge1xcbiAgY29uc3Qgb2JqID0ge307XFxuXFxuICBjb25zdCBkZWZpbmUgPSAoYXJyKSA9PiB7XFxuICAgIGFyci5mb3JFYWNoKHZhbHVlID0+IHtcXG4gICAgICBvYmpbdmFsdWVdID0gdHJ1ZTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgaXNBcnJheShhcnJheU9yU3RyaW5nKSA/IGRlZmluZShhcnJheU9yU3RyaW5nKSA6IGRlZmluZShTdHJpbmcoYXJyYXlPclN0cmluZykuc3BsaXQoZGVsaW1pdGVyKSk7XFxuXFxuICByZXR1cm4gb2JqO1xcbn07XFxuXFxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xcblxcbmNvbnN0IHRvRmluaXRlTnVtYmVyID0gKHZhbHVlLCBkZWZhdWx0VmFsdWUpID0+IHtcXG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSA9ICt2YWx1ZSkgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcXG59O1xcblxcbmNvbnN0IEFMUEhBID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcXG5cXG5jb25zdCBESUdJVCA9ICcwMTIzNDU2Nzg5JztcXG5cXG5jb25zdCBBTFBIQUJFVCA9IHtcXG4gIERJR0lULFxcbiAgQUxQSEEsXFxuICBBTFBIQV9ESUdJVDogQUxQSEEgKyBBTFBIQS50b1VwcGVyQ2FzZSgpICsgRElHSVRcXG59O1xcblxcbmNvbnN0IGdlbmVyYXRlU3RyaW5nID0gKHNpemUgPSAxNiwgYWxwaGFiZXQgPSBBTFBIQUJFVC5BTFBIQV9ESUdJVCkgPT4ge1xcbiAgbGV0IHN0ciA9ICcnO1xcbiAgY29uc3Qge2xlbmd0aH0gPSBhbHBoYWJldDtcXG4gIHdoaWxlIChzaXplLS0pIHtcXG4gICAgc3RyICs9IGFscGhhYmV0W01hdGgucmFuZG9tKCkgKiBsZW5ndGh8MF07XFxuICB9XFxuXFxuICByZXR1cm4gc3RyO1xcbn07XFxuXFxuLyoqXFxuICogSWYgdGhlIHRoaW5nIGlzIGEgRm9ybURhdGEgb2JqZWN0LCByZXR1cm4gdHJ1ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cXG4gKlxcbiAqIEBwYXJhbSB7dW5rbm93bn0gdGhpbmcgLSBUaGUgdGhpbmcgdG8gY2hlY2suXFxuICpcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cXG4gKi9cXG5mdW5jdGlvbiBpc1NwZWNDb21wbGlhbnRGb3JtKHRoaW5nKSB7XFxuICByZXR1cm4gISEodGhpbmcgJiYgaXNGdW5jdGlvbih0aGluZy5hcHBlbmQpICYmIHRoaW5nW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGb3JtRGF0YScgJiYgdGhpbmdbU3ltYm9sLml0ZXJhdG9yXSk7XFxufVxcblxcbmNvbnN0IHRvSlNPTk9iamVjdCA9IChvYmopID0+IHtcXG4gIGNvbnN0IHN0YWNrID0gbmV3IEFycmF5KDEwKTtcXG5cXG4gIGNvbnN0IHZpc2l0ID0gKHNvdXJjZSwgaSkgPT4ge1xcblxcbiAgICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xcbiAgICAgIGlmIChzdGFjay5pbmRleE9mKHNvdXJjZSkgPj0gMCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZighKCd0b0pTT04nIGluIHNvdXJjZSkpIHtcXG4gICAgICAgIHN0YWNrW2ldID0gc291cmNlO1xcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gaXNBcnJheShzb3VyY2UpID8gW10gOiB7fTtcXG5cXG4gICAgICAgIGZvckVhY2goc291cmNlLCAodmFsdWUsIGtleSkgPT4ge1xcbiAgICAgICAgICBjb25zdCByZWR1Y2VkVmFsdWUgPSB2aXNpdCh2YWx1ZSwgaSArIDEpO1xcbiAgICAgICAgICAhaXNVbmRlZmluZWQocmVkdWNlZFZhbHVlKSAmJiAodGFyZ2V0W2tleV0gPSByZWR1Y2VkVmFsdWUpO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBzdGFja1tpXSA9IHVuZGVmaW5lZDtcXG5cXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBzb3VyY2U7XFxuICB9O1xcblxcbiAgcmV0dXJuIHZpc2l0KG9iaiwgMCk7XFxufTtcXG5cXG5jb25zdCBpc0FzeW5jRm4gPSBraW5kT2ZUZXN0KCdBc3luY0Z1bmN0aW9uJyk7XFxuXFxuY29uc3QgaXNUaGVuYWJsZSA9ICh0aGluZykgPT5cXG4gIHRoaW5nICYmIChpc09iamVjdCh0aGluZykgfHwgaXNGdW5jdGlvbih0aGluZykpICYmIGlzRnVuY3Rpb24odGhpbmcudGhlbikgJiYgaXNGdW5jdGlvbih0aGluZy5jYXRjaCk7XFxuXFxudmFyIHV0aWxzJDEgPSB7XFxuICBpc0FycmF5LFxcbiAgaXNBcnJheUJ1ZmZlcixcXG4gIGlzQnVmZmVyLFxcbiAgaXNGb3JtRGF0YSxcXG4gIGlzQXJyYXlCdWZmZXJWaWV3LFxcbiAgaXNTdHJpbmcsXFxuICBpc051bWJlcixcXG4gIGlzQm9vbGVhbixcXG4gIGlzT2JqZWN0LFxcbiAgaXNQbGFpbk9iamVjdCxcXG4gIGlzUmVhZGFibGVTdHJlYW0sXFxuICBpc1JlcXVlc3QsXFxuICBpc1Jlc3BvbnNlLFxcbiAgaXNIZWFkZXJzLFxcbiAgaXNVbmRlZmluZWQsXFxuICBpc0RhdGUsXFxuICBpc0ZpbGUsXFxuICBpc0Jsb2IsXFxuICBpc1JlZ0V4cCxcXG4gIGlzRnVuY3Rpb24sXFxuICBpc1N0cmVhbSxcXG4gIGlzVVJMU2VhcmNoUGFyYW1zLFxcbiAgaXNUeXBlZEFycmF5LFxcbiAgaXNGaWxlTGlzdCxcXG4gIGZvckVhY2gsXFxuICBtZXJnZSxcXG4gIGV4dGVuZCxcXG4gIHRyaW0sXFxuICBzdHJpcEJPTSxcXG4gIGluaGVyaXRzLFxcbiAgdG9GbGF0T2JqZWN0LFxcbiAga2luZE9mLFxcbiAga2luZE9mVGVzdCxcXG4gIGVuZHNXaXRoLFxcbiAgdG9BcnJheSxcXG4gIGZvckVhY2hFbnRyeSxcXG4gIG1hdGNoQWxsLFxcbiAgaXNIVE1MRm9ybSxcXG4gIGhhc093blByb3BlcnR5LFxcbiAgaGFzT3duUHJvcDogaGFzT3duUHJvcGVydHksIC8vIGFuIGFsaWFzIHRvIGF2b2lkIEVTTGludCBuby1wcm90b3R5cGUtYnVpbHRpbnMgZGV0ZWN0aW9uXFxuICByZWR1Y2VEZXNjcmlwdG9ycyxcXG4gIGZyZWV6ZU1ldGhvZHMsXFxuICB0b09iamVjdFNldCxcXG4gIHRvQ2FtZWxDYXNlLFxcbiAgbm9vcCxcXG4gIHRvRmluaXRlTnVtYmVyLFxcbiAgZmluZEtleSxcXG4gIGdsb2JhbDogX2dsb2JhbCxcXG4gIGlzQ29udGV4dERlZmluZWQsXFxuICBBTFBIQUJFVCxcXG4gIGdlbmVyYXRlU3RyaW5nLFxcbiAgaXNTcGVjQ29tcGxpYW50Rm9ybSxcXG4gIHRvSlNPTk9iamVjdCxcXG4gIGlzQXN5bmNGbixcXG4gIGlzVGhlbmFibGVcXG59O1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXFxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIFRoZSBjb25maWcuXFxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXFxuICpcXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxcbiAqL1xcbmZ1bmN0aW9uIEF4aW9zRXJyb3IobWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSkge1xcbiAgRXJyb3IuY2FsbCh0aGlzKTtcXG5cXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xcbiAgfVxcblxcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcXG4gIHRoaXMubmFtZSA9ICdBeGlvc0Vycm9yJztcXG4gIGNvZGUgJiYgKHRoaXMuY29kZSA9IGNvZGUpO1xcbiAgY29uZmlnICYmICh0aGlzLmNvbmZpZyA9IGNvbmZpZyk7XFxuICByZXF1ZXN0ICYmICh0aGlzLnJlcXVlc3QgPSByZXF1ZXN0KTtcXG4gIHJlc3BvbnNlICYmICh0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2UpO1xcbn1cXG5cXG51dGlscyQxLmluaGVyaXRzKEF4aW9zRXJyb3IsIEVycm9yLCB7XFxuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAvLyBTdGFuZGFyZFxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXFxuICAgICAgLy8gTWljcm9zb2Z0XFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcXG4gICAgICAvLyBNb3ppbGxhXFxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXFxuICAgICAgLy8gQXhpb3NcXG4gICAgICBjb25maWc6IHV0aWxzJDEudG9KU09OT2JqZWN0KHRoaXMuY29uZmlnKSxcXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXFxuICAgICAgc3RhdHVzOiB0aGlzLnJlc3BvbnNlICYmIHRoaXMucmVzcG9uc2Uuc3RhdHVzID8gdGhpcy5yZXNwb25zZS5zdGF0dXMgOiBudWxsXFxuICAgIH07XFxuICB9XFxufSk7XFxuXFxuY29uc3QgcHJvdG90eXBlJDEgPSBBeGlvc0Vycm9yLnByb3RvdHlwZTtcXG5jb25zdCBkZXNjcmlwdG9ycyA9IHt9O1xcblxcbltcXG4gICdFUlJfQkFEX09QVElPTl9WQUxVRScsXFxuICAnRVJSX0JBRF9PUFRJT04nLFxcbiAgJ0VDT05OQUJPUlRFRCcsXFxuICAnRVRJTUVET1VUJyxcXG4gICdFUlJfTkVUV09SSycsXFxuICAnRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUUycsXFxuICAnRVJSX0RFUFJFQ0FURUQnLFxcbiAgJ0VSUl9CQURfUkVTUE9OU0UnLFxcbiAgJ0VSUl9CQURfUkVRVUVTVCcsXFxuICAnRVJSX0NBTkNFTEVEJyxcXG4gICdFUlJfTk9UX1NVUFBPUlQnLFxcbiAgJ0VSUl9JTlZBTElEX1VSTCdcXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xcbl0uZm9yRWFjaChjb2RlID0+IHtcXG4gIGRlc2NyaXB0b3JzW2NvZGVdID0ge3ZhbHVlOiBjb2RlfTtcXG59KTtcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBeGlvc0Vycm9yLCBkZXNjcmlwdG9ycyk7XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSQxLCAnaXNBeGlvc0Vycm9yJywge3ZhbHVlOiB0cnVlfSk7XFxuXFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcXG5BeGlvc0Vycm9yLmZyb20gPSAoZXJyb3IsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UsIGN1c3RvbVByb3BzKSA9PiB7XFxuICBjb25zdCBheGlvc0Vycm9yID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUkMSk7XFxuXFxuICB1dGlscyQxLnRvRmxhdE9iamVjdChlcnJvciwgYXhpb3NFcnJvciwgZnVuY3Rpb24gZmlsdGVyKG9iaikge1xcbiAgICByZXR1cm4gb2JqICE9PSBFcnJvci5wcm90b3R5cGU7XFxuICB9LCBwcm9wID0+IHtcXG4gICAgcmV0dXJuIHByb3AgIT09ICdpc0F4aW9zRXJyb3InO1xcbiAgfSk7XFxuXFxuICBBeGlvc0Vycm9yLmNhbGwoYXhpb3NFcnJvciwgZXJyb3IubWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSk7XFxuXFxuICBheGlvc0Vycm9yLmNhdXNlID0gZXJyb3I7XFxuXFxuICBheGlvc0Vycm9yLm5hbWUgPSBlcnJvci5uYW1lO1xcblxcbiAgY3VzdG9tUHJvcHMgJiYgT2JqZWN0LmFzc2lnbihheGlvc0Vycm9yLCBjdXN0b21Qcm9wcyk7XFxuXFxuICByZXR1cm4gYXhpb3NFcnJvcjtcXG59O1xcblxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzdHJpY3RcXG52YXIgaHR0cEFkYXB0ZXIgPSBudWxsO1xcblxcbi8qKlxcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHRoaW5nIGlzIGEgYXJyYXkgb3IganMgb2JqZWN0LlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHRoaW5nIC0gVGhlIG9iamVjdCBvciBhcnJheSB0byBiZSB2aXNpdGVkLlxcbiAqXFxuICogQHJldHVybnMge2Jvb2xlYW59XFxuICovXFxuZnVuY3Rpb24gaXNWaXNpdGFibGUodGhpbmcpIHtcXG4gIHJldHVybiB1dGlscyQxLmlzUGxhaW5PYmplY3QodGhpbmcpIHx8IHV0aWxzJDEuaXNBcnJheSh0aGluZyk7XFxufVxcblxcbi8qKlxcbiAqIEl0IHJlbW92ZXMgdGhlIGJyYWNrZXRzIGZyb20gdGhlIGVuZCBvZiBhIHN0cmluZ1xcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIHBhcmFtZXRlci5cXG4gKlxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBrZXkgd2l0aG91dCB0aGUgYnJhY2tldHMuXFxuICovXFxuZnVuY3Rpb24gcmVtb3ZlQnJhY2tldHMoa2V5KSB7XFxuICByZXR1cm4gdXRpbHMkMS5lbmRzV2l0aChrZXksICdbXScpID8ga2V5LnNsaWNlKDAsIC0yKSA6IGtleTtcXG59XFxuXFxuLyoqXFxuICogSXQgdGFrZXMgYSBwYXRoLCBhIGtleSwgYW5kIGEgYm9vbGVhbiwgYW5kIHJldHVybnMgYSBzdHJpbmdcXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQga2V5LlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBjdXJyZW50IG9iamVjdCBiZWluZyBpdGVyYXRlZCBvdmVyLlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb3RzIC0gSWYgdHJ1ZSwgdGhlIGtleSB3aWxsIGJlIHJlbmRlcmVkIHdpdGggZG90cyBpbnN0ZWFkIG9mIGJyYWNrZXRzLlxcbiAqXFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQga2V5LlxcbiAqL1xcbmZ1bmN0aW9uIHJlbmRlcktleShwYXRoLCBrZXksIGRvdHMpIHtcXG4gIGlmICghcGF0aCkgcmV0dXJuIGtleTtcXG4gIHJldHVybiBwYXRoLmNvbmNhdChrZXkpLm1hcChmdW5jdGlvbiBlYWNoKHRva2VuLCBpKSB7XFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxcbiAgICB0b2tlbiA9IHJlbW92ZUJyYWNrZXRzKHRva2VuKTtcXG4gICAgcmV0dXJuICFkb3RzICYmIGkgPyAnWycgKyB0b2tlbiArICddJyA6IHRva2VuO1xcbiAgfSkuam9pbihkb3RzID8gJy4nIDogJycpO1xcbn1cXG5cXG4vKipcXG4gKiBJZiB0aGUgYXJyYXkgaXMgYW4gYXJyYXkgYW5kIG5vbmUgb2YgaXRzIGVsZW1lbnRzIGFyZSB2aXNpdGFibGUsIHRoZW4gaXQncyBhIGZsYXQgYXJyYXkuXFxuICpcXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGFyciAtIFRoZSBhcnJheSB0byBjaGVja1xcbiAqXFxuICogQHJldHVybnMge2Jvb2xlYW59XFxuICovXFxuZnVuY3Rpb24gaXNGbGF0QXJyYXkoYXJyKSB7XFxuICByZXR1cm4gdXRpbHMkMS5pc0FycmF5KGFycikgJiYgIWFyci5zb21lKGlzVmlzaXRhYmxlKTtcXG59XFxuXFxuY29uc3QgcHJlZGljYXRlcyA9IHV0aWxzJDEudG9GbGF0T2JqZWN0KHV0aWxzJDEsIHt9LCBudWxsLCBmdW5jdGlvbiBmaWx0ZXIocHJvcCkge1xcbiAgcmV0dXJuIC9eaXNbQS1aXS8udGVzdChwcm9wKTtcXG59KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgZGF0YSBvYmplY3QgdG8gRm9ybURhdGFcXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcXG4gKiBAcGFyYW0gez9PYmplY3R9IFtmb3JtRGF0YV1cXG4gKiBAcGFyYW0gez9PYmplY3R9IFtvcHRpb25zXVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnZpc2l0b3JdXFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tZXRhVG9rZW5zID0gdHJ1ZV1cXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRvdHMgPSBmYWxzZV1cXG4gKiBAcGFyYW0gez9Cb29sZWFufSBbb3B0aW9ucy5pbmRleGVzID0gZmFsc2VdXFxuICpcXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxcbiAqKi9cXG5cXG4vKipcXG4gKiBJdCBjb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIEZvcm1EYXRhIG9iamVjdFxcbiAqXFxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgdG8gZm9ybSBkYXRhLlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtRGF0YSAtIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gYXBwZW5kIHRvLlxcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gb3B0aW9uc1xcbiAqXFxuICogQHJldHVybnNcXG4gKi9cXG5mdW5jdGlvbiB0b0Zvcm1EYXRhKG9iaiwgZm9ybURhdGEsIG9wdGlvbnMpIHtcXG4gIGlmICghdXRpbHMkMS5pc09iamVjdChvYmopKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCcpO1xcbiAgfVxcblxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXFxuICBmb3JtRGF0YSA9IGZvcm1EYXRhIHx8IG5ldyAoRm9ybURhdGEpKCk7XFxuXFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cXG4gIG9wdGlvbnMgPSB1dGlscyQxLnRvRmxhdE9iamVjdChvcHRpb25zLCB7XFxuICAgIG1ldGFUb2tlbnM6IHRydWUsXFxuICAgIGRvdHM6IGZhbHNlLFxcbiAgICBpbmRleGVzOiBmYWxzZVxcbiAgfSwgZmFsc2UsIGZ1bmN0aW9uIGRlZmluZWQob3B0aW9uLCBzb3VyY2UpIHtcXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXFxuICAgIHJldHVybiAhdXRpbHMkMS5pc1VuZGVmaW5lZChzb3VyY2Vbb3B0aW9uXSk7XFxuICB9KTtcXG5cXG4gIGNvbnN0IG1ldGFUb2tlbnMgPSBvcHRpb25zLm1ldGFUb2tlbnM7XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcXG4gIGNvbnN0IHZpc2l0b3IgPSBvcHRpb25zLnZpc2l0b3IgfHwgZGVmYXVsdFZpc2l0b3I7XFxuICBjb25zdCBkb3RzID0gb3B0aW9ucy5kb3RzO1xcbiAgY29uc3QgaW5kZXhlcyA9IG9wdGlvbnMuaW5kZXhlcztcXG4gIGNvbnN0IF9CbG9iID0gb3B0aW9ucy5CbG9iIHx8IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBCbG9iO1xcbiAgY29uc3QgdXNlQmxvYiA9IF9CbG9iICYmIHV0aWxzJDEuaXNTcGVjQ29tcGxpYW50Rm9ybShmb3JtRGF0YSk7XFxuXFxuICBpZiAoIXV0aWxzJDEuaXNGdW5jdGlvbih2aXNpdG9yKSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2aXNpdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY29udmVydFZhbHVlKHZhbHVlKSB7XFxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuICcnO1xcblxcbiAgICBpZiAodXRpbHMkMS5pc0RhdGUodmFsdWUpKSB7XFxuICAgICAgcmV0dXJuIHZhbHVlLnRvSVNPU3RyaW5nKCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKCF1c2VCbG9iICYmIHV0aWxzJDEuaXNCbG9iKHZhbHVlKSkge1xcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdCbG9iIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhIEJ1ZmZlciBpbnN0ZWFkLicpO1xcbiAgICB9XFxuXFxuICAgIGlmICh1dGlscyQxLmlzQXJyYXlCdWZmZXIodmFsdWUpIHx8IHV0aWxzJDEuaXNUeXBlZEFycmF5KHZhbHVlKSkge1xcbiAgICAgIHJldHVybiB1c2VCbG9iICYmIHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nID8gbmV3IEJsb2IoW3ZhbHVlXSkgOiBCdWZmZXIuZnJvbSh2YWx1ZSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHZhbHVlO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBEZWZhdWx0IHZpc2l0b3IuXFxuICAgKlxcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXlcXG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nfE51bWJlcj59IHBhdGhcXG4gICAqIEB0aGlzIHtGb3JtRGF0YX1cXG4gICAqXFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJuIHRydWUgdG8gdmlzaXQgdGhlIGVhY2ggcHJvcCBvZiB0aGUgdmFsdWUgcmVjdXJzaXZlbHlcXG4gICAqL1xcbiAgZnVuY3Rpb24gZGVmYXVsdFZpc2l0b3IodmFsdWUsIGtleSwgcGF0aCkge1xcbiAgICBsZXQgYXJyID0gdmFsdWU7XFxuXFxuICAgIGlmICh2YWx1ZSAmJiAhcGF0aCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XFxuICAgICAgaWYgKHV0aWxzJDEuZW5kc1dpdGgoa2V5LCAne30nKSkge1xcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXFxuICAgICAgICBrZXkgPSBtZXRhVG9rZW5zID8ga2V5IDoga2V5LnNsaWNlKDAsIC0yKTtcXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxcbiAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XFxuICAgICAgfSBlbHNlIGlmIChcXG4gICAgICAgICh1dGlscyQxLmlzQXJyYXkodmFsdWUpICYmIGlzRmxhdEFycmF5KHZhbHVlKSkgfHxcXG4gICAgICAgICgodXRpbHMkMS5pc0ZpbGVMaXN0KHZhbHVlKSB8fCB1dGlscyQxLmVuZHNXaXRoKGtleSwgJ1tdJykpICYmIChhcnIgPSB1dGlscyQxLnRvQXJyYXkodmFsdWUpKVxcbiAgICAgICAgKSkge1xcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXFxuICAgICAgICBrZXkgPSByZW1vdmVCcmFja2V0cyhrZXkpO1xcblxcbiAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gZWFjaChlbCwgaW5kZXgpIHtcXG4gICAgICAgICAgISh1dGlscyQxLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgZm9ybURhdGEuYXBwZW5kKFxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxcbiAgICAgICAgICAgIGluZGV4ZXMgPT09IHRydWUgPyByZW5kZXJLZXkoW2tleV0sIGluZGV4LCBkb3RzKSA6IChpbmRleGVzID09PSBudWxsID8ga2V5IDoga2V5ICsgJ1tdJyksXFxuICAgICAgICAgICAgY29udmVydFZhbHVlKGVsKVxcbiAgICAgICAgICApO1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChpc1Zpc2l0YWJsZSh2YWx1ZSkpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBmb3JtRGF0YS5hcHBlbmQocmVuZGVyS2V5KHBhdGgsIGtleSwgZG90cyksIGNvbnZlcnRWYWx1ZSh2YWx1ZSkpO1xcblxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICBjb25zdCBzdGFjayA9IFtdO1xcblxcbiAgY29uc3QgZXhwb3NlZEhlbHBlcnMgPSBPYmplY3QuYXNzaWduKHByZWRpY2F0ZXMsIHtcXG4gICAgZGVmYXVsdFZpc2l0b3IsXFxuICAgIGNvbnZlcnRWYWx1ZSxcXG4gICAgaXNWaXNpdGFibGVcXG4gIH0pO1xcblxcbiAgZnVuY3Rpb24gYnVpbGQodmFsdWUsIHBhdGgpIHtcXG4gICAgaWYgKHV0aWxzJDEuaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XFxuXFxuICAgIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcXG4gICAgICB0aHJvdyBFcnJvcignQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkIGluICcgKyBwYXRoLmpvaW4oJy4nKSk7XFxuICAgIH1cXG5cXG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XFxuXFxuICAgIHV0aWxzJDEuZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gZWFjaChlbCwga2V5KSB7XFxuICAgICAgY29uc3QgcmVzdWx0ID0gISh1dGlscyQxLmlzVW5kZWZpbmVkKGVsKSB8fCBlbCA9PT0gbnVsbCkgJiYgdmlzaXRvci5jYWxsKFxcbiAgICAgICAgZm9ybURhdGEsIGVsLCB1dGlscyQxLmlzU3RyaW5nKGtleSkgPyBrZXkudHJpbSgpIDoga2V5LCBwYXRoLCBleHBvc2VkSGVscGVyc1xcbiAgICAgICk7XFxuXFxuICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xcbiAgICAgICAgYnVpbGQoZWwsIHBhdGggPyBwYXRoLmNvbmNhdChrZXkpIDogW2tleV0pO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIHN0YWNrLnBvcCgpO1xcbiAgfVxcblxcbiAgaWYgKCF1dGlscyQxLmlzT2JqZWN0KG9iaikpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xcbiAgfVxcblxcbiAgYnVpbGQob2JqKTtcXG5cXG4gIHJldHVybiBmb3JtRGF0YTtcXG59XFxuXFxuLyoqXFxuICogSXQgZW5jb2RlcyBhIHN0cmluZyBieSByZXBsYWNpbmcgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IGluIHRoZSB1bnJlc2VydmVkIHNldCB3aXRoXFxuICogdGhlaXIgcGVyY2VudC1lbmNvZGVkIGVxdWl2YWxlbnRzXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBlbmNvZGUuXFxuICpcXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCBzdHJpbmcuXFxuICovXFxuZnVuY3Rpb24gZW5jb2RlJDEoc3RyKSB7XFxuICBjb25zdCBjaGFyTWFwID0ge1xcbiAgICAnISc6ICclMjEnLFxcbiAgICBcXFwiJ1xcXCI6ICclMjcnLFxcbiAgICAnKCc6ICclMjgnLFxcbiAgICAnKSc6ICclMjknLFxcbiAgICAnfic6ICclN0UnLFxcbiAgICAnJTIwJzogJysnLFxcbiAgICAnJTAwJzogJ1xcXFx4MDAnXFxuICB9O1xcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpfl18JTIwfCUwMC9nLCBmdW5jdGlvbiByZXBsYWNlcihtYXRjaCkge1xcbiAgICByZXR1cm4gY2hhck1hcFttYXRjaF07XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogSXQgdGFrZXMgYSBwYXJhbXMgb2JqZWN0IGFuZCBjb252ZXJ0cyBpdCB0byBhIEZvcm1EYXRhIG9iamVjdFxcbiAqXFxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBGb3JtRGF0YSBvYmplY3QuXFxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB0byB0aGUgQXhpb3MgY29uc3RydWN0b3IuXFxuICpcXG4gKiBAcmV0dXJucyB7dm9pZH1cXG4gKi9cXG5mdW5jdGlvbiBBeGlvc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpIHtcXG4gIHRoaXMuX3BhaXJzID0gW107XFxuXFxuICBwYXJhbXMgJiYgdG9Gb3JtRGF0YShwYXJhbXMsIHRoaXMsIG9wdGlvbnMpO1xcbn1cXG5cXG5jb25zdCBwcm90b3R5cGUgPSBBeGlvc1VSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGU7XFxuXFxucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xcbiAgdGhpcy5fcGFpcnMucHVzaChbbmFtZSwgdmFsdWVdKTtcXG59O1xcblxcbnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGVuY29kZXIpIHtcXG4gIGNvbnN0IF9lbmNvZGUgPSBlbmNvZGVyID8gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgcmV0dXJuIGVuY29kZXIuY2FsbCh0aGlzLCB2YWx1ZSwgZW5jb2RlJDEpO1xcbiAgfSA6IGVuY29kZSQxO1xcblxcbiAgcmV0dXJuIHRoaXMuX3BhaXJzLm1hcChmdW5jdGlvbiBlYWNoKHBhaXIpIHtcXG4gICAgcmV0dXJuIF9lbmNvZGUocGFpclswXSkgKyAnPScgKyBfZW5jb2RlKHBhaXJbMV0pO1xcbiAgfSwgJycpLmpvaW4oJyYnKTtcXG59O1xcblxcbi8qKlxcbiAqIEl0IHJlcGxhY2VzIGFsbCBpbnN0YW5jZXMgb2YgdGhlIGNoYXJhY3RlcnMgYDpgLCBgJGAsIGAsYCwgYCtgLCBgW2AsIGFuZCBgXWAgd2l0aCB0aGVpclxcbiAqIFVSSSBlbmNvZGVkIGNvdW50ZXJwYXJ0c1xcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbCBUaGUgdmFsdWUgdG8gYmUgZW5jb2RlZC5cXG4gKlxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHZhbHVlLlxcbiAqL1xcbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcXG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxcbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxcbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxcbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XFxufVxcblxcbi8qKlxcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXFxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcXG4gKiBAcGFyYW0gez9vYmplY3R9IG9wdGlvbnNcXG4gKlxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXFxuICovXFxuZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIG9wdGlvbnMpIHtcXG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xcbiAgaWYgKCFwYXJhbXMpIHtcXG4gICAgcmV0dXJuIHVybDtcXG4gIH1cXG4gIFxcbiAgY29uc3QgX2VuY29kZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGUgfHwgZW5jb2RlO1xcblxcbiAgY29uc3Qgc2VyaWFsaXplRm4gPSBvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplO1xcblxcbiAgbGV0IHNlcmlhbGl6ZWRQYXJhbXM7XFxuXFxuICBpZiAoc2VyaWFsaXplRm4pIHtcXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHNlcmlhbGl6ZUZuKHBhcmFtcywgb3B0aW9ucyk7XFxuICB9IGVsc2Uge1xcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gdXRpbHMkMS5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpID9cXG4gICAgICBwYXJhbXMudG9TdHJpbmcoKSA6XFxuICAgICAgbmV3IEF4aW9zVVJMU2VhcmNoUGFyYW1zKHBhcmFtcywgb3B0aW9ucykudG9TdHJpbmcoX2VuY29kZSk7XFxuICB9XFxuXFxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xcbiAgICBjb25zdCBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoXFxcIiNcXFwiKTtcXG5cXG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XFxuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xcbiAgICB9XFxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcXG4gIH1cXG5cXG4gIHJldHVybiB1cmw7XFxufVxcblxcbmNsYXNzIEludGVyY2VwdG9yTWFuYWdlciB7XFxuICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXFxuICAgKlxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcXG4gICAqXFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXFxuICAgKi9cXG4gIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkLCBvcHRpb25zKSB7XFxuICAgIHRoaXMuaGFuZGxlcnMucHVzaCh7XFxuICAgICAgZnVsZmlsbGVkLFxcbiAgICAgIHJlamVjdGVkLFxcbiAgICAgIHN5bmNocm9ub3VzOiBvcHRpb25zID8gb3B0aW9ucy5zeW5jaHJvbm91cyA6IGZhbHNlLFxcbiAgICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXFxuICAgIH0pO1xcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcXG4gICAqXFxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXFxuICAgKlxcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgaW50ZXJjZXB0b3Igd2FzIHJlbW92ZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXFxuICAgKi9cXG4gIGVqZWN0KGlkKSB7XFxuICAgIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xcbiAgICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBDbGVhciBhbGwgaW50ZXJjZXB0b3JzIGZyb20gdGhlIHN0YWNrXFxuICAgKlxcbiAgICogQHJldHVybnMge3ZvaWR9XFxuICAgKi9cXG4gIGNsZWFyKCkge1xcbiAgICBpZiAodGhpcy5oYW5kbGVycykge1xcbiAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xcbiAgICpcXG4gICAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XFxuICAgKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cXG4gICAqXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxcbiAgICpcXG4gICAqIEByZXR1cm5zIHt2b2lkfVxcbiAgICovXFxuICBmb3JFYWNoKGZuKSB7XFxuICAgIHV0aWxzJDEuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XFxuICAgICAgaWYgKGggIT09IG51bGwpIHtcXG4gICAgICAgIGZuKGgpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxufVxcblxcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIkMSA9IEludGVyY2VwdG9yTWFuYWdlcjtcXG5cXG52YXIgdHJhbnNpdGlvbmFsRGVmYXVsdHMgPSB7XFxuICBzaWxlbnRKU09OUGFyc2luZzogdHJ1ZSxcXG4gIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxcbiAgY2xhcmlmeVRpbWVvdXRFcnJvcjogZmFsc2VcXG59O1xcblxcbnZhciBVUkxTZWFyY2hQYXJhbXMkMSA9IHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnID8gVVJMU2VhcmNoUGFyYW1zIDogQXhpb3NVUkxTZWFyY2hQYXJhbXM7XFxuXFxudmFyIEZvcm1EYXRhJDEgPSB0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnID8gRm9ybURhdGEgOiBudWxsO1xcblxcbnZhciBCbG9iJDEgPSB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iIDogbnVsbDtcXG5cXG52YXIgcGxhdGZvcm0kMSA9IHtcXG4gIGlzQnJvd3NlcjogdHJ1ZSxcXG4gIGNsYXNzZXM6IHtcXG4gICAgVVJMU2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXMkMSxcXG4gICAgRm9ybURhdGE6IEZvcm1EYXRhJDEsXFxuICAgIEJsb2I6IEJsb2IkMVxcbiAgfSxcXG4gIHByb3RvY29sczogWydodHRwJywgJ2h0dHBzJywgJ2ZpbGUnLCAnYmxvYicsICd1cmwnLCAnZGF0YSddXFxufTtcXG5cXG5jb25zdCBoYXNCcm93c2VyRW52ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcXG5cXG4vKipcXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcXG4gKlxcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXFxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxcbiAqXFxuICogd2ViIHdvcmtlcnM6XFxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcXG4gKlxcbiAqIHJlYWN0LW5hdGl2ZTpcXG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xcbiAqIG5hdGl2ZXNjcmlwdFxcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXFxuICpcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cXG4gKi9cXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJFbnYgPSAoXFxuICAocHJvZHVjdCkgPT4ge1xcbiAgICByZXR1cm4gaGFzQnJvd3NlckVudiAmJiBbJ1JlYWN0TmF0aXZlJywgJ05hdGl2ZVNjcmlwdCcsICdOUyddLmluZGV4T2YocHJvZHVjdCkgPCAwXFxuICB9KSh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCk7XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIHdlYldvcmtlciBlbnZpcm9ubWVudFxcbiAqXFxuICogQWx0aG91Z2ggdGhlIGBpc1N0YW5kYXJkQnJvd3NlckVudmAgbWV0aG9kIGluZGljYXRlcyB0aGF0XFxuICogYGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyYCwgdGhlIFdlYldvcmtlciB3aWxsIHN0aWxsIGJlXFxuICogZmlsdGVyZWQgb3V0IGR1ZSB0byBpdHMganVkZ21lbnQgc3RhbmRhcmRcXG4gKiBgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ2AuXFxuICogVGhpcyBsZWFkcyB0byBhIHByb2JsZW0gd2hlbiBheGlvcyBwb3N0IGBGb3JtRGF0YWAgaW4gd2ViV29ya2VyXFxuICovXFxuY29uc3QgaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52ID0gKCgpID0+IHtcXG4gIHJldHVybiAoXFxuICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXFxuICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSAmJlxcbiAgICB0eXBlb2Ygc2VsZi5pbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nXFxuICApO1xcbn0pKCk7XFxuXFxuY29uc3Qgb3JpZ2luID0gaGFzQnJvd3NlckVudiAmJiB3aW5kb3cubG9jYXRpb24uaHJlZiB8fCAnaHR0cDovL2xvY2FsaG9zdCc7XFxuXFxudmFyIHV0aWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xcbiAgX19wcm90b19fOiBudWxsLFxcbiAgaGFzQnJvd3NlckVudjogaGFzQnJvd3NlckVudixcXG4gIGhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudjogaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52LFxcbiAgaGFzU3RhbmRhcmRCcm93c2VyRW52OiBoYXNTdGFuZGFyZEJyb3dzZXJFbnYsXFxuICBvcmlnaW46IG9yaWdpblxcbn0pO1xcblxcbnZhciBwbGF0Zm9ybSA9IHtcXG4gIC4uLnV0aWxzLFxcbiAgLi4ucGxhdGZvcm0kMVxcbn07XFxuXFxuZnVuY3Rpb24gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCBvcHRpb25zKSB7XFxuICByZXR1cm4gdG9Gb3JtRGF0YShkYXRhLCBuZXcgcGxhdGZvcm0uY2xhc3Nlcy5VUkxTZWFyY2hQYXJhbXMoKSwgT2JqZWN0LmFzc2lnbih7XFxuICAgIHZpc2l0b3I6IGZ1bmN0aW9uKHZhbHVlLCBrZXksIHBhdGgsIGhlbHBlcnMpIHtcXG4gICAgICBpZiAocGxhdGZvcm0uaXNOb2RlICYmIHV0aWxzJDEuaXNCdWZmZXIodmFsdWUpKSB7XFxuICAgICAgICB0aGlzLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCdiYXNlNjQnKSk7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBoZWxwZXJzLmRlZmF1bHRWaXNpdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIH1cXG4gIH0sIG9wdGlvbnMpKTtcXG59XFxuXFxuLyoqXFxuICogSXQgdGFrZXMgYSBzdHJpbmcgbGlrZSBgZm9vW3hdW3ldW3pdYCBhbmQgcmV0dXJucyBhbiBhcnJheSBsaWtlIGBbJ2ZvbycsICd4JywgJ3knLCAneiddXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXFxuICpcXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdHJpbmdzLlxcbiAqL1xcbmZ1bmN0aW9uIHBhcnNlUHJvcFBhdGgobmFtZSkge1xcbiAgLy8gZm9vW3hdW3ldW3pdXFxuICAvLyBmb28ueC55LnpcXG4gIC8vIGZvby14LXktelxcbiAgLy8gZm9vIHggeSB6XFxuICByZXR1cm4gdXRpbHMkMS5tYXRjaEFsbCgvXFxcXHcrfFxcXFxbKFxcXFx3KildL2csIG5hbWUpLm1hcChtYXRjaCA9PiB7XFxuICAgIHJldHVybiBtYXRjaFswXSA9PT0gJ1tdJyA/ICcnIDogbWF0Y2hbMV0gfHwgbWF0Y2hbMF07XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogQ29udmVydCBhbiBhcnJheSB0byBhbiBvYmplY3QuXFxuICpcXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGFyciAtIFRoZSBhcnJheSB0byBjb252ZXJ0IHRvIGFuIG9iamVjdC5cXG4gKlxcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYW5kIHZhbHVlcyBhcyB0aGUgYXJyYXkuXFxuICovXFxuZnVuY3Rpb24gYXJyYXlUb09iamVjdChhcnIpIHtcXG4gIGNvbnN0IG9iaiA9IHt9O1xcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFycik7XFxuICBsZXQgaTtcXG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xcbiAgbGV0IGtleTtcXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xcbiAgICBrZXkgPSBrZXlzW2ldO1xcbiAgICBvYmpba2V5XSA9IGFycltrZXldO1xcbiAgfVxcbiAgcmV0dXJuIG9iajtcXG59XFxuXFxuLyoqXFxuICogSXQgdGFrZXMgYSBGb3JtRGF0YSBvYmplY3QgYW5kIHJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdFxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1EYXRhIFRoZSBGb3JtRGF0YSBvYmplY3QgdG8gY29udmVydCB0byBKU09OLlxcbiAqXFxuICogQHJldHVybnMge09iamVjdDxzdHJpbmcsIGFueT4gfCBudWxsfSBUaGUgY29udmVydGVkIG9iamVjdC5cXG4gKi9cXG5mdW5jdGlvbiBmb3JtRGF0YVRvSlNPTihmb3JtRGF0YSkge1xcbiAgZnVuY3Rpb24gYnVpbGRQYXRoKHBhdGgsIHZhbHVlLCB0YXJnZXQsIGluZGV4KSB7XFxuICAgIGxldCBuYW1lID0gcGF0aFtpbmRleCsrXTtcXG5cXG4gICAgaWYgKG5hbWUgPT09ICdfX3Byb3RvX18nKSByZXR1cm4gdHJ1ZTtcXG5cXG4gICAgY29uc3QgaXNOdW1lcmljS2V5ID0gTnVtYmVyLmlzRmluaXRlKCtuYW1lKTtcXG4gICAgY29uc3QgaXNMYXN0ID0gaW5kZXggPj0gcGF0aC5sZW5ndGg7XFxuICAgIG5hbWUgPSAhbmFtZSAmJiB1dGlscyQxLmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldC5sZW5ndGggOiBuYW1lO1xcblxcbiAgICBpZiAoaXNMYXN0KSB7XFxuICAgICAgaWYgKHV0aWxzJDEuaGFzT3duUHJvcCh0YXJnZXQsIG5hbWUpKSB7XFxuICAgICAgICB0YXJnZXRbbmFtZV0gPSBbdGFyZ2V0W25hbWVdLCB2YWx1ZV07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gIWlzTnVtZXJpY0tleTtcXG4gICAgfVxcblxcbiAgICBpZiAoIXRhcmdldFtuYW1lXSB8fCAhdXRpbHMkMS5pc09iamVjdCh0YXJnZXRbbmFtZV0pKSB7XFxuICAgICAgdGFyZ2V0W25hbWVdID0gW107XFxuICAgIH1cXG5cXG4gICAgY29uc3QgcmVzdWx0ID0gYnVpbGRQYXRoKHBhdGgsIHZhbHVlLCB0YXJnZXRbbmFtZV0sIGluZGV4KTtcXG5cXG4gICAgaWYgKHJlc3VsdCAmJiB1dGlscyQxLmlzQXJyYXkodGFyZ2V0W25hbWVdKSkge1xcbiAgICAgIHRhcmdldFtuYW1lXSA9IGFycmF5VG9PYmplY3QodGFyZ2V0W25hbWVdKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gIWlzTnVtZXJpY0tleTtcXG4gIH1cXG5cXG4gIGlmICh1dGlscyQxLmlzRm9ybURhdGEoZm9ybURhdGEpICYmIHV0aWxzJDEuaXNGdW5jdGlvbihmb3JtRGF0YS5lbnRyaWVzKSkge1xcbiAgICBjb25zdCBvYmogPSB7fTtcXG5cXG4gICAgdXRpbHMkMS5mb3JFYWNoRW50cnkoZm9ybURhdGEsIChuYW1lLCB2YWx1ZSkgPT4ge1xcbiAgICAgIGJ1aWxkUGF0aChwYXJzZVByb3BQYXRoKG5hbWUpLCB2YWx1ZSwgb2JqLCAwKTtcXG4gICAgfSk7XFxuXFxuICAgIHJldHVybiBvYmo7XFxuICB9XFxuXFxuICByZXR1cm4gbnVsbDtcXG59XFxuXFxuLyoqXFxuICogSXQgdGFrZXMgYSBzdHJpbmcsIHRyaWVzIHRvIHBhcnNlIGl0LCBhbmQgaWYgaXQgZmFpbHMsIGl0IHJldHVybnMgdGhlIHN0cmluZ2lmaWVkIHZlcnNpb25cXG4gKiBvZiB0aGUgaW5wdXRcXG4gKlxcbiAqIEBwYXJhbSB7YW55fSByYXdWYWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBzdHJpbmdpZmllZC5cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJzZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGEgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVyIC0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmFsdWUgYW5kIHJldHVybnMgYSBzdHJpbmcuXFxuICpcXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgdGhlIHJhd1ZhbHVlLlxcbiAqL1xcbmZ1bmN0aW9uIHN0cmluZ2lmeVNhZmVseShyYXdWYWx1ZSwgcGFyc2VyLCBlbmNvZGVyKSB7XFxuICBpZiAodXRpbHMkMS5pc1N0cmluZyhyYXdWYWx1ZSkpIHtcXG4gICAgdHJ5IHtcXG4gICAgICAocGFyc2VyIHx8IEpTT04ucGFyc2UpKHJhd1ZhbHVlKTtcXG4gICAgICByZXR1cm4gdXRpbHMkMS50cmltKHJhd1ZhbHVlKTtcXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcXG4gICAgICAgIHRocm93IGU7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcXG59XFxuXFxuY29uc3QgZGVmYXVsdHMgPSB7XFxuXFxuICB0cmFuc2l0aW9uYWw6IHRyYW5zaXRpb25hbERlZmF1bHRzLFxcblxcbiAgYWRhcHRlcjogWyd4aHInLCAnaHR0cCcsICdmZXRjaCddLFxcblxcbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0Q29udGVudFR5cGUoKSB8fCAnJztcXG4gICAgY29uc3QgaGFzSlNPTkNvbnRlbnRUeXBlID0gY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTE7XFxuICAgIGNvbnN0IGlzT2JqZWN0UGF5bG9hZCA9IHV0aWxzJDEuaXNPYmplY3QoZGF0YSk7XFxuXFxuICAgIGlmIChpc09iamVjdFBheWxvYWQgJiYgdXRpbHMkMS5pc0hUTUxGb3JtKGRhdGEpKSB7XFxuICAgICAgZGF0YSA9IG5ldyBGb3JtRGF0YShkYXRhKTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBpc0Zvcm1EYXRhID0gdXRpbHMkMS5pc0Zvcm1EYXRhKGRhdGEpO1xcblxcbiAgICBpZiAoaXNGb3JtRGF0YSkge1xcbiAgICAgIHJldHVybiBoYXNKU09OQ29udGVudFR5cGUgPyBKU09OLnN0cmluZ2lmeShmb3JtRGF0YVRvSlNPTihkYXRhKSkgOiBkYXRhO1xcbiAgICB9XFxuXFxuICAgIGlmICh1dGlscyQxLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcXG4gICAgICB1dGlscyQxLmlzQnVmZmVyKGRhdGEpIHx8XFxuICAgICAgdXRpbHMkMS5pc1N0cmVhbShkYXRhKSB8fFxcbiAgICAgIHV0aWxzJDEuaXNGaWxlKGRhdGEpIHx8XFxuICAgICAgdXRpbHMkMS5pc0Jsb2IoZGF0YSkgfHxcXG4gICAgICB1dGlscyQxLmlzUmVhZGFibGVTdHJlYW0oZGF0YSlcXG4gICAgKSB7XFxuICAgICAgcmV0dXJuIGRhdGE7XFxuICAgIH1cXG4gICAgaWYgKHV0aWxzJDEuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcXG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XFxuICAgIH1cXG4gICAgaWYgKHV0aWxzJDEuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcXG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcsIGZhbHNlKTtcXG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xcbiAgICB9XFxuXFxuICAgIGxldCBpc0ZpbGVMaXN0O1xcblxcbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkKSB7XFxuICAgICAgaWYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpID4gLTEpIHtcXG4gICAgICAgIHJldHVybiB0b1VSTEVuY29kZWRGb3JtKGRhdGEsIHRoaXMuZm9ybVNlcmlhbGl6ZXIpLnRvU3RyaW5nKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgoaXNGaWxlTGlzdCA9IHV0aWxzJDEuaXNGaWxlTGlzdChkYXRhKSkgfHwgY29udGVudFR5cGUuaW5kZXhPZignbXVsdGlwYXJ0L2Zvcm0tZGF0YScpID4gLTEpIHtcXG4gICAgICAgIGNvbnN0IF9Gb3JtRGF0YSA9IHRoaXMuZW52ICYmIHRoaXMuZW52LkZvcm1EYXRhO1xcblxcbiAgICAgICAgcmV0dXJuIHRvRm9ybURhdGEoXFxuICAgICAgICAgIGlzRmlsZUxpc3QgPyB7J2ZpbGVzW10nOiBkYXRhfSA6IGRhdGEsXFxuICAgICAgICAgIF9Gb3JtRGF0YSAmJiBuZXcgX0Zvcm1EYXRhKCksXFxuICAgICAgICAgIHRoaXMuZm9ybVNlcmlhbGl6ZXJcXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChpc09iamVjdFBheWxvYWQgfHwgaGFzSlNPTkNvbnRlbnRUeXBlICkge1xcbiAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL2pzb24nLCBmYWxzZSk7XFxuICAgICAgcmV0dXJuIHN0cmluZ2lmeVNhZmVseShkYXRhKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gZGF0YTtcXG4gIH1dLFxcblxcbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XFxuICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsIHx8IGRlZmF1bHRzLnRyYW5zaXRpb25hbDtcXG4gICAgY29uc3QgZm9yY2VkSlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLmZvcmNlZEpTT05QYXJzaW5nO1xcbiAgICBjb25zdCBKU09OUmVxdWVzdGVkID0gdGhpcy5yZXNwb25zZVR5cGUgPT09ICdqc29uJztcXG5cXG4gICAgaWYgKHV0aWxzJDEuaXNSZXNwb25zZShkYXRhKSB8fCB1dGlscyQxLmlzUmVhZGFibGVTdHJlYW0oZGF0YSkpIHtcXG4gICAgICByZXR1cm4gZGF0YTtcXG4gICAgfVxcblxcbiAgICBpZiAoZGF0YSAmJiB1dGlscyQxLmlzU3RyaW5nKGRhdGEpICYmICgoZm9yY2VkSlNPTlBhcnNpbmcgJiYgIXRoaXMucmVzcG9uc2VUeXBlKSB8fCBKU09OUmVxdWVzdGVkKSkge1xcbiAgICAgIGNvbnN0IHNpbGVudEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5zaWxlbnRKU09OUGFyc2luZztcXG4gICAgICBjb25zdCBzdHJpY3RKU09OUGFyc2luZyA9ICFzaWxlbnRKU09OUGFyc2luZyAmJiBKU09OUmVxdWVzdGVkO1xcblxcbiAgICAgIHRyeSB7XFxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcpIHtcXG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xcbiAgICAgICAgICAgIHRocm93IEF4aW9zRXJyb3IuZnJvbShlLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0UsIHRoaXMsIG51bGwsIHRoaXMucmVzcG9uc2UpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHRocm93IGU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBkYXRhO1xcbiAgfV0sXFxuXFxuICAvKipcXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cXG4gICAqL1xcbiAgdGltZW91dDogMCxcXG5cXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXFxuXFxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxcblxcbiAgZW52OiB7XFxuICAgIEZvcm1EYXRhOiBwbGF0Zm9ybS5jbGFzc2VzLkZvcm1EYXRhLFxcbiAgICBCbG9iOiBwbGF0Zm9ybS5jbGFzc2VzLkJsb2JcXG4gIH0sXFxuXFxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XFxuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcXG4gIH0sXFxuXFxuICBoZWFkZXJzOiB7XFxuICAgIGNvbW1vbjoge1xcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJyxcXG4gICAgICAnQ29udGVudC1UeXBlJzogdW5kZWZpbmVkXFxuICAgIH1cXG4gIH1cXG59O1xcblxcbnV0aWxzJDEuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCddLCAobWV0aG9kKSA9PiB7XFxuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcXG59KTtcXG5cXG52YXIgZGVmYXVsdHMkMSA9IGRlZmF1bHRzO1xcblxcbi8vIFJhd0F4aW9zSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXFxuY29uc3QgaWdub3JlRHVwbGljYXRlT2YgPSB1dGlscyQxLnRvT2JqZWN0U2V0KFtcXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xcbl0pO1xcblxcbi8qKlxcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcXG4gKlxcbiAqIGBgYFxcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXFxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXFxuICogYGBgXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3SGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXFxuICpcXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxcbiAqL1xcbnZhciBwYXJzZUhlYWRlcnMgPSByYXdIZWFkZXJzID0+IHtcXG4gIGNvbnN0IHBhcnNlZCA9IHt9O1xcbiAgbGV0IGtleTtcXG4gIGxldCB2YWw7XFxuICBsZXQgaTtcXG5cXG4gIHJhd0hlYWRlcnMgJiYgcmF3SGVhZGVycy5zcGxpdCgnXFxcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XFxuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcXG4gICAga2V5ID0gbGluZS5zdWJzdHJpbmcoMCwgaSkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XFxuICAgIHZhbCA9IGxpbmUuc3Vic3RyaW5nKGkgKyAxKS50cmltKCk7XFxuXFxuICAgIGlmICgha2V5IHx8IChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZltrZXldKSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcXG4gICAgICBpZiAocGFyc2VkW2tleV0pIHtcXG4gICAgICAgIHBhcnNlZFtrZXldLnB1c2godmFsKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcGFyc2VkW2tleV0gPSBbdmFsXTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICByZXR1cm4gcGFyc2VkO1xcbn07XFxuXFxuY29uc3QgJGludGVybmFscyA9IFN5bWJvbCgnaW50ZXJuYWxzJyk7XFxuXFxuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyKGhlYWRlcikge1xcbiAgcmV0dXJuIGhlYWRlciAmJiBTdHJpbmcoaGVhZGVyKS50cmltKCkudG9Mb3dlckNhc2UoKTtcXG59XFxuXFxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcXG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT0gbnVsbCkge1xcbiAgICByZXR1cm4gdmFsdWU7XFxuICB9XFxuXFxuICByZXR1cm4gdXRpbHMkMS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcChub3JtYWxpemVWYWx1ZSkgOiBTdHJpbmcodmFsdWUpO1xcbn1cXG5cXG5mdW5jdGlvbiBwYXJzZVRva2VucyhzdHIpIHtcXG4gIGNvbnN0IHRva2VucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuICBjb25zdCB0b2tlbnNSRSA9IC8oW15cXFxccyw7PV0rKVxcXFxzKig/Oj1cXFxccyooW14sO10rKSk/L2c7XFxuICBsZXQgbWF0Y2g7XFxuXFxuICB3aGlsZSAoKG1hdGNoID0gdG9rZW5zUkUuZXhlYyhzdHIpKSkge1xcbiAgICB0b2tlbnNbbWF0Y2hbMV1dID0gbWF0Y2hbMl07XFxuICB9XFxuXFxuICByZXR1cm4gdG9rZW5zO1xcbn1cXG5cXG5jb25zdCBpc1ZhbGlkSGVhZGVyTmFtZSA9IChzdHIpID0+IC9eWy1fYS16QS1aMC05XmB8fiwhIyQlJicqKy5dKyQvLnRlc3Qoc3RyLnRyaW0oKSk7XFxuXFxuZnVuY3Rpb24gbWF0Y2hIZWFkZXJWYWx1ZShjb250ZXh0LCB2YWx1ZSwgaGVhZGVyLCBmaWx0ZXIsIGlzSGVhZGVyTmFtZUZpbHRlcikge1xcbiAgaWYgKHV0aWxzJDEuaXNGdW5jdGlvbihmaWx0ZXIpKSB7XFxuICAgIHJldHVybiBmaWx0ZXIuY2FsbCh0aGlzLCB2YWx1ZSwgaGVhZGVyKTtcXG4gIH1cXG5cXG4gIGlmIChpc0hlYWRlck5hbWVGaWx0ZXIpIHtcXG4gICAgdmFsdWUgPSBoZWFkZXI7XFxuICB9XFxuXFxuICBpZiAoIXV0aWxzJDEuaXNTdHJpbmcodmFsdWUpKSByZXR1cm47XFxuXFxuICBpZiAodXRpbHMkMS5pc1N0cmluZyhmaWx0ZXIpKSB7XFxuICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKGZpbHRlcikgIT09IC0xO1xcbiAgfVxcblxcbiAgaWYgKHV0aWxzJDEuaXNSZWdFeHAoZmlsdGVyKSkge1xcbiAgICByZXR1cm4gZmlsdGVyLnRlc3QodmFsdWUpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBmb3JtYXRIZWFkZXIoaGVhZGVyKSB7XFxuICByZXR1cm4gaGVhZGVyLnRyaW0oKVxcbiAgICAudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8oW2EtelxcXFxkXSkoXFxcXHcqKS9nLCAodywgY2hhciwgc3RyKSA9PiB7XFxuICAgICAgcmV0dXJuIGNoYXIudG9VcHBlckNhc2UoKSArIHN0cjtcXG4gICAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIGJ1aWxkQWNjZXNzb3JzKG9iaiwgaGVhZGVyKSB7XFxuICBjb25zdCBhY2Nlc3Nvck5hbWUgPSB1dGlscyQxLnRvQ2FtZWxDYXNlKCcgJyArIGhlYWRlcik7XFxuXFxuICBbJ2dldCcsICdzZXQnLCAnaGFzJ10uZm9yRWFjaChtZXRob2ROYW1lID0+IHtcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbWV0aG9kTmFtZSArIGFjY2Vzc29yTmFtZSwge1xcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihhcmcxLCBhcmcyLCBhcmczKSB7XFxuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2ROYW1lXS5jYWxsKHRoaXMsIGhlYWRlciwgYXJnMSwgYXJnMiwgYXJnMyk7XFxuICAgICAgfSxcXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcXG4gICAgfSk7XFxuICB9KTtcXG59XFxuXFxuY2xhc3MgQXhpb3NIZWFkZXJzIHtcXG4gIGNvbnN0cnVjdG9yKGhlYWRlcnMpIHtcXG4gICAgaGVhZGVycyAmJiB0aGlzLnNldChoZWFkZXJzKTtcXG4gIH1cXG5cXG4gIHNldChoZWFkZXIsIHZhbHVlT3JSZXdyaXRlLCByZXdyaXRlKSB7XFxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xcblxcbiAgICBmdW5jdGlvbiBzZXRIZWFkZXIoX3ZhbHVlLCBfaGVhZGVyLCBfcmV3cml0ZSkge1xcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XFxuXFxuICAgICAgaWYgKCFsSGVhZGVyKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hlYWRlciBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzJDEuZmluZEtleShzZWxmLCBsSGVhZGVyKTtcXG5cXG4gICAgICBpZigha2V5IHx8IHNlbGZba2V5XSA9PT0gdW5kZWZpbmVkIHx8IF9yZXdyaXRlID09PSB0cnVlIHx8IChfcmV3cml0ZSA9PT0gdW5kZWZpbmVkICYmIHNlbGZba2V5XSAhPT0gZmFsc2UpKSB7XFxuICAgICAgICBzZWxmW2tleSB8fCBfaGVhZGVyXSA9IG5vcm1hbGl6ZVZhbHVlKF92YWx1ZSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGNvbnN0IHNldEhlYWRlcnMgPSAoaGVhZGVycywgX3Jld3JpdGUpID0+XFxuICAgICAgdXRpbHMkMS5mb3JFYWNoKGhlYWRlcnMsIChfdmFsdWUsIF9oZWFkZXIpID0+IHNldEhlYWRlcihfdmFsdWUsIF9oZWFkZXIsIF9yZXdyaXRlKSk7XFxuXFxuICAgIGlmICh1dGlscyQxLmlzUGxhaW5PYmplY3QoaGVhZGVyKSB8fCBoZWFkZXIgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSB7XFxuICAgICAgc2V0SGVhZGVycyhoZWFkZXIsIHZhbHVlT3JSZXdyaXRlKTtcXG4gICAgfSBlbHNlIGlmKHV0aWxzJDEuaXNTdHJpbmcoaGVhZGVyKSAmJiAoaGVhZGVyID0gaGVhZGVyLnRyaW0oKSkgJiYgIWlzVmFsaWRIZWFkZXJOYW1lKGhlYWRlcikpIHtcXG4gICAgICBzZXRIZWFkZXJzKHBhcnNlSGVhZGVycyhoZWFkZXIpLCB2YWx1ZU9yUmV3cml0ZSk7XFxuICAgIH0gZWxzZSBpZiAodXRpbHMkMS5pc0hlYWRlcnMoaGVhZGVyKSkge1xcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGhlYWRlci5lbnRyaWVzKCkpIHtcXG4gICAgICAgIHNldEhlYWRlcih2YWx1ZSwga2V5LCByZXdyaXRlKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaGVhZGVyICE9IG51bGwgJiYgc2V0SGVhZGVyKHZhbHVlT3JSZXdyaXRlLCBoZWFkZXIsIHJld3JpdGUpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgZ2V0KGhlYWRlciwgcGFyc2VyKSB7XFxuICAgIGhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpO1xcblxcbiAgICBpZiAoaGVhZGVyKSB7XFxuICAgICAgY29uc3Qga2V5ID0gdXRpbHMkMS5maW5kS2V5KHRoaXMsIGhlYWRlcik7XFxuXFxuICAgICAgaWYgKGtleSkge1xcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2tleV07XFxuXFxuICAgICAgICBpZiAoIXBhcnNlcikge1xcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAocGFyc2VyID09PSB0cnVlKSB7XFxuICAgICAgICAgIHJldHVybiBwYXJzZVRva2Vucyh2YWx1ZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodXRpbHMkMS5pc0Z1bmN0aW9uKHBhcnNlcikpIHtcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5jYWxsKHRoaXMsIHZhbHVlLCBrZXkpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHV0aWxzJDEuaXNSZWdFeHAocGFyc2VyKSkge1xcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmV4ZWModmFsdWUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyc2VyIG11c3QgYmUgYm9vbGVhbnxyZWdleHB8ZnVuY3Rpb24nKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGhhcyhoZWFkZXIsIG1hdGNoZXIpIHtcXG4gICAgaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKGhlYWRlcik7XFxuXFxuICAgIGlmIChoZWFkZXIpIHtcXG4gICAgICBjb25zdCBrZXkgPSB1dGlscyQxLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcXG5cXG4gICAgICByZXR1cm4gISEoa2V5ICYmIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkICYmICghbWF0Y2hlciB8fCBtYXRjaEhlYWRlclZhbHVlKHRoaXMsIHRoaXNba2V5XSwga2V5LCBtYXRjaGVyKSkpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIGRlbGV0ZShoZWFkZXIsIG1hdGNoZXIpIHtcXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XFxuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XFxuXFxuICAgIGZ1bmN0aW9uIGRlbGV0ZUhlYWRlcihfaGVhZGVyKSB7XFxuICAgICAgX2hlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcXG5cXG4gICAgICBpZiAoX2hlYWRlcikge1xcbiAgICAgICAgY29uc3Qga2V5ID0gdXRpbHMkMS5maW5kS2V5KHNlbGYsIF9oZWFkZXIpO1xcblxcbiAgICAgICAgaWYgKGtleSAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZShzZWxmLCBzZWxmW2tleV0sIGtleSwgbWF0Y2hlcikpKSB7XFxuICAgICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XFxuXFxuICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAodXRpbHMkMS5pc0FycmF5KGhlYWRlcikpIHtcXG4gICAgICBoZWFkZXIuZm9yRWFjaChkZWxldGVIZWFkZXIpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGRlbGV0ZUhlYWRlcihoZWFkZXIpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBkZWxldGVkO1xcbiAgfVxcblxcbiAgY2xlYXIobWF0Y2hlcikge1xcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XFxuICAgIGxldCBpID0ga2V5cy5sZW5ndGg7XFxuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XFxuXFxuICAgIHdoaWxlIChpLS0pIHtcXG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xcbiAgICAgIGlmKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUodGhpcywgdGhpc1trZXldLCBrZXksIG1hdGNoZXIsIHRydWUpKSB7XFxuICAgICAgICBkZWxldGUgdGhpc1trZXldO1xcbiAgICAgICAgZGVsZXRlZCA9IHRydWU7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBkZWxldGVkO1xcbiAgfVxcblxcbiAgbm9ybWFsaXplKGZvcm1hdCkge1xcbiAgICBjb25zdCBzZWxmID0gdGhpcztcXG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xcblxcbiAgICB1dGlscyQxLmZvckVhY2godGhpcywgKHZhbHVlLCBoZWFkZXIpID0+IHtcXG4gICAgICBjb25zdCBrZXkgPSB1dGlscyQxLmZpbmRLZXkoaGVhZGVycywgaGVhZGVyKTtcXG5cXG4gICAgICBpZiAoa2V5KSB7XFxuICAgICAgICBzZWxmW2tleV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XFxuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBub3JtYWxpemVkID0gZm9ybWF0ID8gZm9ybWF0SGVhZGVyKGhlYWRlcikgOiBTdHJpbmcoaGVhZGVyKS50cmltKCk7XFxuXFxuICAgICAgaWYgKG5vcm1hbGl6ZWQgIT09IGhlYWRlcikge1xcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcXG4gICAgICB9XFxuXFxuICAgICAgc2VsZltub3JtYWxpemVkXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcXG5cXG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWRdID0gdHJ1ZTtcXG4gICAgfSk7XFxuXFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgY29uY2F0KC4uLnRhcmdldHMpIHtcXG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY29uY2F0KHRoaXMsIC4uLnRhcmdldHMpO1xcbiAgfVxcblxcbiAgdG9KU09OKGFzU3RyaW5ncykge1xcbiAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcblxcbiAgICB1dGlscyQxLmZvckVhY2godGhpcywgKHZhbHVlLCBoZWFkZXIpID0+IHtcXG4gICAgICB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSAmJiAob2JqW2hlYWRlcl0gPSBhc1N0cmluZ3MgJiYgdXRpbHMkMS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywgJykgOiB2YWx1ZSk7XFxuICAgIH0pO1xcblxcbiAgICByZXR1cm4gb2JqO1xcbiAgfVxcblxcbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XFxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKVtTeW1ib2wuaXRlcmF0b3JdKCk7XFxuICB9XFxuXFxuICB0b1N0cmluZygpIHtcXG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMudG9KU09OKCkpLm1hcCgoW2hlYWRlciwgdmFsdWVdKSA9PiBoZWFkZXIgKyAnOiAnICsgdmFsdWUpLmpvaW4oJ1xcXFxuJyk7XFxuICB9XFxuXFxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XFxuICAgIHJldHVybiAnQXhpb3NIZWFkZXJzJztcXG4gIH1cXG5cXG4gIHN0YXRpYyBmcm9tKHRoaW5nKSB7XFxuICAgIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIHRoaXMgPyB0aGluZyA6IG5ldyB0aGlzKHRoaW5nKTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBjb25jYXQoZmlyc3QsIC4uLnRhcmdldHMpIHtcXG4gICAgY29uc3QgY29tcHV0ZWQgPSBuZXcgdGhpcyhmaXJzdCk7XFxuXFxuICAgIHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiBjb21wdXRlZC5zZXQodGFyZ2V0KSk7XFxuXFxuICAgIHJldHVybiBjb21wdXRlZDtcXG4gIH1cXG5cXG4gIHN0YXRpYyBhY2Nlc3NvcihoZWFkZXIpIHtcXG4gICAgY29uc3QgaW50ZXJuYWxzID0gdGhpc1skaW50ZXJuYWxzXSA9ICh0aGlzWyRpbnRlcm5hbHNdID0ge1xcbiAgICAgIGFjY2Vzc29yczoge31cXG4gICAgfSk7XFxuXFxuICAgIGNvbnN0IGFjY2Vzc29ycyA9IGludGVybmFscy5hY2Nlc3NvcnM7XFxuICAgIGNvbnN0IHByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xcblxcbiAgICBmdW5jdGlvbiBkZWZpbmVBY2Nlc3NvcihfaGVhZGVyKSB7XFxuICAgICAgY29uc3QgbEhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihfaGVhZGVyKTtcXG5cXG4gICAgICBpZiAoIWFjY2Vzc29yc1tsSGVhZGVyXSkge1xcbiAgICAgICAgYnVpbGRBY2Nlc3NvcnMocHJvdG90eXBlLCBfaGVhZGVyKTtcXG4gICAgICAgIGFjY2Vzc29yc1tsSGVhZGVyXSA9IHRydWU7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHV0aWxzJDEuaXNBcnJheShoZWFkZXIpID8gaGVhZGVyLmZvckVhY2goZGVmaW5lQWNjZXNzb3IpIDogZGVmaW5lQWNjZXNzb3IoaGVhZGVyKTtcXG5cXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxufVxcblxcbkF4aW9zSGVhZGVycy5hY2Nlc3NvcihbJ0NvbnRlbnQtVHlwZScsICdDb250ZW50LUxlbmd0aCcsICdBY2NlcHQnLCAnQWNjZXB0LUVuY29kaW5nJywgJ1VzZXItQWdlbnQnLCAnQXV0aG9yaXphdGlvbiddKTtcXG5cXG4vLyByZXNlcnZlZCBuYW1lcyBob3RmaXhcXG51dGlscyQxLnJlZHVjZURlc2NyaXB0b3JzKEF4aW9zSGVhZGVycy5wcm90b3R5cGUsICh7dmFsdWV9LCBrZXkpID0+IHtcXG4gIGxldCBtYXBwZWQgPSBrZXlbMF0udG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTsgLy8gbWFwIGBzZXRgID0+IGBTZXRgXFxuICByZXR1cm4ge1xcbiAgICBnZXQ6ICgpID0+IHZhbHVlLFxcbiAgICBzZXQoaGVhZGVyVmFsdWUpIHtcXG4gICAgICB0aGlzW21hcHBlZF0gPSBoZWFkZXJWYWx1ZTtcXG4gICAgfVxcbiAgfVxcbn0pO1xcblxcbnV0aWxzJDEuZnJlZXplTWV0aG9kcyhBeGlvc0hlYWRlcnMpO1xcblxcbnZhciBBeGlvc0hlYWRlcnMkMSA9IEF4aW9zSGVhZGVycztcXG5cXG4vKipcXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXFxuICpcXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXFxuICogQHBhcmFtIHs/T2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2Ugb2JqZWN0XFxuICpcXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXFxuICovXFxuZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShmbnMsIHJlc3BvbnNlKSB7XFxuICBjb25zdCBjb25maWcgPSB0aGlzIHx8IGRlZmF1bHRzJDE7XFxuICBjb25zdCBjb250ZXh0ID0gcmVzcG9uc2UgfHwgY29uZmlnO1xcbiAgY29uc3QgaGVhZGVycyA9IEF4aW9zSGVhZGVycyQxLmZyb20oY29udGV4dC5oZWFkZXJzKTtcXG4gIGxldCBkYXRhID0gY29udGV4dC5kYXRhO1xcblxcbiAgdXRpbHMkMS5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XFxuICAgIGRhdGEgPSBmbi5jYWxsKGNvbmZpZywgZGF0YSwgaGVhZGVycy5ub3JtYWxpemUoKSwgcmVzcG9uc2UgPyByZXNwb25zZS5zdGF0dXMgOiB1bmRlZmluZWQpO1xcbiAgfSk7XFxuXFxuICBoZWFkZXJzLm5vcm1hbGl6ZSgpO1xcblxcbiAgcmV0dXJuIGRhdGE7XFxufVxcblxcbmZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XFxuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XFxufVxcblxcbi8qKlxcbiAqIEEgYENhbmNlbGVkRXJyb3JgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cXG4gKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyBUaGUgY29uZmlnLlxcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcmVxdWVzdCBUaGUgcmVxdWVzdC5cXG4gKlxcbiAqIEByZXR1cm5zIHtDYW5jZWxlZEVycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cXG4gKi9cXG5mdW5jdGlvbiBDYW5jZWxlZEVycm9yKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXFxuICBBeGlvc0Vycm9yLmNhbGwodGhpcywgbWVzc2FnZSA9PSBudWxsID8gJ2NhbmNlbGVkJyA6IG1lc3NhZ2UsIEF4aW9zRXJyb3IuRVJSX0NBTkNFTEVELCBjb25maWcsIHJlcXVlc3QpO1xcbiAgdGhpcy5uYW1lID0gJ0NhbmNlbGVkRXJyb3InO1xcbn1cXG5cXG51dGlscyQxLmluaGVyaXRzKENhbmNlbGVkRXJyb3IsIEF4aW9zRXJyb3IsIHtcXG4gIF9fQ0FOQ0VMX186IHRydWVcXG59KTtcXG5cXG4vKipcXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxcbiAqXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxcbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXFxuICpcXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgcmVzcG9uc2UuXFxuICovXFxuZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcXG4gIGNvbnN0IHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcXG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XFxuICB9IGVsc2Uge1xcbiAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcXG4gICAgICBbQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIEF4aW9zRXJyb3IuRVJSX0JBRF9SRVNQT05TRV1bTWF0aC5mbG9vcihyZXNwb25zZS5zdGF0dXMgLyAxMDApIC0gNF0sXFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXFxuICAgICAgcmVzcG9uc2VcXG4gICAgKSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHBhcnNlUHJvdG9jb2wodXJsKSB7XFxuICBjb25zdCBtYXRjaCA9IC9eKFstK1xcXFx3XXsxLDI1fSkoOj9cXFxcL1xcXFwvfDopLy5leGVjKHVybCk7XFxuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XFxufVxcblxcbi8qKlxcbiAqIENhbGN1bGF0ZSBkYXRhIG1heFJhdGVcXG4gKiBAcGFyYW0ge051bWJlcn0gW3NhbXBsZXNDb3VudD0gMTBdXFxuICogQHBhcmFtIHtOdW1iZXJ9IFttaW49IDEwMDBdXFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxcbiAqL1xcbmZ1bmN0aW9uIHNwZWVkb21ldGVyKHNhbXBsZXNDb3VudCwgbWluKSB7XFxuICBzYW1wbGVzQ291bnQgPSBzYW1wbGVzQ291bnQgfHwgMTA7XFxuICBjb25zdCBieXRlcyA9IG5ldyBBcnJheShzYW1wbGVzQ291bnQpO1xcbiAgY29uc3QgdGltZXN0YW1wcyA9IG5ldyBBcnJheShzYW1wbGVzQ291bnQpO1xcbiAgbGV0IGhlYWQgPSAwO1xcbiAgbGV0IHRhaWwgPSAwO1xcbiAgbGV0IGZpcnN0U2FtcGxlVFM7XFxuXFxuICBtaW4gPSBtaW4gIT09IHVuZGVmaW5lZCA/IG1pbiA6IDEwMDA7XFxuXFxuICByZXR1cm4gZnVuY3Rpb24gcHVzaChjaHVua0xlbmd0aCkge1xcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xcblxcbiAgICBjb25zdCBzdGFydGVkQXQgPSB0aW1lc3RhbXBzW3RhaWxdO1xcblxcbiAgICBpZiAoIWZpcnN0U2FtcGxlVFMpIHtcXG4gICAgICBmaXJzdFNhbXBsZVRTID0gbm93O1xcbiAgICB9XFxuXFxuICAgIGJ5dGVzW2hlYWRdID0gY2h1bmtMZW5ndGg7XFxuICAgIHRpbWVzdGFtcHNbaGVhZF0gPSBub3c7XFxuXFxuICAgIGxldCBpID0gdGFpbDtcXG4gICAgbGV0IGJ5dGVzQ291bnQgPSAwO1xcblxcbiAgICB3aGlsZSAoaSAhPT0gaGVhZCkge1xcbiAgICAgIGJ5dGVzQ291bnQgKz0gYnl0ZXNbaSsrXTtcXG4gICAgICBpID0gaSAlIHNhbXBsZXNDb3VudDtcXG4gICAgfVxcblxcbiAgICBoZWFkID0gKGhlYWQgKyAxKSAlIHNhbXBsZXNDb3VudDtcXG5cXG4gICAgaWYgKGhlYWQgPT09IHRhaWwpIHtcXG4gICAgICB0YWlsID0gKHRhaWwgKyAxKSAlIHNhbXBsZXNDb3VudDtcXG4gICAgfVxcblxcbiAgICBpZiAobm93IC0gZmlyc3RTYW1wbGVUUyA8IG1pbikge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBwYXNzZWQgPSBzdGFydGVkQXQgJiYgbm93IC0gc3RhcnRlZEF0O1xcblxcbiAgICByZXR1cm4gcGFzc2VkID8gTWF0aC5yb3VuZChieXRlc0NvdW50ICogMTAwMCAvIHBhc3NlZCkgOiB1bmRlZmluZWQ7XFxuICB9O1xcbn1cXG5cXG4vKipcXG4gKiBUaHJvdHRsZSBkZWNvcmF0b3JcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBwYXJhbSB7TnVtYmVyfSBmcmVxXFxuICogQHJldHVybiB7RnVuY3Rpb259XFxuICovXFxuZnVuY3Rpb24gdGhyb3R0bGUoZm4sIGZyZXEpIHtcXG4gIGxldCB0aW1lc3RhbXAgPSAwO1xcbiAgY29uc3QgdGhyZXNob2xkID0gMTAwMCAvIGZyZXE7XFxuICBsZXQgdGltZXIgPSBudWxsO1xcbiAgcmV0dXJuIGZ1bmN0aW9uIHRocm90dGxlZCgpIHtcXG4gICAgY29uc3QgZm9yY2UgPSB0aGlzID09PSB0cnVlO1xcblxcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xcbiAgICBpZiAoZm9yY2UgfHwgbm93IC0gdGltZXN0YW1wID4gdGhyZXNob2xkKSB7XFxuICAgICAgaWYgKHRpbWVyKSB7XFxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xcbiAgICAgICAgdGltZXIgPSBudWxsO1xcbiAgICAgIH1cXG4gICAgICB0aW1lc3RhbXAgPSBub3c7XFxuICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuICAgIH1cXG4gICAgaWYgKCF0aW1lcikge1xcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XFxuICAgICAgICB0aW1lciA9IG51bGw7XFxuICAgICAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuICAgICAgfSwgdGhyZXNob2xkIC0gKG5vdyAtIHRpbWVzdGFtcCkpO1xcbiAgICB9XFxuICB9O1xcbn1cXG5cXG52YXIgcHJvZ3Jlc3NFdmVudFJlZHVjZXIgPSAobGlzdGVuZXIsIGlzRG93bmxvYWRTdHJlYW0sIGZyZXEgPSAzKSA9PiB7XFxuICBsZXQgYnl0ZXNOb3RpZmllZCA9IDA7XFxuICBjb25zdCBfc3BlZWRvbWV0ZXIgPSBzcGVlZG9tZXRlcig1MCwgMjUwKTtcXG5cXG4gIHJldHVybiB0aHJvdHRsZShlID0+IHtcXG4gICAgY29uc3QgbG9hZGVkID0gZS5sb2FkZWQ7XFxuICAgIGNvbnN0IHRvdGFsID0gZS5sZW5ndGhDb21wdXRhYmxlID8gZS50b3RhbCA6IHVuZGVmaW5lZDtcXG4gICAgY29uc3QgcHJvZ3Jlc3NCeXRlcyA9IGxvYWRlZCAtIGJ5dGVzTm90aWZpZWQ7XFxuICAgIGNvbnN0IHJhdGUgPSBfc3BlZWRvbWV0ZXIocHJvZ3Jlc3NCeXRlcyk7XFxuICAgIGNvbnN0IGluUmFuZ2UgPSBsb2FkZWQgPD0gdG90YWw7XFxuXFxuICAgIGJ5dGVzTm90aWZpZWQgPSBsb2FkZWQ7XFxuXFxuICAgIGNvbnN0IGRhdGEgPSB7XFxuICAgICAgbG9hZGVkLFxcbiAgICAgIHRvdGFsLFxcbiAgICAgIHByb2dyZXNzOiB0b3RhbCA/IChsb2FkZWQgLyB0b3RhbCkgOiB1bmRlZmluZWQsXFxuICAgICAgYnl0ZXM6IHByb2dyZXNzQnl0ZXMsXFxuICAgICAgcmF0ZTogcmF0ZSA/IHJhdGUgOiB1bmRlZmluZWQsXFxuICAgICAgZXN0aW1hdGVkOiByYXRlICYmIHRvdGFsICYmIGluUmFuZ2UgPyAodG90YWwgLSBsb2FkZWQpIC8gcmF0ZSA6IHVuZGVmaW5lZCxcXG4gICAgICBldmVudDogZSxcXG4gICAgICBsZW5ndGhDb21wdXRhYmxlOiB0b3RhbCAhPSBudWxsXFxuICAgIH07XFxuXFxuICAgIGRhdGFbaXNEb3dubG9hZFN0cmVhbSA/ICdkb3dubG9hZCcgOiAndXBsb2FkJ10gPSB0cnVlO1xcblxcbiAgICBsaXN0ZW5lcihkYXRhKTtcXG4gIH0sIGZyZXEpO1xcbn07XFxuXFxudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudiA/XFxuXFxuLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XFxuLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXFxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xcbiAgICBjb25zdCBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcXG4gICAgY29uc3QgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XFxuICAgIGxldCBvcmlnaW5VUkw7XFxuXFxuICAgIC8qKlxcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0cyBjb21wb25lbnRzXFxuICAgICpcXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXFxuICAgICogQHJldHVybnMge09iamVjdH1cXG4gICAgKi9cXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcXG4gICAgICBsZXQgaHJlZiA9IHVybDtcXG5cXG4gICAgICBpZiAobXNpZSkge1xcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XFxuICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcXG4gICAgICB9XFxuXFxuICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XFxuXFxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcXG4gICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXFxuICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFxcXD8vLCAnJykgOiAnJyxcXG4gICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXFxuICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxcbiAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xcbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XFxuICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcXG5cXG4gICAgLyoqXFxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cXG4gICAgKlxcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcXG4gICAgKi9cXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XFxuICAgICAgY29uc3QgcGFyc2VkID0gKHV0aWxzJDEuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XFxuICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxcbiAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xcbiAgICB9O1xcbiAgfSkoKSA6XFxuXFxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxcbiAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfTtcXG4gIH0pKCk7XFxuXFxudmFyIGNvb2tpZXMgPSBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgP1xcblxcbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXFxuICB7XFxuICAgIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xcbiAgICAgIGNvbnN0IGNvb2tpZSA9IFtuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKV07XFxuXFxuICAgICAgdXRpbHMkMS5pc051bWJlcihleHBpcmVzKSAmJiBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XFxuXFxuICAgICAgdXRpbHMkMS5pc1N0cmluZyhwYXRoKSAmJiBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XFxuXFxuICAgICAgdXRpbHMkMS5pc1N0cmluZyhkb21haW4pICYmIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XFxuXFxuICAgICAgc2VjdXJlID09PSB0cnVlICYmIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcXG5cXG4gICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcXG4gICAgfSxcXG5cXG4gICAgcmVhZChuYW1lKSB7XFxuICAgICAgY29uc3QgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcXG4gICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xcbiAgICB9LFxcblxcbiAgICByZW1vdmUobmFtZSkge1xcbiAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIDpcXG5cXG4gIC8vIE5vbi1zdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cXG4gIHtcXG4gICAgd3JpdGUoKSB7fSxcXG4gICAgcmVhZCgpIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfSxcXG4gICAgcmVtb3ZlKCkge31cXG4gIH07XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxcbiAqXFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XFxuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFxcXCI8c2NoZW1lPjovL1xcXCIgb3IgXFxcIi8vXFxcIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXFxuICByZXR1cm4gL14oW2Etel1bYS16XFxcXGQrXFxcXC0uXSo6KT9cXFxcL1xcXFwvL2kudGVzdCh1cmwpO1xcbn1cXG5cXG4vKipcXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxcbiAqXFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxcbiAqL1xcbmZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XFxuICByZXR1cm4gcmVsYXRpdmVVUkxcXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcXFwvP1xcXFwvJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXFxcLysvLCAnJylcXG4gICAgOiBiYXNlVVJMO1xcbn1cXG5cXG4vKipcXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIGJhc2VVUkwgd2l0aCB0aGUgcmVxdWVzdGVkVVJMLFxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxcbiAqXFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxcbiAqL1xcbmZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XFxuICBpZiAoYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpKSB7XFxuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xcbiAgfVxcbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcXG59XFxuXFxuY29uc3QgaGVhZGVyc1RvT2JqZWN0ID0gKHRoaW5nKSA9PiB0aGluZyBpbnN0YW5jZW9mIEF4aW9zSGVhZGVycyQxID8geyAuLi50aGluZyB9IDogdGhpbmc7XFxuXFxuLyoqXFxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcXG4gKlxcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcXG4gKi9cXG5mdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xcbiAgY29uc3QgY29uZmlnID0ge307XFxuXFxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSwgY2FzZWxlc3MpIHtcXG4gICAgaWYgKHV0aWxzJDEuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzJDEuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XFxuICAgICAgcmV0dXJuIHV0aWxzJDEubWVyZ2UuY2FsbCh7Y2FzZWxlc3N9LCB0YXJnZXQsIHNvdXJjZSk7XFxuICAgIH0gZWxzZSBpZiAodXRpbHMkMS5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcXG4gICAgICByZXR1cm4gdXRpbHMkMS5tZXJnZSh7fSwgc291cmNlKTtcXG4gICAgfSBlbHNlIGlmICh1dGlscyQxLmlzQXJyYXkoc291cmNlKSkge1xcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcXG4gICAgfVxcbiAgICByZXR1cm4gc291cmNlO1xcbiAgfVxcblxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXFxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKGEsIGIsIGNhc2VsZXNzKSB7XFxuICAgIGlmICghdXRpbHMkMS5pc1VuZGVmaW5lZChiKSkge1xcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShhLCBiLCBjYXNlbGVzcyk7XFxuICAgIH0gZWxzZSBpZiAoIXV0aWxzJDEuaXNVbmRlZmluZWQoYSkpIHtcXG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhLCBjYXNlbGVzcyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxcbiAgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihhLCBiKSB7XFxuICAgIGlmICghdXRpbHMkMS5pc1VuZGVmaW5lZChiKSkge1xcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGIpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cXG4gIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIoYSwgYikge1xcbiAgICBpZiAoIXV0aWxzJDEuaXNVbmRlZmluZWQoYikpIHtcXG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBiKTtcXG4gICAgfSBlbHNlIGlmICghdXRpbHMkMS5pc1VuZGVmaW5lZChhKSkge1xcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cXG4gIGZ1bmN0aW9uIG1lcmdlRGlyZWN0S2V5cyhhLCBiLCBwcm9wKSB7XFxuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcXG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoYSwgYik7XFxuICAgIH0gZWxzZSBpZiAocHJvcCBpbiBjb25maWcxKSB7XFxuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGNvbnN0IG1lcmdlTWFwID0ge1xcbiAgICB1cmw6IHZhbHVlRnJvbUNvbmZpZzIsXFxuICAgIG1ldGhvZDogdmFsdWVGcm9tQ29uZmlnMixcXG4gICAgZGF0YTogdmFsdWVGcm9tQ29uZmlnMixcXG4gICAgYmFzZVVSTDogZGVmYXVsdFRvQ29uZmlnMixcXG4gICAgdHJhbnNmb3JtUmVxdWVzdDogZGVmYXVsdFRvQ29uZmlnMixcXG4gICAgdHJhbnNmb3JtUmVzcG9uc2U6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIHBhcmFtc1NlcmlhbGl6ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIHRpbWVvdXQ6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIHRpbWVvdXRNZXNzYWdlOiBkZWZhdWx0VG9Db25maWcyLFxcbiAgICB3aXRoQ3JlZGVudGlhbHM6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIHdpdGhYU1JGVG9rZW46IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIGFkYXB0ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIHJlc3BvbnNlVHlwZTogZGVmYXVsdFRvQ29uZmlnMixcXG4gICAgeHNyZkNvb2tpZU5hbWU6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIHhzcmZIZWFkZXJOYW1lOiBkZWZhdWx0VG9Db25maWcyLFxcbiAgICBvblVwbG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxcbiAgICBvbkRvd25sb2FkUHJvZ3Jlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIGRlY29tcHJlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIG1heENvbnRlbnRMZW5ndGg6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIG1heEJvZHlMZW5ndGg6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIGJlZm9yZVJlZGlyZWN0OiBkZWZhdWx0VG9Db25maWcyLFxcbiAgICB0cmFuc3BvcnQ6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIGh0dHBBZ2VudDogZGVmYXVsdFRvQ29uZmlnMixcXG4gICAgaHR0cHNBZ2VudDogZGVmYXVsdFRvQ29uZmlnMixcXG4gICAgY2FuY2VsVG9rZW46IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIHNvY2tldFBhdGg6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIHJlc3BvbnNlRW5jb2Rpbmc6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgIHZhbGlkYXRlU3RhdHVzOiBtZXJnZURpcmVjdEtleXMsXFxuICAgIGhlYWRlcnM6IChhLCBiKSA9PiBtZXJnZURlZXBQcm9wZXJ0aWVzKGhlYWRlcnNUb09iamVjdChhKSwgaGVhZGVyc1RvT2JqZWN0KGIpLCB0cnVlKVxcbiAgfTtcXG5cXG4gIHV0aWxzJDEuZm9yRWFjaChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCBjb25maWcxLCBjb25maWcyKSksIGZ1bmN0aW9uIGNvbXB1dGVDb25maWdWYWx1ZShwcm9wKSB7XFxuICAgIGNvbnN0IG1lcmdlID0gbWVyZ2VNYXBbcHJvcF0gfHwgbWVyZ2VEZWVwUHJvcGVydGllcztcXG4gICAgY29uc3QgY29uZmlnVmFsdWUgPSBtZXJnZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdLCBwcm9wKTtcXG4gICAgKHV0aWxzJDEuaXNVbmRlZmluZWQoY29uZmlnVmFsdWUpICYmIG1lcmdlICE9PSBtZXJnZURpcmVjdEtleXMpIHx8IChjb25maWdbcHJvcF0gPSBjb25maWdWYWx1ZSk7XFxuICB9KTtcXG5cXG4gIHJldHVybiBjb25maWc7XFxufVxcblxcbnZhciByZXNvbHZlQ29uZmlnID0gKGNvbmZpZykgPT4ge1xcbiAgY29uc3QgbmV3Q29uZmlnID0gbWVyZ2VDb25maWcoe30sIGNvbmZpZyk7XFxuXFxuICBsZXQge2RhdGEsIHdpdGhYU1JGVG9rZW4sIHhzcmZIZWFkZXJOYW1lLCB4c3JmQ29va2llTmFtZSwgaGVhZGVycywgYXV0aH0gPSBuZXdDb25maWc7XFxuXFxuICBuZXdDb25maWcuaGVhZGVycyA9IGhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKGhlYWRlcnMpO1xcblxcbiAgbmV3Q29uZmlnLnVybCA9IGJ1aWxkVVJMKGJ1aWxkRnVsbFBhdGgobmV3Q29uZmlnLmJhc2VVUkwsIG5ld0NvbmZpZy51cmwpLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcik7XFxuXFxuICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXFxuICBpZiAoYXV0aCkge1xcbiAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICtcXG4gICAgICBidG9hKChhdXRoLnVzZXJuYW1lIHx8ICcnKSArICc6JyArIChhdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgucGFzc3dvcmQpKSA6ICcnKSlcXG4gICAgKTtcXG4gIH1cXG5cXG4gIGxldCBjb250ZW50VHlwZTtcXG5cXG4gIGlmICh1dGlscyQxLmlzRm9ybURhdGEoZGF0YSkpIHtcXG4gICAgaWYgKHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudiB8fCBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJXZWJXb3JrZXJFbnYpIHtcXG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKHVuZGVmaW5lZCk7IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcXG4gICAgfSBlbHNlIGlmICgoY29udGVudFR5cGUgPSBoZWFkZXJzLmdldENvbnRlbnRUeXBlKCkpICE9PSBmYWxzZSkge1xcbiAgICAgIC8vIGZpeCBzZW1pY29sb24gZHVwbGljYXRpb24gaXNzdWUgZm9yIFJlYWN0TmF0aXZlIEZvcm1EYXRhIGltcGxlbWVudGF0aW9uXFxuICAgICAgY29uc3QgW3R5cGUsIC4uLnRva2Vuc10gPSBjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JykubWFwKHRva2VuID0+IHRva2VuLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pIDogW107XFxuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZShbdHlwZSB8fCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsIC4uLnRva2Vuc10uam9pbignOyAnKSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIEFkZCB4c3JmIGhlYWRlclxcbiAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXFxuICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxcblxcbiAgaWYgKHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudikge1xcbiAgICB3aXRoWFNSRlRva2VuICYmIHV0aWxzJDEuaXNGdW5jdGlvbih3aXRoWFNSRlRva2VuKSAmJiAod2l0aFhTUkZUb2tlbiA9IHdpdGhYU1JGVG9rZW4obmV3Q29uZmlnKSk7XFxuXFxuICAgIGlmICh3aXRoWFNSRlRva2VuIHx8ICh3aXRoWFNSRlRva2VuICE9PSBmYWxzZSAmJiBpc1VSTFNhbWVPcmlnaW4obmV3Q29uZmlnLnVybCkpKSB7XFxuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXFxuICAgICAgY29uc3QgeHNyZlZhbHVlID0geHNyZkhlYWRlck5hbWUgJiYgeHNyZkNvb2tpZU5hbWUgJiYgY29va2llcy5yZWFkKHhzcmZDb29raWVOYW1lKTtcXG5cXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XFxuICAgICAgICBoZWFkZXJzLnNldCh4c3JmSGVhZGVyTmFtZSwgeHNyZlZhbHVlKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBuZXdDb25maWc7XFxufTtcXG5cXG5jb25zdCBpc1hIUkFkYXB0ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnO1xcblxcbnZhciB4aHJBZGFwdGVyID0gaXNYSFJBZGFwdGVyU3VwcG9ydGVkICYmIGZ1bmN0aW9uIChjb25maWcpIHtcXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XFxuICAgIGNvbnN0IF9jb25maWcgPSByZXNvbHZlQ29uZmlnKGNvbmZpZyk7XFxuICAgIGxldCByZXF1ZXN0RGF0YSA9IF9jb25maWcuZGF0YTtcXG4gICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKF9jb25maWcuaGVhZGVycykubm9ybWFsaXplKCk7XFxuICAgIGxldCB7cmVzcG9uc2VUeXBlfSA9IF9jb25maWc7XFxuICAgIGxldCBvbkNhbmNlbGVkO1xcbiAgICBmdW5jdGlvbiBkb25lKCkge1xcbiAgICAgIGlmIChfY29uZmlnLmNhbmNlbFRva2VuKSB7XFxuICAgICAgICBfY29uZmlnLmNhbmNlbFRva2VuLnVuc3Vic2NyaWJlKG9uQ2FuY2VsZWQpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoX2NvbmZpZy5zaWduYWwpIHtcXG4gICAgICAgIF9jb25maWcuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGxldCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XFxuXFxuICAgIHJlcXVlc3Qub3BlbihfY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBfY29uZmlnLnVybCwgdHJ1ZSk7XFxuXFxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXFxuICAgIHJlcXVlc3QudGltZW91dCA9IF9jb25maWcudGltZW91dDtcXG5cXG4gICAgZnVuY3Rpb24gb25sb2FkZW5kKCkge1xcbiAgICAgIGlmICghcmVxdWVzdCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxcbiAgICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IEF4aW9zSGVhZGVycyQxLmZyb20oXFxuICAgICAgICAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ICYmIHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcXG4gICAgICApO1xcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgcmVzcG9uc2VUeXBlID09PSAnanNvbicgP1xcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcXG4gICAgICAgIGNvbmZpZyxcXG4gICAgICAgIHJlcXVlc3RcXG4gICAgICB9O1xcblxcbiAgICAgIHNldHRsZShmdW5jdGlvbiBfcmVzb2x2ZSh2YWx1ZSkge1xcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XFxuICAgICAgICBkb25lKCk7XFxuICAgICAgfSwgZnVuY3Rpb24gX3JlamVjdChlcnIpIHtcXG4gICAgICAgIHJlamVjdChlcnIpO1xcbiAgICAgICAgZG9uZSgpO1xcbiAgICAgIH0sIHJlc3BvbnNlKTtcXG5cXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XFxuICAgICAgcmVxdWVzdCA9IG51bGw7XFxuICAgIH1cXG5cXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcXG4gICAgICAvLyBVc2Ugb25sb2FkZW5kIGlmIGF2YWlsYWJsZVxcbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gb25sb2FkZW5kO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGUgdG8gZW11bGF0ZSBvbmxvYWRlbmRcXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XFxuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxcbiAgICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXFxuICAgICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XFxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gcmVhZHlzdGF0ZSBoYW5kbGVyIGlzIGNhbGxpbmcgYmVmb3JlIG9uZXJyb3Igb3Igb250aW1lb3V0IGhhbmRsZXJzLFxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xcbiAgICAgICAgc2V0VGltZW91dChvbmxvYWRlbmQpO1xcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcXG4gICAgICBpZiAoIXJlcXVlc3QpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCwgX2NvbmZpZywgcmVxdWVzdCkpO1xcblxcbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcXG4gICAgICByZXF1ZXN0ID0gbnVsbDtcXG4gICAgfTtcXG5cXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcXG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcXG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBBeGlvc0Vycm9yLkVSUl9ORVRXT1JLLCBfY29uZmlnLCByZXF1ZXN0KSk7XFxuXFxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xcbiAgICB9O1xcblxcbiAgICAvLyBIYW5kbGUgdGltZW91dFxcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XFxuICAgICAgbGV0IHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBfY29uZmlnLnRpbWVvdXQgPyAndGltZW91dCBvZiAnICsgX2NvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyA6ICd0aW1lb3V0IGV4Y2VlZGVkJztcXG4gICAgICBjb25zdCB0cmFuc2l0aW9uYWwgPSBfY29uZmlnLnRyYW5zaXRpb25hbCB8fCB0cmFuc2l0aW9uYWxEZWZhdWx0cztcXG4gICAgICBpZiAoX2NvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gX2NvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xcbiAgICAgIH1cXG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxcbiAgICAgICAgdHJhbnNpdGlvbmFsLmNsYXJpZnlUaW1lb3V0RXJyb3IgPyBBeGlvc0Vycm9yLkVUSU1FRE9VVCA6IEF4aW9zRXJyb3IuRUNPTk5BQk9SVEVELFxcbiAgICAgICAgX2NvbmZpZyxcXG4gICAgICAgIHJlcXVlc3QpKTtcXG5cXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XFxuICAgICAgcmVxdWVzdCA9IG51bGw7XFxuICAgIH07XFxuXFxuICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcXG4gICAgcmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCAmJiByZXF1ZXN0SGVhZGVycy5zZXRDb250ZW50VHlwZShudWxsKTtcXG5cXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcXG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XFxuICAgICAgdXRpbHMkMS5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLnRvSlNPTigpLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XFxuICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcXG4gICAgaWYgKCF1dGlscyQxLmlzVW5kZWZpbmVkKF9jb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFfY29uZmlnLndpdGhDcmVkZW50aWFscztcXG4gICAgfVxcblxcbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXFxuICAgIGlmIChyZXNwb25zZVR5cGUgJiYgcmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcXG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IF9jb25maWcucmVzcG9uc2VUeXBlO1xcbiAgICB9XFxuXFxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcXG4gICAgaWYgKHR5cGVvZiBfY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBwcm9ncmVzc0V2ZW50UmVkdWNlcihfY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcywgdHJ1ZSkpO1xcbiAgICB9XFxuXFxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXFxuICAgIGlmICh0eXBlb2YgX2NvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XFxuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBwcm9ncmVzc0V2ZW50UmVkdWNlcihfY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpKTtcXG4gICAgfVxcblxcbiAgICBpZiAoX2NvbmZpZy5jYW5jZWxUb2tlbiB8fCBfY29uZmlnLnNpZ25hbCkge1xcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xcbiAgICAgIG9uQ2FuY2VsZWQgPSBjYW5jZWwgPT4ge1xcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHJlamVjdCghY2FuY2VsIHx8IGNhbmNlbC50eXBlID8gbmV3IENhbmNlbGVkRXJyb3IobnVsbCwgY29uZmlnLCByZXF1ZXN0KSA6IGNhbmNlbCk7XFxuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcXG4gICAgICB9O1xcblxcbiAgICAgIF9jb25maWcuY2FuY2VsVG9rZW4gJiYgX2NvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUob25DYW5jZWxlZCk7XFxuICAgICAgaWYgKF9jb25maWcuc2lnbmFsKSB7XFxuICAgICAgICBfY29uZmlnLnNpZ25hbC5hYm9ydGVkID8gb25DYW5jZWxlZCgpIDogX2NvbmZpZy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgY29uc3QgcHJvdG9jb2wgPSBwYXJzZVByb3RvY29sKF9jb25maWcudXJsKTtcXG5cXG4gICAgaWYgKHByb3RvY29sICYmIHBsYXRmb3JtLnByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcXG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sICcgKyBwcm90b2NvbCArICc6JywgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIGNvbmZpZykpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcblxcbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSB8fCBudWxsKTtcXG4gIH0pO1xcbn07XFxuXFxuY29uc3QgY29tcG9zZVNpZ25hbHMgPSAoc2lnbmFscywgdGltZW91dCkgPT4ge1xcbiAgbGV0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XFxuXFxuICBsZXQgYWJvcnRlZDtcXG5cXG4gIGNvbnN0IG9uYWJvcnQgPSBmdW5jdGlvbiAoY2FuY2VsKSB7XFxuICAgIGlmICghYWJvcnRlZCkge1xcbiAgICAgIGFib3J0ZWQgPSB0cnVlO1xcbiAgICAgIHVuc3Vic2NyaWJlKCk7XFxuICAgICAgY29uc3QgZXJyID0gY2FuY2VsIGluc3RhbmNlb2YgRXJyb3IgPyBjYW5jZWwgOiB0aGlzLnJlYXNvbjtcXG4gICAgICBjb250cm9sbGVyLmFib3J0KGVyciBpbnN0YW5jZW9mIEF4aW9zRXJyb3IgPyBlcnIgOiBuZXcgQ2FuY2VsZWRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogZXJyKSk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBsZXQgdGltZXIgPSB0aW1lb3V0ICYmIHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICBvbmFib3J0KG5ldyBBeGlvc0Vycm9yKGB0aW1lb3V0ICR7dGltZW91dH0gb2YgbXMgZXhjZWVkZWRgLCBBeGlvc0Vycm9yLkVUSU1FRE9VVCkpO1xcbiAgfSwgdGltZW91dCk7XFxuXFxuICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHtcXG4gICAgaWYgKHNpZ25hbHMpIHtcXG4gICAgICB0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xcbiAgICAgIHRpbWVyID0gbnVsbDtcXG4gICAgICBzaWduYWxzLmZvckVhY2goc2lnbmFsID0+IHtcXG4gICAgICAgIHNpZ25hbCAmJlxcbiAgICAgICAgKHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyID8gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25hYm9ydCkgOiBzaWduYWwudW5zdWJzY3JpYmUob25hYm9ydCkpO1xcbiAgICAgIH0pO1xcbiAgICAgIHNpZ25hbHMgPSBudWxsO1xcbiAgICB9XFxuICB9O1xcblxcbiAgc2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHNpZ25hbCAmJiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbmFib3J0KSk7XFxuXFxuICBjb25zdCB7c2lnbmFsfSA9IGNvbnRyb2xsZXI7XFxuXFxuICBzaWduYWwudW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcXG5cXG4gIHJldHVybiBbc2lnbmFsLCAoKSA9PiB7XFxuICAgIHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XFxuICAgIHRpbWVyID0gbnVsbDtcXG4gIH1dO1xcbn07XFxuXFxudmFyIGNvbXBvc2VTaWduYWxzJDEgPSBjb21wb3NlU2lnbmFscztcXG5cXG5jb25zdCBzdHJlYW1DaHVuayA9IGZ1bmN0aW9uKiAoY2h1bmssIGNodW5rU2l6ZSkge1xcbiAgbGV0IGxlbiA9IGNodW5rLmJ5dGVMZW5ndGg7XFxuXFxuICBpZiAoIWNodW5rU2l6ZSB8fCBsZW4gPCBjaHVua1NpemUpIHtcXG4gICAgeWllbGQgY2h1bms7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGxldCBwb3MgPSAwO1xcbiAgbGV0IGVuZDtcXG5cXG4gIHdoaWxlIChwb3MgPCBsZW4pIHtcXG4gICAgZW5kID0gcG9zICsgY2h1bmtTaXplO1xcbiAgICB5aWVsZCBjaHVuay5zbGljZShwb3MsIGVuZCk7XFxuICAgIHBvcyA9IGVuZDtcXG4gIH1cXG59O1xcblxcbmNvbnN0IHJlYWRCeXRlcyA9IGFzeW5jIGZ1bmN0aW9uKiAoaXRlcmFibGUsIGNodW5rU2l6ZSwgZW5jb2RlKSB7XFxuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXJhYmxlKSB7XFxuICAgIHlpZWxkKiBzdHJlYW1DaHVuayhBcnJheUJ1ZmZlci5pc1ZpZXcoY2h1bmspID8gY2h1bmsgOiAoYXdhaXQgZW5jb2RlKFN0cmluZyhjaHVuaykpKSwgY2h1bmtTaXplKTtcXG4gIH1cXG59O1xcblxcbmNvbnN0IHRyYWNrU3RyZWFtID0gKHN0cmVhbSwgY2h1bmtTaXplLCBvblByb2dyZXNzLCBvbkZpbmlzaCwgZW5jb2RlKSA9PiB7XFxuICBjb25zdCBpdGVyYXRvciA9IHJlYWRCeXRlcyhzdHJlYW0sIGNodW5rU2l6ZSwgZW5jb2RlKTtcXG5cXG4gIGxldCBieXRlcyA9IDA7XFxuXFxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcXG4gICAgdHlwZTogJ2J5dGVzJyxcXG5cXG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XFxuICAgICAgY29uc3Qge2RvbmUsIHZhbHVlfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcXG5cXG4gICAgICBpZiAoZG9uZSkge1xcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xcbiAgICAgICAgb25GaW5pc2goKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgbGV0IGxlbiA9IHZhbHVlLmJ5dGVMZW5ndGg7XFxuICAgICAgb25Qcm9ncmVzcyAmJiBvblByb2dyZXNzKGJ5dGVzICs9IGxlbik7XFxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XFxuICAgIH0sXFxuICAgIGNhbmNlbChyZWFzb24pIHtcXG4gICAgICBvbkZpbmlzaChyZWFzb24pO1xcbiAgICAgIHJldHVybiBpdGVyYXRvci5yZXR1cm4oKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBoaWdoV2F0ZXJNYXJrOiAyXFxuICB9KVxcbn07XFxuXFxuY29uc3QgZmV0Y2hQcm9ncmVzc0RlY29yYXRvciA9ICh0b3RhbCwgZm4pID0+IHtcXG4gIGNvbnN0IGxlbmd0aENvbXB1dGFibGUgPSB0b3RhbCAhPSBudWxsO1xcbiAgcmV0dXJuIChsb2FkZWQpID0+IHNldFRpbWVvdXQoKCkgPT4gZm4oe1xcbiAgICBsZW5ndGhDb21wdXRhYmxlLFxcbiAgICB0b3RhbCxcXG4gICAgbG9hZGVkXFxuICB9KSk7XFxufTtcXG5cXG5jb25zdCBpc0ZldGNoU3VwcG9ydGVkID0gdHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJztcXG5jb25zdCBpc1JlYWRhYmxlU3RyZWFtU3VwcG9ydGVkID0gaXNGZXRjaFN1cHBvcnRlZCAmJiB0eXBlb2YgUmVhZGFibGVTdHJlYW0gPT09ICdmdW5jdGlvbic7XFxuXFxuLy8gdXNlZCBvbmx5IGluc2lkZSB0aGUgZmV0Y2ggYWRhcHRlclxcbmNvbnN0IGVuY29kZVRleHQgPSBpc0ZldGNoU3VwcG9ydGVkICYmICh0eXBlb2YgVGV4dEVuY29kZXIgPT09ICdmdW5jdGlvbicgP1xcbiAgICAoKGVuY29kZXIpID0+IChzdHIpID0+IGVuY29kZXIuZW5jb2RlKHN0cikpKG5ldyBUZXh0RW5jb2RlcigpKSA6XFxuICAgIGFzeW5jIChzdHIpID0+IG5ldyBVaW50OEFycmF5KGF3YWl0IG5ldyBSZXNwb25zZShzdHIpLmFycmF5QnVmZmVyKCkpXFxuKTtcXG5cXG5jb25zdCBzdXBwb3J0c1JlcXVlc3RTdHJlYW0gPSBpc1JlYWRhYmxlU3RyZWFtU3VwcG9ydGVkICYmICgoKSA9PiB7XFxuICBsZXQgZHVwbGV4QWNjZXNzZWQgPSBmYWxzZTtcXG5cXG4gIGNvbnN0IGhhc0NvbnRlbnRUeXBlID0gbmV3IFJlcXVlc3QocGxhdGZvcm0ub3JpZ2luLCB7XFxuICAgIGJvZHk6IG5ldyBSZWFkYWJsZVN0cmVhbSgpLFxcbiAgICBtZXRob2Q6ICdQT1NUJyxcXG4gICAgZ2V0IGR1cGxleCgpIHtcXG4gICAgICBkdXBsZXhBY2Nlc3NlZCA9IHRydWU7XFxuICAgICAgcmV0dXJuICdoYWxmJztcXG4gICAgfSxcXG4gIH0pLmhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKTtcXG5cXG4gIHJldHVybiBkdXBsZXhBY2Nlc3NlZCAmJiAhaGFzQ29udGVudFR5cGU7XFxufSkoKTtcXG5cXG5jb25zdCBERUZBVUxUX0NIVU5LX1NJWkUgPSA2NCAqIDEwMjQ7XFxuXFxuY29uc3Qgc3VwcG9ydHNSZXNwb25zZVN0cmVhbSA9IGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgJiYgISEoKCk9PiB7XFxuICB0cnkge1xcbiAgICByZXR1cm4gdXRpbHMkMS5pc1JlYWRhYmxlU3RyZWFtKG5ldyBSZXNwb25zZSgnJykuYm9keSk7XFxuICB9IGNhdGNoKGVycikge1xcbiAgICAvLyByZXR1cm4gdW5kZWZpbmVkXFxuICB9XFxufSkoKTtcXG5cXG5jb25zdCByZXNvbHZlcnMgPSB7XFxuICBzdHJlYW06IHN1cHBvcnRzUmVzcG9uc2VTdHJlYW0gJiYgKChyZXMpID0+IHJlcy5ib2R5KVxcbn07XFxuXFxuaXNGZXRjaFN1cHBvcnRlZCAmJiAoKChyZXMpID0+IHtcXG4gIFsndGV4dCcsICdhcnJheUJ1ZmZlcicsICdibG9iJywgJ2Zvcm1EYXRhJywgJ3N0cmVhbSddLmZvckVhY2godHlwZSA9PiB7XFxuICAgICFyZXNvbHZlcnNbdHlwZV0gJiYgKHJlc29sdmVyc1t0eXBlXSA9IHV0aWxzJDEuaXNGdW5jdGlvbihyZXNbdHlwZV0pID8gKHJlcykgPT4gcmVzW3R5cGVdKCkgOlxcbiAgICAgIChfLCBjb25maWcpID0+IHtcXG4gICAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKGBSZXNwb25zZSB0eXBlICcke3R5cGV9JyBpcyBub3Qgc3VwcG9ydGVkYCwgQXhpb3NFcnJvci5FUlJfTk9UX1NVUFBPUlQsIGNvbmZpZyk7XFxuICAgICAgfSk7XFxuICB9KTtcXG59KShuZXcgUmVzcG9uc2UpKTtcXG5cXG5jb25zdCBnZXRCb2R5TGVuZ3RoID0gYXN5bmMgKGJvZHkpID0+IHtcXG4gIGlmIChib2R5ID09IG51bGwpIHtcXG4gICAgcmV0dXJuIDA7XFxuICB9XFxuXFxuICBpZih1dGlscyQxLmlzQmxvYihib2R5KSkge1xcbiAgICByZXR1cm4gYm9keS5zaXplO1xcbiAgfVxcblxcbiAgaWYodXRpbHMkMS5pc1NwZWNDb21wbGlhbnRGb3JtKGJvZHkpKSB7XFxuICAgIHJldHVybiAoYXdhaXQgbmV3IFJlcXVlc3QoYm9keSkuYXJyYXlCdWZmZXIoKSkuYnl0ZUxlbmd0aDtcXG4gIH1cXG5cXG4gIGlmKHV0aWxzJDEuaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpIHtcXG4gICAgcmV0dXJuIGJvZHkuYnl0ZUxlbmd0aDtcXG4gIH1cXG5cXG4gIGlmKHV0aWxzJDEuaXNVUkxTZWFyY2hQYXJhbXMoYm9keSkpIHtcXG4gICAgYm9keSA9IGJvZHkgKyAnJztcXG4gIH1cXG5cXG4gIGlmKHV0aWxzJDEuaXNTdHJpbmcoYm9keSkpIHtcXG4gICAgcmV0dXJuIChhd2FpdCBlbmNvZGVUZXh0KGJvZHkpKS5ieXRlTGVuZ3RoO1xcbiAgfVxcbn07XFxuXFxuY29uc3QgcmVzb2x2ZUJvZHlMZW5ndGggPSBhc3luYyAoaGVhZGVycywgYm9keSkgPT4ge1xcbiAgY29uc3QgbGVuZ3RoID0gdXRpbHMkMS50b0Zpbml0ZU51bWJlcihoZWFkZXJzLmdldENvbnRlbnRMZW5ndGgoKSk7XFxuXFxuICByZXR1cm4gbGVuZ3RoID09IG51bGwgPyBnZXRCb2R5TGVuZ3RoKGJvZHkpIDogbGVuZ3RoO1xcbn07XFxuXFxudmFyIGZldGNoQWRhcHRlciA9IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgKGFzeW5jIChjb25maWcpID0+IHtcXG4gIGxldCB7XFxuICAgIHVybCxcXG4gICAgbWV0aG9kLFxcbiAgICBkYXRhLFxcbiAgICBzaWduYWwsXFxuICAgIGNhbmNlbFRva2VuLFxcbiAgICB0aW1lb3V0LFxcbiAgICBvbkRvd25sb2FkUHJvZ3Jlc3MsXFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3MsXFxuICAgIHJlc3BvbnNlVHlwZSxcXG4gICAgaGVhZGVycyxcXG4gICAgd2l0aENyZWRlbnRpYWxzID0gJ3NhbWUtb3JpZ2luJyxcXG4gICAgZmV0Y2hPcHRpb25zXFxuICB9ID0gcmVzb2x2ZUNvbmZpZyhjb25maWcpO1xcblxcbiAgcmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlID8gKHJlc3BvbnNlVHlwZSArICcnKS50b0xvd2VyQ2FzZSgpIDogJ3RleHQnO1xcblxcbiAgbGV0IFtjb21wb3NlZFNpZ25hbCwgc3RvcFRpbWVvdXRdID0gKHNpZ25hbCB8fCBjYW5jZWxUb2tlbiB8fCB0aW1lb3V0KSA/XFxuICAgIGNvbXBvc2VTaWduYWxzJDEoW3NpZ25hbCwgY2FuY2VsVG9rZW5dLCB0aW1lb3V0KSA6IFtdO1xcblxcbiAgbGV0IGZpbmlzaGVkLCByZXF1ZXN0O1xcblxcbiAgY29uc3Qgb25GaW5pc2ggPSAoKSA9PiB7XFxuICAgICFmaW5pc2hlZCAmJiBzZXRUaW1lb3V0KCgpID0+IHtcXG4gICAgICBjb21wb3NlZFNpZ25hbCAmJiBjb21wb3NlZFNpZ25hbC51bnN1YnNjcmliZSgpO1xcbiAgICB9KTtcXG5cXG4gICAgZmluaXNoZWQgPSB0cnVlO1xcbiAgfTtcXG5cXG4gIGxldCByZXF1ZXN0Q29udGVudExlbmd0aDtcXG5cXG4gIHRyeSB7XFxuICAgIGlmIChcXG4gICAgICBvblVwbG9hZFByb2dyZXNzICYmIHN1cHBvcnRzUmVxdWVzdFN0cmVhbSAmJiBtZXRob2QgIT09ICdnZXQnICYmIG1ldGhvZCAhPT0gJ2hlYWQnICYmXFxuICAgICAgKHJlcXVlc3RDb250ZW50TGVuZ3RoID0gYXdhaXQgcmVzb2x2ZUJvZHlMZW5ndGgoaGVhZGVycywgZGF0YSkpICE9PSAwXFxuICAgICkge1xcbiAgICAgIGxldCBfcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwge1xcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXFxuICAgICAgICBib2R5OiBkYXRhLFxcbiAgICAgICAgZHVwbGV4OiBcXFwiaGFsZlxcXCJcXG4gICAgICB9KTtcXG5cXG4gICAgICBsZXQgY29udGVudFR5cGVIZWFkZXI7XFxuXFxuICAgICAgaWYgKHV0aWxzJDEuaXNGb3JtRGF0YShkYXRhKSAmJiAoY29udGVudFR5cGVIZWFkZXIgPSBfcmVxdWVzdC5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpKSB7XFxuICAgICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKGNvbnRlbnRUeXBlSGVhZGVyKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKF9yZXF1ZXN0LmJvZHkpIHtcXG4gICAgICAgIGRhdGEgPSB0cmFja1N0cmVhbShfcmVxdWVzdC5ib2R5LCBERUZBVUxUX0NIVU5LX1NJWkUsIGZldGNoUHJvZ3Jlc3NEZWNvcmF0b3IoXFxuICAgICAgICAgIHJlcXVlc3RDb250ZW50TGVuZ3RoLFxcbiAgICAgICAgICBwcm9ncmVzc0V2ZW50UmVkdWNlcihvblVwbG9hZFByb2dyZXNzKVxcbiAgICAgICAgKSwgbnVsbCwgZW5jb2RlVGV4dCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmICghdXRpbHMkMS5pc1N0cmluZyh3aXRoQ3JlZGVudGlhbHMpKSB7XFxuICAgICAgd2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzID8gJ2NvcnMnIDogJ29taXQnO1xcbiAgICB9XFxuXFxuICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIHtcXG4gICAgICAuLi5mZXRjaE9wdGlvbnMsXFxuICAgICAgc2lnbmFsOiBjb21wb3NlZFNpZ25hbCxcXG4gICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpLFxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMubm9ybWFsaXplKCkudG9KU09OKCksXFxuICAgICAgYm9keTogZGF0YSxcXG4gICAgICBkdXBsZXg6IFxcXCJoYWxmXFxcIixcXG4gICAgICB3aXRoQ3JlZGVudGlhbHNcXG4gICAgfSk7XFxuXFxuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QpO1xcblxcbiAgICBjb25zdCBpc1N0cmVhbVJlc3BvbnNlID0gc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAocmVzcG9uc2VUeXBlID09PSAnc3RyZWFtJyB8fCByZXNwb25zZVR5cGUgPT09ICdyZXNwb25zZScpO1xcblxcbiAgICBpZiAoc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAob25Eb3dubG9hZFByb2dyZXNzIHx8IGlzU3RyZWFtUmVzcG9uc2UpKSB7XFxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xcblxcbiAgICAgIFsnc3RhdHVzJywgJ3N0YXR1c1RleHQnLCAnaGVhZGVycyddLmZvckVhY2gocHJvcCA9PiB7XFxuICAgICAgICBvcHRpb25zW3Byb3BdID0gcmVzcG9uc2VbcHJvcF07XFxuICAgICAgfSk7XFxuXFxuICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50TGVuZ3RoID0gdXRpbHMkMS50b0Zpbml0ZU51bWJlcihyZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKSk7XFxuXFxuICAgICAgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoXFxuICAgICAgICB0cmFja1N0cmVhbShyZXNwb25zZS5ib2R5LCBERUZBVUxUX0NIVU5LX1NJWkUsIG9uRG93bmxvYWRQcm9ncmVzcyAmJiBmZXRjaFByb2dyZXNzRGVjb3JhdG9yKFxcbiAgICAgICAgICByZXNwb25zZUNvbnRlbnRMZW5ndGgsXFxuICAgICAgICAgIHByb2dyZXNzRXZlbnRSZWR1Y2VyKG9uRG93bmxvYWRQcm9ncmVzcywgdHJ1ZSlcXG4gICAgICAgICksIGlzU3RyZWFtUmVzcG9uc2UgJiYgb25GaW5pc2gsIGVuY29kZVRleHQpLFxcbiAgICAgICAgb3B0aW9uc1xcbiAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgcmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlIHx8ICd0ZXh0JztcXG5cXG4gICAgbGV0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHJlc29sdmVyc1t1dGlscyQxLmZpbmRLZXkocmVzb2x2ZXJzLCByZXNwb25zZVR5cGUpIHx8ICd0ZXh0J10ocmVzcG9uc2UsIGNvbmZpZyk7XFxuXFxuICAgICFpc1N0cmVhbVJlc3BvbnNlICYmIG9uRmluaXNoKCk7XFxuXFxuICAgIHN0b3BUaW1lb3V0ICYmIHN0b3BUaW1lb3V0KCk7XFxuXFxuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwge1xcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxcbiAgICAgICAgaGVhZGVyczogQXhpb3NIZWFkZXJzJDEuZnJvbShyZXNwb25zZS5oZWFkZXJzKSxcXG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcXG4gICAgICAgIGNvbmZpZyxcXG4gICAgICAgIHJlcXVlc3RcXG4gICAgICB9KTtcXG4gICAgfSlcXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICBvbkZpbmlzaCgpO1xcblxcbiAgICBpZiAoZXJyICYmIGVyci5uYW1lID09PSAnVHlwZUVycm9yJyAmJiAvZmV0Y2gvaS50ZXN0KGVyci5tZXNzYWdlKSkge1xcbiAgICAgIHRocm93IE9iamVjdC5hc3NpZ24oXFxuICAgICAgICBuZXcgQXhpb3NFcnJvcignTmV0d29yayBFcnJvcicsIEF4aW9zRXJyb3IuRVJSX05FVFdPUkssIGNvbmZpZywgcmVxdWVzdCksXFxuICAgICAgICB7XFxuICAgICAgICAgIGNhdXNlOiBlcnIuY2F1c2UgfHwgZXJyXFxuICAgICAgICB9XFxuICAgICAgKVxcbiAgICB9XFxuXFxuICAgIHRocm93IEF4aW9zRXJyb3IuZnJvbShlcnIsIGVyciAmJiBlcnIuY29kZSwgY29uZmlnLCByZXF1ZXN0KTtcXG4gIH1cXG59KTtcXG5cXG5jb25zdCBrbm93bkFkYXB0ZXJzID0ge1xcbiAgaHR0cDogaHR0cEFkYXB0ZXIsXFxuICB4aHI6IHhockFkYXB0ZXIsXFxuICBmZXRjaDogZmV0Y2hBZGFwdGVyXFxufTtcXG5cXG51dGlscyQxLmZvckVhY2goa25vd25BZGFwdGVycywgKGZuLCB2YWx1ZSkgPT4ge1xcbiAgaWYgKGZuKSB7XFxuICAgIHRyeSB7XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbmFtZScsIHt2YWx1ZX0pO1xcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XFxuICAgIH1cXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnYWRhcHRlck5hbWUnLCB7dmFsdWV9KTtcXG4gIH1cXG59KTtcXG5cXG5jb25zdCByZW5kZXJSZWFzb24gPSAocmVhc29uKSA9PiBgLSAke3JlYXNvbn1gO1xcblxcbmNvbnN0IGlzUmVzb2x2ZWRIYW5kbGUgPSAoYWRhcHRlcikgPT4gdXRpbHMkMS5pc0Z1bmN0aW9uKGFkYXB0ZXIpIHx8IGFkYXB0ZXIgPT09IG51bGwgfHwgYWRhcHRlciA9PT0gZmFsc2U7XFxuXFxudmFyIGFkYXB0ZXJzID0ge1xcbiAgZ2V0QWRhcHRlcjogKGFkYXB0ZXJzKSA9PiB7XFxuICAgIGFkYXB0ZXJzID0gdXRpbHMkMS5pc0FycmF5KGFkYXB0ZXJzKSA/IGFkYXB0ZXJzIDogW2FkYXB0ZXJzXTtcXG5cXG4gICAgY29uc3Qge2xlbmd0aH0gPSBhZGFwdGVycztcXG4gICAgbGV0IG5hbWVPckFkYXB0ZXI7XFxuICAgIGxldCBhZGFwdGVyO1xcblxcbiAgICBjb25zdCByZWplY3RlZFJlYXNvbnMgPSB7fTtcXG5cXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICAgIG5hbWVPckFkYXB0ZXIgPSBhZGFwdGVyc1tpXTtcXG4gICAgICBsZXQgaWQ7XFxuXFxuICAgICAgYWRhcHRlciA9IG5hbWVPckFkYXB0ZXI7XFxuXFxuICAgICAgaWYgKCFpc1Jlc29sdmVkSGFuZGxlKG5hbWVPckFkYXB0ZXIpKSB7XFxuICAgICAgICBhZGFwdGVyID0ga25vd25BZGFwdGVyc1soaWQgPSBTdHJpbmcobmFtZU9yQWRhcHRlcikpLnRvTG93ZXJDYXNlKCldO1xcblxcbiAgICAgICAgaWYgKGFkYXB0ZXIgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihgVW5rbm93biBhZGFwdGVyICcke2lkfSdgKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGFkYXB0ZXIpIHtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG5cXG4gICAgICByZWplY3RlZFJlYXNvbnNbaWQgfHwgJyMnICsgaV0gPSBhZGFwdGVyO1xcbiAgICB9XFxuXFxuICAgIGlmICghYWRhcHRlcikge1xcblxcbiAgICAgIGNvbnN0IHJlYXNvbnMgPSBPYmplY3QuZW50cmllcyhyZWplY3RlZFJlYXNvbnMpXFxuICAgICAgICAubWFwKChbaWQsIHN0YXRlXSkgPT4gYGFkYXB0ZXIgJHtpZH0gYCArXFxuICAgICAgICAgIChzdGF0ZSA9PT0gZmFsc2UgPyAnaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQnIDogJ2lzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJ1aWxkJylcXG4gICAgICAgICk7XFxuXFxuICAgICAgbGV0IHMgPSBsZW5ndGggP1xcbiAgICAgICAgKHJlYXNvbnMubGVuZ3RoID4gMSA/ICdzaW5jZSA6XFxcXG4nICsgcmVhc29ucy5tYXAocmVuZGVyUmVhc29uKS5qb2luKCdcXFxcbicpIDogJyAnICsgcmVuZGVyUmVhc29uKHJlYXNvbnNbMF0pKSA6XFxuICAgICAgICAnYXMgbm8gYWRhcHRlciBzcGVjaWZpZWQnO1xcblxcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKFxcbiAgICAgICAgYFRoZXJlIGlzIG5vIHN1aXRhYmxlIGFkYXB0ZXIgdG8gZGlzcGF0Y2ggdGhlIHJlcXVlc3QgYCArIHMsXFxuICAgICAgICAnRVJSX05PVF9TVVBQT1JUJ1xcbiAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGFkYXB0ZXI7XFxuICB9LFxcbiAgYWRhcHRlcnM6IGtub3duQWRhcHRlcnNcXG59O1xcblxcbi8qKlxcbiAqIFRocm93cyBhIGBDYW5jZWxlZEVycm9yYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcXG4gKlxcbiAqIEByZXR1cm5zIHt2b2lkfVxcbiAqL1xcbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XFxuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XFxuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XFxuICB9XFxuXFxuICBpZiAoY29uZmlnLnNpZ25hbCAmJiBjb25maWcuc2lnbmFsLmFib3J0ZWQpIHtcXG4gICAgdGhyb3cgbmV3IENhbmNlbGVkRXJyb3IobnVsbCwgY29uZmlnKTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cXG4gKlxcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XFxuICpcXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXFxuICovXFxuZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xcblxcbiAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKGNvbmZpZy5oZWFkZXJzKTtcXG5cXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxcbiAgICBjb25maWcsXFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XFxuICApO1xcblxcbiAgaWYgKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXS5pbmRleE9mKGNvbmZpZy5tZXRob2QpICE9PSAtMSkge1xcbiAgICBjb25maWcuaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJywgZmFsc2UpO1xcbiAgfVxcblxcbiAgY29uc3QgYWRhcHRlciA9IGFkYXB0ZXJzLmdldEFkYXB0ZXIoY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMkMS5hZGFwdGVyKTtcXG5cXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XFxuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcXG5cXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcXG4gICAgICBjb25maWcsXFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlLFxcbiAgICAgIHJlc3BvbnNlXFxuICAgICk7XFxuXFxuICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKHJlc3BvbnNlLmhlYWRlcnMpO1xcblxcbiAgICByZXR1cm4gcmVzcG9uc2U7XFxuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XFxuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcXG5cXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XFxuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcXG4gICAgICAgICAgY29uZmlnLFxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UsXFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZVxcbiAgICAgICAgKTtcXG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzID0gQXhpb3NIZWFkZXJzJDEuZnJvbShyZWFzb24ucmVzcG9uc2UuaGVhZGVycyk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xcbiAgfSk7XFxufVxcblxcbmNvbnN0IFZFUlNJT04gPSBcXFwiMS43LjJcXFwiO1xcblxcbmNvbnN0IHZhbGlkYXRvcnMkMSA9IHt9O1xcblxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXFxuWydvYmplY3QnLCAnYm9vbGVhbicsICdudW1iZXInLCAnZnVuY3Rpb24nLCAnc3RyaW5nJywgJ3N5bWJvbCddLmZvckVhY2goKHR5cGUsIGkpID0+IHtcXG4gIHZhbGlkYXRvcnMkMVt0eXBlXSA9IGZ1bmN0aW9uIHZhbGlkYXRvcih0aGluZykge1xcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcXG4gIH07XFxufSk7XFxuXFxuY29uc3QgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XFxuXFxuLyoqXFxuICogVHJhbnNpdGlvbmFsIG9wdGlvbiB2YWxpZGF0b3JcXG4gKlxcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvciAtIHNldCB0byBmYWxzZSBpZiB0aGUgdHJhbnNpdGlvbmFsIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkXFxuICogQHBhcmFtIHtzdHJpbmc/fSB2ZXJzaW9uIC0gZGVwcmVjYXRlZCB2ZXJzaW9uIC8gcmVtb3ZlZCBzaW5jZSB2ZXJzaW9uXFxuICogQHBhcmFtIHtzdHJpbmc/fSBtZXNzYWdlIC0gc29tZSBtZXNzYWdlIHdpdGggYWRkaXRpb25hbCBpbmZvXFxuICpcXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XFxuICovXFxudmFsaWRhdG9ycyQxLnRyYW5zaXRpb25hbCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25hbCh2YWxpZGF0b3IsIHZlcnNpb24sIG1lc3NhZ2UpIHtcXG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XFxuICAgIHJldHVybiAnW0F4aW9zIHYnICsgVkVSU0lPTiArICddIFRyYW5zaXRpb25hbCBvcHRpb24gXFxcXCcnICsgb3B0ICsgJ1xcXFwnJyArIGRlc2MgKyAobWVzc2FnZSA/ICcuICcgKyBtZXNzYWdlIDogJycpO1xcbiAgfVxcblxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcXG4gIHJldHVybiAodmFsdWUsIG9wdCwgb3B0cykgPT4ge1xcbiAgICBpZiAodmFsaWRhdG9yID09PSBmYWxzZSkge1xcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKFxcbiAgICAgICAgZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCcgKyAodmVyc2lvbiA/ICcgaW4gJyArIHZlcnNpb24gOiAnJykpLFxcbiAgICAgICAgQXhpb3NFcnJvci5FUlJfREVQUkVDQVRFRFxcbiAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHZlcnNpb24gJiYgIWRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdKSB7XFxuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXFxuICAgICAgY29uc29sZS53YXJuKFxcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcXG4gICAgICAgICAgb3B0LFxcbiAgICAgICAgICAnIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdicgKyB2ZXJzaW9uICsgJyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZWFyIGZ1dHVyZSdcXG4gICAgICAgIClcXG4gICAgICApO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB2YWxpZGF0b3IgPyB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0cykgOiB0cnVlO1xcbiAgfTtcXG59O1xcblxcbi8qKlxcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcXG4gKlxcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXFxuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGFsbG93VW5rbm93blxcbiAqXFxuICogQHJldHVybnMge29iamVjdH1cXG4gKi9cXG5cXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XFxuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XFxuICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0JywgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTl9WQUxVRSk7XFxuICB9XFxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XFxuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xcbiAgd2hpbGUgKGktLSA+IDApIHtcXG4gICAgY29uc3Qgb3B0ID0ga2V5c1tpXTtcXG4gICAgY29uc3QgdmFsaWRhdG9yID0gc2NoZW1hW29wdF07XFxuICAgIGlmICh2YWxpZGF0b3IpIHtcXG4gICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNbb3B0XTtcXG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRpb25zKTtcXG4gICAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XFxuICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9uICcgKyBvcHQgKyAnIG11c3QgYmUgJyArIHJlc3VsdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTl9WQUxVRSk7XFxuICAgICAgfVxcbiAgICAgIGNvbnRpbnVlO1xcbiAgICB9XFxuICAgIGlmIChhbGxvd1Vua25vd24gIT09IHRydWUpIHtcXG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTik7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxudmFyIHZhbGlkYXRvciA9IHtcXG4gIGFzc2VydE9wdGlvbnMsXFxuICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzJDFcXG59O1xcblxcbmNvbnN0IHZhbGlkYXRvcnMgPSB2YWxpZGF0b3IudmFsaWRhdG9ycztcXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxcbiAqXFxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXFxuICovXFxuY2xhc3MgQXhpb3Mge1xcbiAgY29uc3RydWN0b3IoaW5zdGFuY2VDb25maWcpIHtcXG4gICAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xcbiAgICB0aGlzLmludGVyY2VwdG9ycyA9IHtcXG4gICAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyJDEoKSxcXG4gICAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlciQxKClcXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogRGlzcGF0Y2ggYSByZXF1ZXN0XFxuICAgKlxcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWdPclVybCBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXFxuICAgKiBAcGFyYW0gez9PYmplY3R9IGNvbmZpZ1xcbiAgICpcXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcXG4gICAqL1xcbiAgYXN5bmMgcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKSB7XFxuICAgIHRyeSB7XFxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZyk7XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xcbiAgICAgICAgbGV0IGR1bW15O1xcblxcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShkdW1teSA9IHt9KSA6IChkdW1teSA9IG5ldyBFcnJvcigpKTtcXG5cXG4gICAgICAgIC8vIHNsaWNlIG9mZiB0aGUgRXJyb3I6IC4uLiBsaW5lXFxuICAgICAgICBjb25zdCBzdGFjayA9IGR1bW15LnN0YWNrID8gZHVtbXkuc3RhY2sucmVwbGFjZSgvXi4rXFxcXG4vLCAnJykgOiAnJztcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGlmICghZXJyLnN0YWNrKSB7XFxuICAgICAgICAgICAgZXJyLnN0YWNrID0gc3RhY2s7XFxuICAgICAgICAgICAgLy8gbWF0Y2ggd2l0aG91dCB0aGUgMiB0b3Agc3RhY2sgbGluZXNcXG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFjayAmJiAhU3RyaW5nKGVyci5zdGFjaykuZW5kc1dpdGgoc3RhY2sucmVwbGFjZSgvXi4rXFxcXG4uK1xcXFxuLywgJycpKSkge1xcbiAgICAgICAgICAgIGVyci5zdGFjayArPSAnXFxcXG4nICsgc3RhY2s7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgLy8gaWdub3JlIHRoZSBjYXNlIHdoZXJlIFxcXCJzdGFja1xcXCIgaXMgYW4gdW4td3JpdGFibGUgcHJvcGVydHlcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhyb3cgZXJyO1xcbiAgICB9XFxuICB9XFxuXFxuICBfcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKSB7XFxuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xcbiAgICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXFxuICAgIGlmICh0eXBlb2YgY29uZmlnT3JVcmwgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xcbiAgICAgIGNvbmZpZy51cmwgPSBjb25maWdPclVybDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjb25maWcgPSBjb25maWdPclVybCB8fCB7fTtcXG4gICAgfVxcblxcbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xcblxcbiAgICBjb25zdCB7dHJhbnNpdGlvbmFsLCBwYXJhbXNTZXJpYWxpemVyLCBoZWFkZXJzfSA9IGNvbmZpZztcXG5cXG4gICAgaWYgKHRyYW5zaXRpb25hbCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XFxuICAgICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcXG4gICAgICAgIGZvcmNlZEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxcbiAgICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKVxcbiAgICAgIH0sIGZhbHNlKTtcXG4gICAgfVxcblxcbiAgICBpZiAocGFyYW1zU2VyaWFsaXplciAhPSBudWxsKSB7XFxuICAgICAgaWYgKHV0aWxzJDEuaXNGdW5jdGlvbihwYXJhbXNTZXJpYWxpemVyKSkge1xcbiAgICAgICAgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIgPSB7XFxuICAgICAgICAgIHNlcmlhbGl6ZTogcGFyYW1zU2VyaWFsaXplclxcbiAgICAgICAgfTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnMocGFyYW1zU2VyaWFsaXplciwge1xcbiAgICAgICAgICBlbmNvZGU6IHZhbGlkYXRvcnMuZnVuY3Rpb24sXFxuICAgICAgICAgIHNlcmlhbGl6ZTogdmFsaWRhdG9ycy5mdW5jdGlvblxcbiAgICAgICAgfSwgdHJ1ZSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIFNldCBjb25maWcubWV0aG9kXFxuICAgIGNvbmZpZy5tZXRob2QgPSAoY29uZmlnLm1ldGhvZCB8fCB0aGlzLmRlZmF1bHRzLm1ldGhvZCB8fCAnZ2V0JykudG9Mb3dlckNhc2UoKTtcXG5cXG4gICAgLy8gRmxhdHRlbiBoZWFkZXJzXFxuICAgIGxldCBjb250ZXh0SGVhZGVycyA9IGhlYWRlcnMgJiYgdXRpbHMkMS5tZXJnZShcXG4gICAgICBoZWFkZXJzLmNvbW1vbixcXG4gICAgICBoZWFkZXJzW2NvbmZpZy5tZXRob2RdXFxuICAgICk7XFxuXFxuICAgIGhlYWRlcnMgJiYgdXRpbHMkMS5mb3JFYWNoKFxcbiAgICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxcbiAgICAgIChtZXRob2QpID0+IHtcXG4gICAgICAgIGRlbGV0ZSBoZWFkZXJzW21ldGhvZF07XFxuICAgICAgfVxcbiAgICApO1xcblxcbiAgICBjb25maWcuaGVhZGVycyA9IEF4aW9zSGVhZGVycyQxLmNvbmNhdChjb250ZXh0SGVhZGVycywgaGVhZGVycyk7XFxuXFxuICAgIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcXG4gICAgY29uc3QgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4gPSBbXTtcXG4gICAgbGV0IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHRydWU7XFxuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xcbiAgICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IucnVuV2hlbiA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnRlcmNlcHRvci5ydW5XaGVuKGNvbmZpZykgPT09IGZhbHNlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyAmJiBpbnRlcmNlcHRvci5zeW5jaHJvbm91cztcXG5cXG4gICAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xcbiAgICB9KTtcXG5cXG4gICAgY29uc3QgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XFxuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XFxuICAgICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XFxuICAgIH0pO1xcblxcbiAgICBsZXQgcHJvbWlzZTtcXG4gICAgbGV0IGkgPSAwO1xcbiAgICBsZXQgbGVuO1xcblxcbiAgICBpZiAoIXN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycykge1xcbiAgICAgIGNvbnN0IGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdC5iaW5kKHRoaXMpLCB1bmRlZmluZWRdO1xcbiAgICAgIGNoYWluLnVuc2hpZnQuYXBwbHkoY2hhaW4sIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcXG4gICAgICBjaGFpbi5wdXNoLmFwcGx5KGNoYWluLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xcbiAgICAgIGxlbiA9IGNoYWluLmxlbmd0aDtcXG5cXG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XFxuXFxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcXG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW5baSsrXSwgY2hhaW5baSsrXSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwcm9taXNlO1xcbiAgICB9XFxuXFxuICAgIGxlbiA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLmxlbmd0aDtcXG5cXG4gICAgbGV0IG5ld0NvbmZpZyA9IGNvbmZpZztcXG5cXG4gICAgaSA9IDA7XFxuXFxuICAgIHdoaWxlIChpIDwgbGVuKSB7XFxuICAgICAgY29uc3Qgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xcbiAgICAgIGNvbnN0IG9uUmVqZWN0ZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBuZXdDb25maWcgPSBvbkZ1bGZpbGxlZChuZXdDb25maWcpO1xcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgICBvblJlamVjdGVkLmNhbGwodGhpcywgZXJyb3IpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHRyeSB7XFxuICAgICAgcHJvbWlzZSA9IGRpc3BhdGNoUmVxdWVzdC5jYWxsKHRoaXMsIG5ld0NvbmZpZyk7XFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcXG4gICAgfVxcblxcbiAgICBpID0gMDtcXG4gICAgbGVuID0gcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLmxlbmd0aDtcXG5cXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcXG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbltpKytdLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW5baSsrXSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHByb21pc2U7XFxuICB9XFxuXFxuICBnZXRVcmkoY29uZmlnKSB7XFxuICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XFxuICAgIGNvbnN0IGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XFxuICAgIHJldHVybiBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xcbiAgfVxcbn1cXG5cXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcXG51dGlscyQxLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcXG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcXG4gICAgICBtZXRob2QsXFxuICAgICAgdXJsLFxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcXG4gICAgfSkpO1xcbiAgfTtcXG59KTtcXG5cXG51dGlscyQxLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XFxuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xcblxcbiAgZnVuY3Rpb24gZ2VuZXJhdGVIVFRQTWV0aG9kKGlzRm9ybSkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24gaHR0cE1ldGhvZCh1cmwsIGRhdGEsIGNvbmZpZykge1xcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XFxuICAgICAgICBtZXRob2QsXFxuICAgICAgICBoZWFkZXJzOiBpc0Zvcm0gPyB7XFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcXG4gICAgICAgIH0gOiB7fSxcXG4gICAgICAgIHVybCxcXG4gICAgICAgIGRhdGFcXG4gICAgICB9KSk7XFxuICAgIH07XFxuICB9XFxuXFxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCgpO1xcblxcbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZCArICdGb3JtJ10gPSBnZW5lcmF0ZUhUVFBNZXRob2QodHJ1ZSk7XFxufSk7XFxuXFxudmFyIEF4aW9zJDEgPSBBeGlvcztcXG5cXG4vKipcXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxcbiAqXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxcbiAqXFxuICogQHJldHVybnMge0NhbmNlbFRva2VufVxcbiAqL1xcbmNsYXNzIENhbmNlbFRva2VuIHtcXG4gIGNvbnN0cnVjdG9yKGV4ZWN1dG9yKSB7XFxuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XFxuICAgIH1cXG5cXG4gICAgbGV0IHJlc29sdmVQcm9taXNlO1xcblxcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnN0IHRva2VuID0gdGhpcztcXG5cXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcXG4gICAgdGhpcy5wcm9taXNlLnRoZW4oY2FuY2VsID0+IHtcXG4gICAgICBpZiAoIXRva2VuLl9saXN0ZW5lcnMpIHJldHVybjtcXG5cXG4gICAgICBsZXQgaSA9IHRva2VuLl9saXN0ZW5lcnMubGVuZ3RoO1xcblxcbiAgICAgIHdoaWxlIChpLS0gPiAwKSB7XFxuICAgICAgICB0b2tlbi5fbGlzdGVuZXJzW2ldKGNhbmNlbCk7XFxuICAgICAgfVxcbiAgICAgIHRva2VuLl9saXN0ZW5lcnMgPSBudWxsO1xcbiAgICB9KTtcXG5cXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcXG4gICAgdGhpcy5wcm9taXNlLnRoZW4gPSBvbmZ1bGZpbGxlZCA9PiB7XFxuICAgICAgbGV0IF9yZXNvbHZlO1xcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXFxuICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xcbiAgICAgICAgdG9rZW4uc3Vic2NyaWJlKHJlc29sdmUpO1xcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xcbiAgICAgIH0pLnRoZW4ob25mdWxmaWxsZWQpO1xcblxcbiAgICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gcmVqZWN0KCkge1xcbiAgICAgICAgdG9rZW4udW5zdWJzY3JpYmUoX3Jlc29sdmUpO1xcbiAgICAgIH07XFxuXFxuICAgICAgcmV0dXJuIHByb21pc2U7XFxuICAgIH07XFxuXFxuICAgIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpIHtcXG4gICAgICBpZiAodG9rZW4ucmVhc29uKSB7XFxuICAgICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbGVkRXJyb3IobWVzc2FnZSwgY29uZmlnLCByZXF1ZXN0KTtcXG4gICAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXFxuICAgKi9cXG4gIHRocm93SWZSZXF1ZXN0ZWQoKSB7XFxuICAgIGlmICh0aGlzLnJlYXNvbikge1xcbiAgICAgIHRocm93IHRoaXMucmVhc29uO1xcbiAgICB9XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFN1YnNjcmliZSB0byB0aGUgY2FuY2VsIHNpZ25hbFxcbiAgICovXFxuXFxuICBzdWJzY3JpYmUobGlzdGVuZXIpIHtcXG4gICAgaWYgKHRoaXMucmVhc29uKSB7XFxuICAgICAgbGlzdGVuZXIodGhpcy5yZWFzb24pO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XFxuICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtsaXN0ZW5lcl07XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgY2FuY2VsIHNpZ25hbFxcbiAgICovXFxuXFxuICB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcXG4gICAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXFxuICAgKi9cXG4gIHN0YXRpYyBzb3VyY2UoKSB7XFxuICAgIGxldCBjYW5jZWw7XFxuICAgIGNvbnN0IHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcXG4gICAgICBjYW5jZWwgPSBjO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIHtcXG4gICAgICB0b2tlbixcXG4gICAgICBjYW5jZWxcXG4gICAgfTtcXG4gIH1cXG59XFxuXFxudmFyIENhbmNlbFRva2VuJDEgPSBDYW5jZWxUb2tlbjtcXG5cXG4vKipcXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxcbiAqXFxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cXG4gKlxcbiAqICBgYGBqc1xcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XFxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xcbiAqICBgYGBcXG4gKlxcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxcbiAqXFxuICogIGBgYGpzXFxuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcXG4gKiAgYGBgXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xcbiAqXFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxcbiAqL1xcbmZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XFxuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xcbiAgfTtcXG59XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xcbiAqXFxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XFxuICpcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XFxuICByZXR1cm4gdXRpbHMkMS5pc09iamVjdChwYXlsb2FkKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xcbn1cXG5cXG5jb25zdCBIdHRwU3RhdHVzQ29kZSA9IHtcXG4gIENvbnRpbnVlOiAxMDAsXFxuICBTd2l0Y2hpbmdQcm90b2NvbHM6IDEwMSxcXG4gIFByb2Nlc3Npbmc6IDEwMixcXG4gIEVhcmx5SGludHM6IDEwMyxcXG4gIE9rOiAyMDAsXFxuICBDcmVhdGVkOiAyMDEsXFxuICBBY2NlcHRlZDogMjAyLFxcbiAgTm9uQXV0aG9yaXRhdGl2ZUluZm9ybWF0aW9uOiAyMDMsXFxuICBOb0NvbnRlbnQ6IDIwNCxcXG4gIFJlc2V0Q29udGVudDogMjA1LFxcbiAgUGFydGlhbENvbnRlbnQ6IDIwNixcXG4gIE11bHRpU3RhdHVzOiAyMDcsXFxuICBBbHJlYWR5UmVwb3J0ZWQ6IDIwOCxcXG4gIEltVXNlZDogMjI2LFxcbiAgTXVsdGlwbGVDaG9pY2VzOiAzMDAsXFxuICBNb3ZlZFBlcm1hbmVudGx5OiAzMDEsXFxuICBGb3VuZDogMzAyLFxcbiAgU2VlT3RoZXI6IDMwMyxcXG4gIE5vdE1vZGlmaWVkOiAzMDQsXFxuICBVc2VQcm94eTogMzA1LFxcbiAgVW51c2VkOiAzMDYsXFxuICBUZW1wb3JhcnlSZWRpcmVjdDogMzA3LFxcbiAgUGVybWFuZW50UmVkaXJlY3Q6IDMwOCxcXG4gIEJhZFJlcXVlc3Q6IDQwMCxcXG4gIFVuYXV0aG9yaXplZDogNDAxLFxcbiAgUGF5bWVudFJlcXVpcmVkOiA0MDIsXFxuICBGb3JiaWRkZW46IDQwMyxcXG4gIE5vdEZvdW5kOiA0MDQsXFxuICBNZXRob2ROb3RBbGxvd2VkOiA0MDUsXFxuICBOb3RBY2NlcHRhYmxlOiA0MDYsXFxuICBQcm94eUF1dGhlbnRpY2F0aW9uUmVxdWlyZWQ6IDQwNyxcXG4gIFJlcXVlc3RUaW1lb3V0OiA0MDgsXFxuICBDb25mbGljdDogNDA5LFxcbiAgR29uZTogNDEwLFxcbiAgTGVuZ3RoUmVxdWlyZWQ6IDQxMSxcXG4gIFByZWNvbmRpdGlvbkZhaWxlZDogNDEyLFxcbiAgUGF5bG9hZFRvb0xhcmdlOiA0MTMsXFxuICBVcmlUb29Mb25nOiA0MTQsXFxuICBVbnN1cHBvcnRlZE1lZGlhVHlwZTogNDE1LFxcbiAgUmFuZ2VOb3RTYXRpc2ZpYWJsZTogNDE2LFxcbiAgRXhwZWN0YXRpb25GYWlsZWQ6IDQxNyxcXG4gIEltQVRlYXBvdDogNDE4LFxcbiAgTWlzZGlyZWN0ZWRSZXF1ZXN0OiA0MjEsXFxuICBVbnByb2Nlc3NhYmxlRW50aXR5OiA0MjIsXFxuICBMb2NrZWQ6IDQyMyxcXG4gIEZhaWxlZERlcGVuZGVuY3k6IDQyNCxcXG4gIFRvb0Vhcmx5OiA0MjUsXFxuICBVcGdyYWRlUmVxdWlyZWQ6IDQyNixcXG4gIFByZWNvbmRpdGlvblJlcXVpcmVkOiA0MjgsXFxuICBUb29NYW55UmVxdWVzdHM6IDQyOSxcXG4gIFJlcXVlc3RIZWFkZXJGaWVsZHNUb29MYXJnZTogNDMxLFxcbiAgVW5hdmFpbGFibGVGb3JMZWdhbFJlYXNvbnM6IDQ1MSxcXG4gIEludGVybmFsU2VydmVyRXJyb3I6IDUwMCxcXG4gIE5vdEltcGxlbWVudGVkOiA1MDEsXFxuICBCYWRHYXRld2F5OiA1MDIsXFxuICBTZXJ2aWNlVW5hdmFpbGFibGU6IDUwMyxcXG4gIEdhdGV3YXlUaW1lb3V0OiA1MDQsXFxuICBIdHRwVmVyc2lvbk5vdFN1cHBvcnRlZDogNTA1LFxcbiAgVmFyaWFudEFsc29OZWdvdGlhdGVzOiA1MDYsXFxuICBJbnN1ZmZpY2llbnRTdG9yYWdlOiA1MDcsXFxuICBMb29wRGV0ZWN0ZWQ6IDUwOCxcXG4gIE5vdEV4dGVuZGVkOiA1MTAsXFxuICBOZXR3b3JrQXV0aGVudGljYXRpb25SZXF1aXJlZDogNTExLFxcbn07XFxuXFxuT2JqZWN0LmVudHJpZXMoSHR0cFN0YXR1c0NvZGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xcbiAgSHR0cFN0YXR1c0NvZGVbdmFsdWVdID0ga2V5O1xcbn0pO1xcblxcbnZhciBIdHRwU3RhdHVzQ29kZSQxID0gSHR0cFN0YXR1c0NvZGU7XFxuXFxuLyoqXFxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxcbiAqXFxuICogQHJldHVybnMge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xcbiAqL1xcbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcXG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgQXhpb3MkMShkZWZhdWx0Q29uZmlnKTtcXG4gIGNvbnN0IGluc3RhbmNlID0gYmluZChBeGlvcyQxLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcXG5cXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXFxuICB1dGlscyQxLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MkMS5wcm90b3R5cGUsIGNvbnRleHQsIHthbGxPd25LZXlzOiB0cnVlfSk7XFxuXFxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcXG4gIHV0aWxzJDEuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0LCBudWxsLCB7YWxsT3duS2V5czogdHJ1ZX0pO1xcblxcbiAgLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xcbiAgaW5zdGFuY2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XFxuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCBpbnN0YW5jZUNvbmZpZykpO1xcbiAgfTtcXG5cXG4gIHJldHVybiBpbnN0YW5jZTtcXG59XFxuXFxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXFxuY29uc3QgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyQxKTtcXG5cXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcXG5heGlvcy5BeGlvcyA9IEF4aW9zJDE7XFxuXFxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXFxuYXhpb3MuQ2FuY2VsZWRFcnJvciA9IENhbmNlbGVkRXJyb3I7XFxuYXhpb3MuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbiQxO1xcbmF4aW9zLmlzQ2FuY2VsID0gaXNDYW5jZWw7XFxuYXhpb3MuVkVSU0lPTiA9IFZFUlNJT047XFxuYXhpb3MudG9Gb3JtRGF0YSA9IHRvRm9ybURhdGE7XFxuXFxuLy8gRXhwb3NlIEF4aW9zRXJyb3IgY2xhc3NcXG5heGlvcy5BeGlvc0Vycm9yID0gQXhpb3NFcnJvcjtcXG5cXG4vLyBhbGlhcyBmb3IgQ2FuY2VsZWRFcnJvciBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxcbmF4aW9zLkNhbmNlbCA9IGF4aW9zLkNhbmNlbGVkRXJyb3I7XFxuXFxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcXG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XFxufTtcXG5cXG5heGlvcy5zcHJlYWQgPSBzcHJlYWQ7XFxuXFxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxcbmF4aW9zLmlzQXhpb3NFcnJvciA9IGlzQXhpb3NFcnJvcjtcXG5cXG4vLyBFeHBvc2UgbWVyZ2VDb25maWdcXG5heGlvcy5tZXJnZUNvbmZpZyA9IG1lcmdlQ29uZmlnO1xcblxcbmF4aW9zLkF4aW9zSGVhZGVycyA9IEF4aW9zSGVhZGVycyQxO1xcblxcbmF4aW9zLmZvcm1Ub0pTT04gPSB0aGluZyA9PiBmb3JtRGF0YVRvSlNPTih1dGlscyQxLmlzSFRNTEZvcm0odGhpbmcpID8gbmV3IEZvcm1EYXRhKHRoaW5nKSA6IHRoaW5nKTtcXG5cXG5heGlvcy5nZXRBZGFwdGVyID0gYWRhcHRlcnMuZ2V0QWRhcHRlcjtcXG5cXG5heGlvcy5IdHRwU3RhdHVzQ29kZSA9IEh0dHBTdGF0dXNDb2RlJDE7XFxuXFxuYXhpb3MuZGVmYXVsdCA9IGF4aW9zO1xcblxcbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXhpb3MuY2pzLm1hcFxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2lzcGFjZS8uL25vZGVfbW9kdWxlcy9heGlvcy9kaXN0L2Jyb3dzZXIvYXhpb3MuY2pzP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2dsb2JhbCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRcdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuLyoqKioqKi8gXHRcdFx0dHJ5IHtcbi8qKioqKiovIFx0XHRcdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4vKioqKioqLyBcdFx0XHR9IGNhdGNoIChlKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9KSgpO1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb3JlLnRzXCIpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=